
## Quick orientation

This repository is a large mono-repo containing the Grafana backend (Go) and frontend (TypeScript/React) plus many packages, plugins and dev tooling.
Focus areas for editing and automation:

- Backend: `pkg/` (server entry: `pkg/cmd/grafana`), build orchestration via `build.go` and the top-level `Makefile`.
- Frontend: `public/` and `packages/` (UI libs live under `packages/` and `@grafana/*` workspaces). Panel plugins are under `public/app/plugins/panel/` (e.g. `barchart`).
- Tooling: `package.json`, `Makefile`, `scripts/`, `devenv/` and `kinds/` (CUE) hold generation and dev workflows.

## What to know before making changes

- Monorepo tools: yarn (workspaces), nx, and lerna are used for JS packages. Use `yarn`/`nx` scripts from `package.json` for frontend work.
- The Go build uses `make` targets which call `go run build.go` and codegen (Wire, CUE). Check `Makefile` for canonical targets: `make deps`, `make build`, `make run`, `make test-go-unit`.
- Enterprise-specific code is gated by the presence of files like `pkg/extensions/ext.go` and `public/app/extensions/index.ts`. Many Makefile targets switch behavior based on these.
- Tests are split: backend Go tests (`make test-go-unit`, `make test-go-integration`) and frontend tests (`yarn test`, `yarn playwright test`, `./e2e/start-and-run-suite`). CI test sharding uses `SHARD`/`SHARDS` env vars.

## Common commands and where to run them

- Install deps: `make deps` (runs `yarn install` and Go setup). Frontend-only: `make deps-js` or `yarn`.
- Build everything: `make build` (builds Go + frontend). For quick frontend dev: `yarn start` (or `make run-frontend`).
- Run backend locally: `make run` (uses `air` per `.air.toml`) or `make run-go` to run the server directly.
- Run unit tests (backend): `make test-go-unit`. For frontend Jest: `yarn test` (or `yarn test:ci` in CI).
- Run playwright e2e: `yarn playwright test` or `yarn e2e:playwright`. For the long e2e harness: `yarn e2e` (invokes `./e2e/start-and-run-suite`).

## Codegen and generation points (important to keep in sync)

- Wire DI graphs: `make gen-go` (calls `pkg/build/wire` generator). File: `pkg/build/wire`.
- CUE/Thema generation: `make gen-cue` and `make gen-cuev2`. Look at `kinds/` and `kindsv2/` for source models.
- OpenAPI/Swagger: `make swagger-gen` writes to `public/api-spec.json`. API server code under `pkg/server`.
- Feature toggles and other generated tests exist; `make gen-feature-toggles` may re-run tests during generation.
- Start all copilot generated codeblocks with `// Code generated by copilot` .
- End all copilot generated codeblocks with `// End of copilot-generated code`.

## Patterns and repo conventions useful for automated edits

- Feature gating: Use the same presence checks as the Makefile (`wildcard` checks for enterprise files) when your edits need to handle enterprise vs OSS.
- Plugins: Panel plugins live at `public/app/plugins/panel/<plugin>/` and usually include a `README.md`. Prefer editing plugin code in-place and follow existing `README.md` patterns.
- TypeScript/React packages: Many internal packages are `workspace:*` in `package.json`. Use `nx` and workspace-aware scripts when adding packages or changing tsconfig settings.
- Linting & formatting: `yarn lint` (TS) and `prettier`. For Go: `gofmt` and `golangci-lint` via `make lint-go`.

## Integration points & external dependencies

- Datasources & services: Prometheus, Loki, Tempo, Alertmanager are referenced through tests and dev containers (see `devenv/docker/blocks`). Integration tests frequently expect services available at common ports; consult `Makefile` integration targets for required env vars (e.g., `GRAFANA_TEST_DB`, `REDIS_URL`).
- Plugins are decoupled and can be built separately with `mage` in `pkg/tsdb` or via `nx` workspace scripts for JS plugins.

## Code reading shortcuts (where to find intent & flow)

- Server entry and routing/handlers: `pkg/cmd/grafana` and `pkg/server`.
- API models and OpenAPI generation: `pkg/api`, `pkg/server`, and the swagger targets in the `Makefile` that output `public/api-spec.json`.
- Frontend core/runtime: `packages/grafana-runtime`, UI components: `packages/grafana-ui`, shared data contracts: `packages/grafana-data`.
- Panel plugin examples: `public/app/plugins/panel/barchart/` (contains TS files & `README.md`) and many other panel folders under `public/app/plugins/panel/`.

## Plugin creation & development (panel plugins)

This repo contains many panel plugins. When creating or iterating on a plugin, prefer copying an existing plugin (for example `public/app/plugins/panel/barchart/`) as a starting point and follow these concrete steps:

1. Files & placement
	- Create the plugin under `public/app/plugins/panel/<your-plugin>/`.
	- Include a short `README.md`, the plugin entry (existing plugins use `module.ts`/`module.tsx` or `index.ts`), and a `plugin.json` manifest.
	- Put UI components and styles next to the entry under `components/`, `styles/` or `hooks/` inside the plugin folder to keep things local and easy to copy.

2. Local dev & hot-reload
	- Install deps and run the frontend dev server in repository root:

	  yarn
	  yarn start

	- Edit the plugin files; webpack (used by `yarn start`) watches the workspace and will rebuild the frontend bundle. For library-level development you can also use `nx` project dev targets (see `package.json` scripts like `plugin:build:dev`).

3. Typechecking, linting & tests
	- Typecheck across the monorepo: `yarn typecheck`.
	- Lint TypeScript/Sass: `yarn lint` / `yarn lint:fix`.
	- Run Jest unit tests (frontend): `yarn test`. Use `yarn plugin:test:ci` / `nx` for plugin-scoped CI-style runs.

4. Building and packaging
	- Build frontend artifacts for the full app: `yarn build` (or `make build` for full backend+frontend).
	- Build plugin artifacts via NX/Lerna: `nx run-many -t build --projects='tag:scope:plugin'` (exposed via `yarn plugin:build`).
	- Decoupled Go/TS plugins: backend plugin builds are done with `mage` in `pkg/tsdb` — See the `make build-plugin-go` target which delegates to `pkg/tsdb` mage tasks.

5. Examples & patterns to copy from
	- `public/app/plugins/panel/barchart/` — good example of a complex panel plugin: UI component structure, plugin manifest and README.
	- `public/app/plugins/panel/gettingstarted/` — smallest example scaffold for a minimal plugin.

6. Common pitfalls
	- When adding new package dependencies, update workspace manifests and ensure `yarn install` completes (`yarn` uses workspaces). Some packages are `workspace:*`; prefer internal libs (e.g., `@grafana/ui`) where possible.
	- If the plugin fails to load in the dev server, check console/webpack output for module resolution issues and cross-package path aliases (tsconfig paths).
	- When changing public API shapes (props, data frames), add/adjust TypeScript types under `packages/grafana-data` or `packages/grafana-ui` when shared across plugins.


## Quick examples to reference in PRs or edits

- When you change a backend API shape, update the swagger targets and run `make swagger-gen` then `make build` so generated clients and docs stay in sync.
- For frontend UI changes, run `yarn start` and `yarn typecheck` locally; run `yarn test` for unit tests and `yarn playwright test` for e2e selectors.

## Useful docs to link to

- Developer setup: `contribute/developer-guide.md`
- Monorepo & package readmes: `packages/README.md` and package-specific README files (e.g., `packages/grafana-ui/README.md`).

## When to ask for human help

- Large refactors affecting CUE generation, Wire graphs or OpenAPI generation. These touch cross-cutting generated files and CI.
- Changes that affect enterprise gating (presence/absence of enterprise files). These require repo owners' review.

If anything here is unclear or you want more examples (for example, a short recipe for making a new panel plugin or adding a backend API handler), say which area and I will expand with concrete file-level examples.

## Assistant instructions: Bar-chart marker feature

When asked to add a small "marker" feature to the bar-chart plugin, the assistant should follow these concrete rules and keep changes minimal and localized.

- Scope: implement all changes under `public/app/plugins/panel/barchart/`. Create a single module (for example `barMarkers.ts` or a `markers/` folder) that contains rendering, hit-testing, and config parsing.

- Hooking & rendering: prefer registering a draw hook with the existing builder (`builder.addHook('draw', ...)`) or providing a small `pathBuilder`/marker painter wired into the series config. Avoid altering global uPlot behavior. Use the chart's `u.bbox` translation and reuse the existing quadtree for marker hit-testing and hover integration.

- Configuration: add new fields to `panelcfg.gen.ts` for marker options (manual vs auto, appearance, target series/groups). Read those options in `prepConfig` / `getConfig` so marker configuration is persisted and type-checked. Keep UI edits minimal and plugin-scoped.

- Data alignment: support manual marker entries and markers derived from input fields. Prefer computing derived markers in `prepData` so marker positions align to `dataIdx` and the aligned data produced by `builder.prepData`.

- Tests: add a small, local smoke/unit test that validates the draw hook runs and that a marker is rendered for a sample aligned dataset. Keep tests inside the plugin folder and avoid CI-wide changes.

- Safety and escalation: do not change CUE/OpenAPI/Wire generators or enterprise gating files. If a requested change requires cross-cutting generation or build-system edits, stop and ask a repo owner.

These instructions are for the assistant to follow when implementing the feature in code or creating patches; keep edits small, well-scoped, and reversible.
