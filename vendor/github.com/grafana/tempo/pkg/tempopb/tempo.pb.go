// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/tempopb/tempo.proto

package tempopb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v1 "github.com/grafana/tempo/pkg/tempopb/common/v1"
	v11 "github.com/grafana/tempo/pkg/tempopb/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PushErrorReason int32

const (
	PushErrorReason_NO_ERROR        PushErrorReason = 0
	PushErrorReason_MAX_LIVE_TRACES PushErrorReason = 1
	PushErrorReason_TRACE_TOO_LARGE PushErrorReason = 2
	PushErrorReason_UNKNOWN_ERROR   PushErrorReason = 3
)

var PushErrorReason_name = map[int32]string{
	0: "NO_ERROR",
	1: "MAX_LIVE_TRACES",
	2: "TRACE_TOO_LARGE",
	3: "UNKNOWN_ERROR",
}

var PushErrorReason_value = map[string]int32{
	"NO_ERROR":        0,
	"MAX_LIVE_TRACES": 1,
	"TRACE_TOO_LARGE": 2,
	"UNKNOWN_ERROR":   3,
}

func (x PushErrorReason) String() string {
	return proto.EnumName(PushErrorReason_name, int32(x))
}

func (PushErrorReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}

type PartialStatus int32

const (
	PartialStatus_COMPLETE PartialStatus = 0
	PartialStatus_PARTIAL  PartialStatus = 1
)

var PartialStatus_name = map[int32]string{
	0: "COMPLETE",
	1: "PARTIAL",
}

var PartialStatus_value = map[string]int32{
	"COMPLETE": 0,
	"PARTIAL":  1,
}

func (x PartialStatus) String() string {
	return proto.EnumName(PartialStatus_name, int32(x))
}

func (PartialStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}

type DedicatedColumn_Scope int32

const (
	DedicatedColumn_SPAN     DedicatedColumn_Scope = 0
	DedicatedColumn_RESOURCE DedicatedColumn_Scope = 1
)

var DedicatedColumn_Scope_name = map[int32]string{
	0: "SPAN",
	1: "RESOURCE",
}

var DedicatedColumn_Scope_value = map[string]int32{
	"SPAN":     0,
	"RESOURCE": 1,
}

func (x DedicatedColumn_Scope) String() string {
	return proto.EnumName(DedicatedColumn_Scope_name, int32(x))
}

func (DedicatedColumn_Scope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 0}
}

type DedicatedColumn_Type int32

const (
	DedicatedColumn_STRING DedicatedColumn_Type = 0
)

var DedicatedColumn_Type_name = map[int32]string{
	0: "STRING",
}

var DedicatedColumn_Type_value = map[string]int32{
	"STRING": 0,
}

func (x DedicatedColumn_Type) String() string {
	return proto.EnumName(DedicatedColumn_Type_name, int32(x))
}

func (DedicatedColumn_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5, 1}
}

// Read
type TraceByIDRequest struct {
	TraceID           []byte `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	BlockStart        string `protobuf:"bytes,2,opt,name=blockStart,proto3" json:"blockStart,omitempty"`
	BlockEnd          string `protobuf:"bytes,3,opt,name=blockEnd,proto3" json:"blockEnd,omitempty"`
	QueryMode         string `protobuf:"bytes,5,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
	AllowPartialTrace bool   `protobuf:"varint,6,opt,name=allowPartialTrace,proto3" json:"allowPartialTrace,omitempty"`
	// Rhythm fields
	RF1After time.Time `protobuf:"bytes,7,opt,name=RF1After,proto3,stdtime" json:"RF1After"`
}

func (m *TraceByIDRequest) Reset()         { *m = TraceByIDRequest{} }
func (m *TraceByIDRequest) String() string { return proto.CompactTextString(m) }
func (*TraceByIDRequest) ProtoMessage()    {}
func (*TraceByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{0}
}
func (m *TraceByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDRequest.Merge(m, src)
}
func (m *TraceByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDRequest proto.InternalMessageInfo

func (m *TraceByIDRequest) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *TraceByIDRequest) GetBlockStart() string {
	if m != nil {
		return m.BlockStart
	}
	return ""
}

func (m *TraceByIDRequest) GetBlockEnd() string {
	if m != nil {
		return m.BlockEnd
	}
	return ""
}

func (m *TraceByIDRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

func (m *TraceByIDRequest) GetAllowPartialTrace() bool {
	if m != nil {
		return m.AllowPartialTrace
	}
	return false
}

func (m *TraceByIDRequest) GetRF1After() time.Time {
	if m != nil {
		return m.RF1After
	}
	return time.Time{}
}

type TraceByIDResponse struct {
	Trace   *Trace            `protobuf:"bytes,1,opt,name=trace,proto3" json:"trace,omitempty"`
	Metrics *TraceByIDMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
	Status  PartialStatus     `protobuf:"varint,3,opt,name=status,proto3,enum=tempopb.PartialStatus" json:"status,omitempty"`
	Message string            `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TraceByIDResponse) Reset()         { *m = TraceByIDResponse{} }
func (m *TraceByIDResponse) String() string { return proto.CompactTextString(m) }
func (*TraceByIDResponse) ProtoMessage()    {}
func (*TraceByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{1}
}
func (m *TraceByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDResponse.Merge(m, src)
}
func (m *TraceByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDResponse proto.InternalMessageInfo

func (m *TraceByIDResponse) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

func (m *TraceByIDResponse) GetMetrics() *TraceByIDMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *TraceByIDResponse) GetStatus() PartialStatus {
	if m != nil {
		return m.Status
	}
	return PartialStatus_COMPLETE
}

func (m *TraceByIDResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type TraceByIDMetrics struct {
	InspectedBytes uint64 `protobuf:"varint,1,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
}

func (m *TraceByIDMetrics) Reset()         { *m = TraceByIDMetrics{} }
func (m *TraceByIDMetrics) String() string { return proto.CompactTextString(m) }
func (*TraceByIDMetrics) ProtoMessage()    {}
func (*TraceByIDMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{2}
}
func (m *TraceByIDMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceByIDMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceByIDMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceByIDMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceByIDMetrics.Merge(m, src)
}
func (m *TraceByIDMetrics) XXX_Size() int {
	return m.Size()
}
func (m *TraceByIDMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceByIDMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_TraceByIDMetrics proto.InternalMessageInfo

func (m *TraceByIDMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

// SearchRequest takes no block parameters and implies a "recent traces" search
type SearchRequest struct {
	// case insensitive partial match
	Tags          map[string]string `protobuf:"bytes,1,rep,name=Tags,proto3" json:"Tags" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MinDurationMs uint32            `protobuf:"varint,2,opt,name=MinDurationMs,proto3" json:"MinDurationMs,omitempty"`
	MaxDurationMs uint32            `protobuf:"varint,3,opt,name=MaxDurationMs,proto3" json:"MaxDurationMs,omitempty"`
	Limit         uint32            `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Start         uint32            `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	End           uint32            `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
	// TraceQL query
	Query           string `protobuf:"bytes,8,opt,name=Query,proto3" json:"Query,omitempty"`
	SpansPerSpanSet uint32 `protobuf:"varint,9,opt,name=SpansPerSpanSet,proto3" json:"SpansPerSpanSet,omitempty"`
	// Rhythm fields
	RF1After time.Time `protobuf:"bytes,10,opt,name=RF1After,proto3,stdtime" json:"RF1After"`
}

func (m *SearchRequest) Reset()         { *m = SearchRequest{} }
func (m *SearchRequest) String() string { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()    {}
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{3}
}
func (m *SearchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchRequest.Merge(m, src)
}
func (m *SearchRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchRequest proto.InternalMessageInfo

func (m *SearchRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchRequest) GetMinDurationMs() uint32 {
	if m != nil {
		return m.MinDurationMs
	}
	return 0
}

func (m *SearchRequest) GetMaxDurationMs() uint32 {
	if m != nil {
		return m.MaxDurationMs
	}
	return 0
}

func (m *SearchRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchRequest) GetSpansPerSpanSet() uint32 {
	if m != nil {
		return m.SpansPerSpanSet
	}
	return 0
}

func (m *SearchRequest) GetRF1After() time.Time {
	if m != nil {
		return m.RF1After
	}
	return time.Time{}
}

// SearchBlockRequest takes SearchRequest parameters as well as all information
// necessary to search a block in the backend.
type SearchBlockRequest struct {
	SearchReq        *SearchRequest     `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchBlockRequest) Reset()         { *m = SearchBlockRequest{} }
func (m *SearchBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchBlockRequest) ProtoMessage()    {}
func (*SearchBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{4}
}
func (m *SearchBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBlockRequest.Merge(m, src)
}
func (m *SearchBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBlockRequest proto.InternalMessageInfo

func (m *SearchBlockRequest) GetSearchReq() *SearchRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

// Configuration for a single dedicated attribute column.
type DedicatedColumn struct {
	Scope DedicatedColumn_Scope `protobuf:"varint,3,opt,name=scope,proto3,enum=tempopb.DedicatedColumn_Scope" json:"scope,omitempty"`
	Name  string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type  DedicatedColumn_Type  `protobuf:"varint,1,opt,name=type,proto3,enum=tempopb.DedicatedColumn_Type" json:"type,omitempty"`
}

func (m *DedicatedColumn) Reset()         { *m = DedicatedColumn{} }
func (m *DedicatedColumn) String() string { return proto.CompactTextString(m) }
func (*DedicatedColumn) ProtoMessage()    {}
func (*DedicatedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{5}
}
func (m *DedicatedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DedicatedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DedicatedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedColumn.Merge(m, src)
}
func (m *DedicatedColumn) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedColumn proto.InternalMessageInfo

func (m *DedicatedColumn) GetScope() DedicatedColumn_Scope {
	if m != nil {
		return m.Scope
	}
	return DedicatedColumn_SPAN
}

func (m *DedicatedColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DedicatedColumn) GetType() DedicatedColumn_Type {
	if m != nil {
		return m.Type
	}
	return DedicatedColumn_STRING
}

type SearchResponse struct {
	Traces  []*TraceSearchMetadata `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
	Metrics *SearchMetrics         `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{6}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetTraces() []*TraceSearchMetadata {
	if m != nil {
		return m.Traces
	}
	return nil
}

func (m *SearchResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TraceSearchMetadata struct {
	TraceID           string                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	RootServiceName   string                   `protobuf:"bytes,2,opt,name=rootServiceName,proto3" json:"rootServiceName,omitempty"`
	RootTraceName     string                   `protobuf:"bytes,3,opt,name=rootTraceName,proto3" json:"rootTraceName,omitempty"`
	StartTimeUnixNano uint64                   `protobuf:"varint,4,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationMs        uint32                   `protobuf:"varint,5,opt,name=durationMs,proto3" json:"durationMs,omitempty"`
	SpanSet           *SpanSet                 `protobuf:"bytes,6,opt,name=spanSet,proto3" json:"spanSet,omitempty"`
	SpanSets          []*SpanSet               `protobuf:"bytes,7,rep,name=spanSets,proto3" json:"spanSets,omitempty"`
	ServiceStats      map[string]*ServiceStats `protobuf:"bytes,8,rep,name=serviceStats,proto3" json:"serviceStats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TraceSearchMetadata) Reset()         { *m = TraceSearchMetadata{} }
func (m *TraceSearchMetadata) String() string { return proto.CompactTextString(m) }
func (*TraceSearchMetadata) ProtoMessage()    {}
func (*TraceSearchMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{7}
}
func (m *TraceSearchMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceSearchMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceSearchMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceSearchMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceSearchMetadata.Merge(m, src)
}
func (m *TraceSearchMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TraceSearchMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceSearchMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TraceSearchMetadata proto.InternalMessageInfo

func (m *TraceSearchMetadata) GetTraceID() string {
	if m != nil {
		return m.TraceID
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootServiceName() string {
	if m != nil {
		return m.RootServiceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetRootTraceName() string {
	if m != nil {
		return m.RootTraceName
	}
	return ""
}

func (m *TraceSearchMetadata) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *TraceSearchMetadata) GetDurationMs() uint32 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

func (m *TraceSearchMetadata) GetSpanSet() *SpanSet {
	if m != nil {
		return m.SpanSet
	}
	return nil
}

func (m *TraceSearchMetadata) GetSpanSets() []*SpanSet {
	if m != nil {
		return m.SpanSets
	}
	return nil
}

func (m *TraceSearchMetadata) GetServiceStats() map[string]*ServiceStats {
	if m != nil {
		return m.ServiceStats
	}
	return nil
}

type ServiceStats struct {
	SpanCount  uint32 `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorCount uint32 `protobuf:"varint,2,opt,name=errorCount,proto3" json:"errorCount,omitempty"`
}

func (m *ServiceStats) Reset()         { *m = ServiceStats{} }
func (m *ServiceStats) String() string { return proto.CompactTextString(m) }
func (*ServiceStats) ProtoMessage()    {}
func (*ServiceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{8}
}
func (m *ServiceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceStats.Merge(m, src)
}
func (m *ServiceStats) XXX_Size() int {
	return m.Size()
}
func (m *ServiceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceStats.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceStats proto.InternalMessageInfo

func (m *ServiceStats) GetSpanCount() uint32 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *ServiceStats) GetErrorCount() uint32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

type SpanSet struct {
	Spans      []*Span        `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans,omitempty"`
	Matched    uint32         `protobuf:"varint,2,opt,name=matched,proto3" json:"matched,omitempty"`
	Attributes []*v1.KeyValue `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *SpanSet) Reset()         { *m = SpanSet{} }
func (m *SpanSet) String() string { return proto.CompactTextString(m) }
func (*SpanSet) ProtoMessage()    {}
func (*SpanSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{9}
}
func (m *SpanSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanSet.Merge(m, src)
}
func (m *SpanSet) XXX_Size() int {
	return m.Size()
}
func (m *SpanSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanSet.DiscardUnknown(m)
}

var xxx_messageInfo_SpanSet proto.InternalMessageInfo

func (m *SpanSet) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *SpanSet) GetMatched() uint32 {
	if m != nil {
		return m.Matched
	}
	return 0
}

func (m *SpanSet) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Span struct {
	SpanID            string         `protobuf:"bytes,1,opt,name=spanID,proto3" json:"spanID,omitempty"`
	Name              string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	StartTimeUnixNano uint64         `protobuf:"varint,3,opt,name=startTimeUnixNano,proto3" json:"startTimeUnixNano,omitempty"`
	DurationNanos     uint64         `protobuf:"varint,4,opt,name=durationNanos,proto3" json:"durationNanos,omitempty"`
	Attributes        []*v1.KeyValue `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{10}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetSpanID() string {
	if m != nil {
		return m.SpanID
	}
	return ""
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Span) GetDurationNanos() uint64 {
	if m != nil {
		return m.DurationNanos
	}
	return 0
}

func (m *Span) GetAttributes() []*v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SearchMetrics struct {
	InspectedTraces uint32 `protobuf:"varint,1,opt,name=inspectedTraces,proto3" json:"inspectedTraces,omitempty"`
	InspectedBytes  uint64 `protobuf:"varint,2,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,3,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,4,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,5,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,6,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
	InspectedSpans  uint64 `protobuf:"varint,7,opt,name=inspectedSpans,proto3" json:"inspectedSpans,omitempty"`
}

func (m *SearchMetrics) Reset()         { *m = SearchMetrics{} }
func (m *SearchMetrics) String() string { return proto.CompactTextString(m) }
func (*SearchMetrics) ProtoMessage()    {}
func (*SearchMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{11}
}
func (m *SearchMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMetrics.Merge(m, src)
}
func (m *SearchMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SearchMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMetrics proto.InternalMessageInfo

func (m *SearchMetrics) GetInspectedTraces() uint32 {
	if m != nil {
		return m.InspectedTraces
	}
	return 0
}

func (m *SearchMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *SearchMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *SearchMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

func (m *SearchMetrics) GetInspectedSpans() uint64 {
	if m != nil {
		return m.InspectedSpans
	}
	return 0
}

type SearchTagsRequest struct {
	Scope                string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	Query                string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Start                uint32 `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint32 `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
	MaxTagsPerScope      uint32 `protobuf:"varint,5,opt,name=maxTagsPerScope,proto3" json:"maxTagsPerScope,omitempty"`
	StaleValuesThreshold uint32 `protobuf:"varint,6,opt,name=staleValuesThreshold,proto3" json:"staleValuesThreshold,omitempty"`
	// Rhythm fields
	RF1After time.Time `protobuf:"bytes,7,opt,name=RF1After,proto3,stdtime" json:"RF1After"`
}

func (m *SearchTagsRequest) Reset()         { *m = SearchTagsRequest{} }
func (m *SearchTagsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsRequest) ProtoMessage()    {}
func (*SearchTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{12}
}
func (m *SearchTagsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsRequest.Merge(m, src)
}
func (m *SearchTagsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsRequest proto.InternalMessageInfo

func (m *SearchTagsRequest) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *SearchTagsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchTagsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchTagsRequest) GetMaxTagsPerScope() uint32 {
	if m != nil {
		return m.MaxTagsPerScope
	}
	return 0
}

func (m *SearchTagsRequest) GetStaleValuesThreshold() uint32 {
	if m != nil {
		return m.StaleValuesThreshold
	}
	return 0
}

func (m *SearchTagsRequest) GetRF1After() time.Time {
	if m != nil {
		return m.RF1After
	}
	return time.Time{}
}

// SearchTagsBlockRequest takes SearchTagsRequest parameters as well as all information necessary
// to search a block in the backend.
type SearchTagsBlockRequest struct {
	SearchReq           *SearchTagsRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID             string             `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage           uint32             `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch       uint32             `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding            string             `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize       uint32             `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords        uint32             `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding        string             `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version             string             `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_               uint64             `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize          uint32             `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns    []*DedicatedColumn `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
	MaxTagsPerScope     uint32             `protobuf:"varint,13,opt,name=maxTagsPerScope,proto3" json:"maxTagsPerScope,omitempty"`
	StaleValueThreshold uint32             `protobuf:"varint,14,opt,name=staleValueThreshold,proto3" json:"staleValueThreshold,omitempty"`
}

func (m *SearchTagsBlockRequest) Reset()         { *m = SearchTagsBlockRequest{} }
func (m *SearchTagsBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagsBlockRequest) ProtoMessage()    {}
func (*SearchTagsBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{13}
}
func (m *SearchTagsBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsBlockRequest.Merge(m, src)
}
func (m *SearchTagsBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsBlockRequest proto.InternalMessageInfo

func (m *SearchTagsBlockRequest) GetSearchReq() *SearchTagsRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagsBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagsBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

func (m *SearchTagsBlockRequest) GetMaxTagsPerScope() uint32 {
	if m != nil {
		return m.MaxTagsPerScope
	}
	return 0
}

func (m *SearchTagsBlockRequest) GetStaleValueThreshold() uint32 {
	if m != nil {
		return m.StaleValueThreshold
	}
	return 0
}

type SearchTagValuesBlockRequest struct {
	SearchReq        *SearchTagValuesRequest `protobuf:"bytes,1,opt,name=searchReq,proto3" json:"searchReq,omitempty"`
	BlockID          string                  `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32                  `protobuf:"varint,3,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32                  `protobuf:"varint,4,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Encoding         string                  `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	IndexPageSize    uint32                  `protobuf:"varint,6,opt,name=indexPageSize,proto3" json:"indexPageSize,omitempty"`
	TotalRecords     uint32                  `protobuf:"varint,7,opt,name=totalRecords,proto3" json:"totalRecords,omitempty"`
	DataEncoding     string                  `protobuf:"bytes,8,opt,name=dataEncoding,proto3" json:"dataEncoding,omitempty"`
	Version          string                  `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_            uint64                  `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32                  `protobuf:"varint,11,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn      `protobuf:"bytes,12,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
}

func (m *SearchTagValuesBlockRequest) Reset()         { *m = SearchTagValuesBlockRequest{} }
func (m *SearchTagValuesBlockRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesBlockRequest) ProtoMessage()    {}
func (*SearchTagValuesBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{14}
}
func (m *SearchTagValuesBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesBlockRequest.Merge(m, src)
}
func (m *SearchTagValuesBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesBlockRequest proto.InternalMessageInfo

func (m *SearchTagValuesBlockRequest) GetSearchReq() *SearchTagValuesRequest {
	if m != nil {
		return m.SearchReq
	}
	return nil
}

func (m *SearchTagValuesBlockRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetIndexPageSize() uint32 {
	if m != nil {
		return m.IndexPageSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetTotalRecords() uint32 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDataEncoding() string {
	if m != nil {
		return m.DataEncoding
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SearchTagValuesBlockRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *SearchTagValuesBlockRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

type SearchTagsResponse struct {
	TagNames []string         `protobuf:"bytes,1,rep,name=tagNames,proto3" json:"tagNames,omitempty"`
	Metrics  *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagsResponse) Reset()         { *m = SearchTagsResponse{} }
func (m *SearchTagsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagsResponse) ProtoMessage()    {}
func (*SearchTagsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{15}
}
func (m *SearchTagsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsResponse.Merge(m, src)
}
func (m *SearchTagsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsResponse proto.InternalMessageInfo

func (m *SearchTagsResponse) GetTagNames() []string {
	if m != nil {
		return m.TagNames
	}
	return nil
}

func (m *SearchTagsResponse) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type SearchTagsV2Response struct {
	Scopes  []*SearchTagsV2Scope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes,omitempty"`
	Metrics *MetadataMetrics     `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagsV2Response) Reset()         { *m = SearchTagsV2Response{} }
func (m *SearchTagsV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Response) ProtoMessage()    {}
func (*SearchTagsV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{16}
}
func (m *SearchTagsV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Response.Merge(m, src)
}
func (m *SearchTagsV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Response proto.InternalMessageInfo

func (m *SearchTagsV2Response) GetScopes() []*SearchTagsV2Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *SearchTagsV2Response) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type SearchTagsV2Scope struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Tags []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *SearchTagsV2Scope) Reset()         { *m = SearchTagsV2Scope{} }
func (m *SearchTagsV2Scope) String() string { return proto.CompactTextString(m) }
func (*SearchTagsV2Scope) ProtoMessage()    {}
func (*SearchTagsV2Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{17}
}
func (m *SearchTagsV2Scope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagsV2Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagsV2Scope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagsV2Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagsV2Scope.Merge(m, src)
}
func (m *SearchTagsV2Scope) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagsV2Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagsV2Scope.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagsV2Scope proto.InternalMessageInfo

func (m *SearchTagsV2Scope) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchTagsV2Scope) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type SearchTagValuesRequest struct {
	TagName             string `protobuf:"bytes,1,opt,name=tagName,proto3" json:"tagName,omitempty"`
	Query               string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Start               uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End                 uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	MaxTagValues        uint32 `protobuf:"varint,6,opt,name=maxTagValues,proto3" json:"maxTagValues,omitempty"`
	StaleValueThreshold uint32 `protobuf:"varint,7,opt,name=staleValueThreshold,proto3" json:"staleValueThreshold,omitempty"`
	// Rhythm fields
	RF1After time.Time `protobuf:"bytes,8,opt,name=RF1After,proto3,stdtime" json:"RF1After"`
}

func (m *SearchTagValuesRequest) Reset()         { *m = SearchTagValuesRequest{} }
func (m *SearchTagValuesRequest) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesRequest) ProtoMessage()    {}
func (*SearchTagValuesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{18}
}
func (m *SearchTagValuesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesRequest.Merge(m, src)
}
func (m *SearchTagValuesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesRequest proto.InternalMessageInfo

func (m *SearchTagValuesRequest) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *SearchTagValuesRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SearchTagValuesRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchTagValuesRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchTagValuesRequest) GetMaxTagValues() uint32 {
	if m != nil {
		return m.MaxTagValues
	}
	return 0
}

func (m *SearchTagValuesRequest) GetStaleValueThreshold() uint32 {
	if m != nil {
		return m.StaleValueThreshold
	}
	return 0
}

func (m *SearchTagValuesRequest) GetRF1After() time.Time {
	if m != nil {
		return m.RF1After
	}
	return time.Time{}
}

type SearchTagValuesResponse struct {
	TagValues []string         `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
	Metrics   *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagValuesResponse) Reset()         { *m = SearchTagValuesResponse{} }
func (m *SearchTagValuesResponse) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesResponse) ProtoMessage()    {}
func (*SearchTagValuesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{19}
}
func (m *SearchTagValuesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesResponse.Merge(m, src)
}
func (m *SearchTagValuesResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesResponse proto.InternalMessageInfo

func (m *SearchTagValuesResponse) GetTagValues() []string {
	if m != nil {
		return m.TagValues
	}
	return nil
}

func (m *SearchTagValuesResponse) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type TagValue struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TagValue) Reset()         { *m = TagValue{} }
func (m *TagValue) String() string { return proto.CompactTextString(m) }
func (*TagValue) ProtoMessage()    {}
func (*TagValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{20}
}
func (m *TagValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagValue.Merge(m, src)
}
func (m *TagValue) XXX_Size() int {
	return m.Size()
}
func (m *TagValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TagValue.DiscardUnknown(m)
}

var xxx_messageInfo_TagValue proto.InternalMessageInfo

func (m *TagValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TagValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SearchTagValuesV2Response struct {
	TagValues []*TagValue      `protobuf:"bytes,1,rep,name=tagValues,proto3" json:"tagValues,omitempty"`
	Metrics   *MetadataMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SearchTagValuesV2Response) Reset()         { *m = SearchTagValuesV2Response{} }
func (m *SearchTagValuesV2Response) String() string { return proto.CompactTextString(m) }
func (*SearchTagValuesV2Response) ProtoMessage()    {}
func (*SearchTagValuesV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{21}
}
func (m *SearchTagValuesV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchTagValuesV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchTagValuesV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchTagValuesV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchTagValuesV2Response.Merge(m, src)
}
func (m *SearchTagValuesV2Response) XXX_Size() int {
	return m.Size()
}
func (m *SearchTagValuesV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchTagValuesV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_SearchTagValuesV2Response proto.InternalMessageInfo

func (m *SearchTagValuesV2Response) GetTagValues() []*TagValue {
	if m != nil {
		return m.TagValues
	}
	return nil
}

func (m *SearchTagValuesV2Response) GetMetrics() *MetadataMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type MetadataMetrics struct {
	InspectedBytes  uint64 `protobuf:"varint,1,opt,name=inspectedBytes,proto3" json:"inspectedBytes,omitempty"`
	TotalJobs       uint32 `protobuf:"varint,2,opt,name=totalJobs,proto3" json:"totalJobs,omitempty"`
	CompletedJobs   uint32 `protobuf:"varint,3,opt,name=completedJobs,proto3" json:"completedJobs,omitempty"`
	TotalBlocks     uint32 `protobuf:"varint,4,opt,name=totalBlocks,proto3" json:"totalBlocks,omitempty"`
	TotalBlockBytes uint64 `protobuf:"varint,5,opt,name=totalBlockBytes,proto3" json:"totalBlockBytes,omitempty"`
}

func (m *MetadataMetrics) Reset()         { *m = MetadataMetrics{} }
func (m *MetadataMetrics) String() string { return proto.CompactTextString(m) }
func (*MetadataMetrics) ProtoMessage()    {}
func (*MetadataMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{22}
}
func (m *MetadataMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataMetrics.Merge(m, src)
}
func (m *MetadataMetrics) XXX_Size() int {
	return m.Size()
}
func (m *MetadataMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataMetrics proto.InternalMessageInfo

func (m *MetadataMetrics) GetInspectedBytes() uint64 {
	if m != nil {
		return m.InspectedBytes
	}
	return 0
}

func (m *MetadataMetrics) GetTotalJobs() uint32 {
	if m != nil {
		return m.TotalJobs
	}
	return 0
}

func (m *MetadataMetrics) GetCompletedJobs() uint32 {
	if m != nil {
		return m.CompletedJobs
	}
	return 0
}

func (m *MetadataMetrics) GetTotalBlocks() uint32 {
	if m != nil {
		return m.TotalBlocks
	}
	return 0
}

func (m *MetadataMetrics) GetTotalBlockBytes() uint64 {
	if m != nil {
		return m.TotalBlockBytes
	}
	return 0
}

type Trace struct {
	ResourceSpans []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=resourceSpans,proto3" json:"resourceSpans,omitempty"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{23}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetResourceSpans() []*v11.ResourceSpans {
	if m != nil {
		return m.ResourceSpans
	}
	return nil
}

// Write
type PushResponse struct {
	ErrorsByTrace []PushErrorReason `protobuf:"varint,1,rep,packed,name=errorsByTrace,proto3,enum=tempopb.PushErrorReason" json:"errorsByTrace,omitempty"`
}

func (m *PushResponse) Reset()         { *m = PushResponse{} }
func (m *PushResponse) String() string { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()    {}
func (*PushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{24}
}
func (m *PushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushResponse.Merge(m, src)
}
func (m *PushResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushResponse proto.InternalMessageInfo

func (m *PushResponse) GetErrorsByTrace() []PushErrorReason {
	if m != nil {
		return m.ErrorsByTrace
	}
	return nil
}

// PushBytesRequest pushes slices of traces, ids and searchdata. Traces are
// encoded using the
//  current BatchDecoder in ./pkg/model
type PushBytesRequest struct {
	// pre-marshalled Traces. length must match ids
	Traces []PreallocBytes `protobuf:"bytes,2,rep,name=traces,proto3,customtype=PreallocBytes" json:"traces"`
	// trace ids. length must match traces
	Ids [][]byte `protobuf:"bytes,3,rep,name=ids,proto3" json:"ids,omitempty"`
	// indicates whether metrics generation should be skipped
	// for traces contained in this request.
	SkipMetricsGeneration bool `protobuf:"varint,5,opt,name=skipMetricsGeneration,proto3" json:"skipMetricsGeneration,omitempty"`
}

func (m *PushBytesRequest) Reset()         { *m = PushBytesRequest{} }
func (m *PushBytesRequest) String() string { return proto.CompactTextString(m) }
func (*PushBytesRequest) ProtoMessage()    {}
func (*PushBytesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{25}
}
func (m *PushBytesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushBytesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushBytesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushBytesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBytesRequest.Merge(m, src)
}
func (m *PushBytesRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushBytesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBytesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushBytesRequest proto.InternalMessageInfo

func (m *PushBytesRequest) GetIds() [][]byte {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *PushBytesRequest) GetSkipMetricsGeneration() bool {
	if m != nil {
		return m.SkipMetricsGeneration
	}
	return false
}

type PushSpansRequest struct {
	// just send entire OTel spans for now
	Batches []*v11.ResourceSpans `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
	// indicates whether metrics generation should be skipped
	// for traces contained in this request.
	SkipMetricsGeneration bool `protobuf:"varint,2,opt,name=skipMetricsGeneration,proto3" json:"skipMetricsGeneration,omitempty"`
}

func (m *PushSpansRequest) Reset()         { *m = PushSpansRequest{} }
func (m *PushSpansRequest) String() string { return proto.CompactTextString(m) }
func (*PushSpansRequest) ProtoMessage()    {}
func (*PushSpansRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{26}
}
func (m *PushSpansRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushSpansRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushSpansRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PushSpansRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushSpansRequest.Merge(m, src)
}
func (m *PushSpansRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushSpansRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushSpansRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushSpansRequest proto.InternalMessageInfo

func (m *PushSpansRequest) GetBatches() []*v11.ResourceSpans {
	if m != nil {
		return m.Batches
	}
	return nil
}

func (m *PushSpansRequest) GetSkipMetricsGeneration() bool {
	if m != nil {
		return m.SkipMetricsGeneration
	}
	return false
}

type TraceBytes struct {
	// pre-marshalled Traces
	Traces [][]byte `protobuf:"bytes,1,rep,name=traces,proto3" json:"traces,omitempty"`
}

func (m *TraceBytes) Reset()         { *m = TraceBytes{} }
func (m *TraceBytes) String() string { return proto.CompactTextString(m) }
func (*TraceBytes) ProtoMessage()    {}
func (*TraceBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{27}
}
func (m *TraceBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceBytes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceBytes.Merge(m, src)
}
func (m *TraceBytes) XXX_Size() int {
	return m.Size()
}
func (m *TraceBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceBytes.DiscardUnknown(m)
}

var xxx_messageInfo_TraceBytes proto.InternalMessageInfo

func (m *TraceBytes) GetTraces() [][]byte {
	if m != nil {
		return m.Traces
	}
	return nil
}

// this message exists for marshalling/unmarshalling convenience to/from
// parquet. in parquet we proto encode links to a column. unfortunately you
// can't encode a slice directly so we use this wrapper to generate the required
// marshalling/unmarshalling functions.
type LinkSlice struct {
	Links []*v11.Span_Link `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
}

func (m *LinkSlice) Reset()         { *m = LinkSlice{} }
func (m *LinkSlice) String() string { return proto.CompactTextString(m) }
func (*LinkSlice) ProtoMessage()    {}
func (*LinkSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{28}
}
func (m *LinkSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkSlice.Merge(m, src)
}
func (m *LinkSlice) XXX_Size() int {
	return m.Size()
}
func (m *LinkSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkSlice.DiscardUnknown(m)
}

var xxx_messageInfo_LinkSlice proto.InternalMessageInfo

func (m *LinkSlice) GetLinks() []*v11.Span_Link {
	if m != nil {
		return m.Links
	}
	return nil
}

type SpanMetricsRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsRequest) Reset()         { *m = SpanMetricsRequest{} }
func (m *SpanMetricsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsRequest) ProtoMessage()    {}
func (*SpanMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{29}
}
func (m *SpanMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsRequest.Merge(m, src)
}
func (m *SpanMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsRequest proto.InternalMessageInfo

func (m *SpanMetricsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsSummaryRequest struct {
	Query   string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	GroupBy string `protobuf:"bytes,2,opt,name=groupBy,proto3" json:"groupBy,omitempty"`
	Limit   uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Start   uint32 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End     uint32 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *SpanMetricsSummaryRequest) Reset()         { *m = SpanMetricsSummaryRequest{} }
func (m *SpanMetricsSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryRequest) ProtoMessage()    {}
func (*SpanMetricsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{30}
}
func (m *SpanMetricsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryRequest.Merge(m, src)
}
func (m *SpanMetricsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryRequest proto.InternalMessageInfo

func (m *SpanMetricsSummaryRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SpanMetricsSummaryRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SpanMetricsSummaryRequest) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SpanMetricsResponse struct {
	Estimated      bool           `protobuf:"varint,1,opt,name=estimated,proto3" json:"estimated,omitempty"`
	SpanCount      uint64         `protobuf:"varint,2,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64         `protobuf:"varint,3,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Metrics        []*SpanMetrics `protobuf:"bytes,4,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *SpanMetricsResponse) Reset()         { *m = SpanMetricsResponse{} }
func (m *SpanMetricsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResponse) ProtoMessage()    {}
func (*SpanMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{31}
}
func (m *SpanMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResponse.Merge(m, src)
}
func (m *SpanMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResponse proto.InternalMessageInfo

func (m *SpanMetricsResponse) GetEstimated() bool {
	if m != nil {
		return m.Estimated
	}
	return false
}

func (m *SpanMetricsResponse) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsResponse) GetMetrics() []*SpanMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type RawHistogram struct {
	Bucket uint64 `protobuf:"varint,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Count  uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RawHistogram) Reset()         { *m = RawHistogram{} }
func (m *RawHistogram) String() string { return proto.CompactTextString(m) }
func (*RawHistogram) ProtoMessage()    {}
func (*RawHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{32}
}
func (m *RawHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawHistogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawHistogram.Merge(m, src)
}
func (m *RawHistogram) XXX_Size() int {
	return m.Size()
}
func (m *RawHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_RawHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_RawHistogram proto.InternalMessageInfo

func (m *RawHistogram) GetBucket() uint64 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *RawHistogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type KeyValue struct {
	Key   string         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value *TraceQLStatic `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{33}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() *TraceQLStatic {
	if m != nil {
		return m.Value
	}
	return nil
}

type SpanMetrics struct {
	LatencyHistogram []*RawHistogram `protobuf:"bytes,1,rep,name=latency_histogram,json=latencyHistogram,proto3" json:"latency_histogram,omitempty"`
	Series           []*KeyValue     `protobuf:"bytes,2,rep,name=series,proto3" json:"series,omitempty"`
	Errors           uint64          `protobuf:"varint,3,opt,name=errors,proto3" json:"errors,omitempty"`
}

func (m *SpanMetrics) Reset()         { *m = SpanMetrics{} }
func (m *SpanMetrics) String() string { return proto.CompactTextString(m) }
func (*SpanMetrics) ProtoMessage()    {}
func (*SpanMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{34}
}
func (m *SpanMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetrics.Merge(m, src)
}
func (m *SpanMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetrics proto.InternalMessageInfo

func (m *SpanMetrics) GetLatencyHistogram() []*RawHistogram {
	if m != nil {
		return m.LatencyHistogram
	}
	return nil
}

func (m *SpanMetrics) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetrics) GetErrors() uint64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type SpanMetricsSummary struct {
	SpanCount      uint64      `protobuf:"varint,1,opt,name=spanCount,proto3" json:"spanCount,omitempty"`
	ErrorSpanCount uint64      `protobuf:"varint,2,opt,name=errorSpanCount,proto3" json:"errorSpanCount,omitempty"`
	Series         []*KeyValue `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
	P99            uint64      `protobuf:"varint,4,opt,name=p99,proto3" json:"p99,omitempty"`
	P95            uint64      `protobuf:"varint,5,opt,name=p95,proto3" json:"p95,omitempty"`
	P90            uint64      `protobuf:"varint,6,opt,name=p90,proto3" json:"p90,omitempty"`
	P50            uint64      `protobuf:"varint,7,opt,name=p50,proto3" json:"p50,omitempty"`
}

func (m *SpanMetricsSummary) Reset()         { *m = SpanMetricsSummary{} }
func (m *SpanMetricsSummary) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummary) ProtoMessage()    {}
func (*SpanMetricsSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{35}
}
func (m *SpanMetricsSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummary.Merge(m, src)
}
func (m *SpanMetricsSummary) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummary.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummary proto.InternalMessageInfo

func (m *SpanMetricsSummary) GetSpanCount() uint64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetErrorSpanCount() uint64 {
	if m != nil {
		return m.ErrorSpanCount
	}
	return 0
}

func (m *SpanMetricsSummary) GetSeries() []*KeyValue {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *SpanMetricsSummary) GetP99() uint64 {
	if m != nil {
		return m.P99
	}
	return 0
}

func (m *SpanMetricsSummary) GetP95() uint64 {
	if m != nil {
		return m.P95
	}
	return 0
}

func (m *SpanMetricsSummary) GetP90() uint64 {
	if m != nil {
		return m.P90
	}
	return 0
}

func (m *SpanMetricsSummary) GetP50() uint64 {
	if m != nil {
		return m.P50
	}
	return 0
}

type SpanMetricsSummaryResponse struct {
	Summaries []*SpanMetricsSummary `protobuf:"bytes,1,rep,name=summaries,proto3" json:"summaries,omitempty"`
}

func (m *SpanMetricsSummaryResponse) Reset()         { *m = SpanMetricsSummaryResponse{} }
func (m *SpanMetricsSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsSummaryResponse) ProtoMessage()    {}
func (*SpanMetricsSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{36}
}
func (m *SpanMetricsSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsSummaryResponse.Merge(m, src)
}
func (m *SpanMetricsSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsSummaryResponse proto.InternalMessageInfo

func (m *SpanMetricsSummaryResponse) GetSummaries() []*SpanMetricsSummary {
	if m != nil {
		return m.Summaries
	}
	return nil
}

type TraceQLStatic struct {
	Type   int32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	N      int64   `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`
	F      float64 `protobuf:"fixed64,3,opt,name=f,proto3" json:"f,omitempty"`
	S      string  `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	B      bool    `protobuf:"varint,5,opt,name=b,proto3" json:"b,omitempty"`
	D      uint64  `protobuf:"varint,6,opt,name=d,proto3" json:"d,omitempty"`
	Status int32   `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	Kind   int32   `protobuf:"varint,8,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *TraceQLStatic) Reset()         { *m = TraceQLStatic{} }
func (m *TraceQLStatic) String() string { return proto.CompactTextString(m) }
func (*TraceQLStatic) ProtoMessage()    {}
func (*TraceQLStatic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{37}
}
func (m *TraceQLStatic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceQLStatic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceQLStatic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceQLStatic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceQLStatic.Merge(m, src)
}
func (m *TraceQLStatic) XXX_Size() int {
	return m.Size()
}
func (m *TraceQLStatic) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceQLStatic.DiscardUnknown(m)
}

var xxx_messageInfo_TraceQLStatic proto.InternalMessageInfo

func (m *TraceQLStatic) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TraceQLStatic) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *TraceQLStatic) GetF() float64 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *TraceQLStatic) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *TraceQLStatic) GetB() bool {
	if m != nil {
		return m.B
	}
	return false
}

func (m *TraceQLStatic) GetD() uint64 {
	if m != nil {
		return m.D
	}
	return 0
}

func (m *TraceQLStatic) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TraceQLStatic) GetKind() int32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

type SpanMetricsData struct {
	ResultType string               `protobuf:"bytes,1,opt,name=resultType,proto3" json:"resultType,omitempty"`
	Result     []*SpanMetricsResult `protobuf:"bytes,2,rep,name=result,proto3" json:"result,omitempty"`
}

func (m *SpanMetricsData) Reset()         { *m = SpanMetricsData{} }
func (m *SpanMetricsData) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsData) ProtoMessage()    {}
func (*SpanMetricsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{38}
}
func (m *SpanMetricsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsData.Merge(m, src)
}
func (m *SpanMetricsData) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsData) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsData.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsData proto.InternalMessageInfo

func (m *SpanMetricsData) GetResultType() string {
	if m != nil {
		return m.ResultType
	}
	return ""
}

func (m *SpanMetricsData) GetResult() []*SpanMetricsResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type SpanMetricsResult struct {
	LabelName  string                    `protobuf:"bytes,1,opt,name=labelName,proto3" json:"labelName,omitempty"`
	LabelValue string                    `protobuf:"bytes,2,opt,name=labelValue,proto3" json:"labelValue,omitempty"`
	Ts         []*SpanMetricsResultPoint `protobuf:"bytes,3,rep,name=ts,proto3" json:"ts,omitempty"`
}

func (m *SpanMetricsResult) Reset()         { *m = SpanMetricsResult{} }
func (m *SpanMetricsResult) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResult) ProtoMessage()    {}
func (*SpanMetricsResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{39}
}
func (m *SpanMetricsResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResult.Merge(m, src)
}
func (m *SpanMetricsResult) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResult.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResult proto.InternalMessageInfo

func (m *SpanMetricsResult) GetLabelName() string {
	if m != nil {
		return m.LabelName
	}
	return ""
}

func (m *SpanMetricsResult) GetLabelValue() string {
	if m != nil {
		return m.LabelValue
	}
	return ""
}

func (m *SpanMetricsResult) GetTs() []*SpanMetricsResultPoint {
	if m != nil {
		return m.Ts
	}
	return nil
}

type SpanMetricsResultPoint struct {
	Time             uint32  `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Val              float64 `protobuf:"fixed64,2,opt,name=val,proto3" json:"val,omitempty"`
	ExemplarTraceID  []byte  `protobuf:"bytes,3,opt,name=exemplarTraceID,proto3" json:"exemplarTraceID,omitempty"`
	ExemplarDuration uint64  `protobuf:"varint,4,opt,name=exemplarDuration,proto3" json:"exemplarDuration,omitempty"`
}

func (m *SpanMetricsResultPoint) Reset()         { *m = SpanMetricsResultPoint{} }
func (m *SpanMetricsResultPoint) String() string { return proto.CompactTextString(m) }
func (*SpanMetricsResultPoint) ProtoMessage()    {}
func (*SpanMetricsResultPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{40}
}
func (m *SpanMetricsResultPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanMetricsResultPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanMetricsResultPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanMetricsResultPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanMetricsResultPoint.Merge(m, src)
}
func (m *SpanMetricsResultPoint) XXX_Size() int {
	return m.Size()
}
func (m *SpanMetricsResultPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanMetricsResultPoint.DiscardUnknown(m)
}

var xxx_messageInfo_SpanMetricsResultPoint proto.InternalMessageInfo

func (m *SpanMetricsResultPoint) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetVal() float64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *SpanMetricsResultPoint) GetExemplarTraceID() []byte {
	if m != nil {
		return m.ExemplarTraceID
	}
	return nil
}

func (m *SpanMetricsResultPoint) GetExemplarDuration() uint64 {
	if m != nil {
		return m.ExemplarDuration
	}
	return 0
}

type QueryInstantRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Start uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QueryInstantRequest) Reset()         { *m = QueryInstantRequest{} }
func (m *QueryInstantRequest) String() string { return proto.CompactTextString(m) }
func (*QueryInstantRequest) ProtoMessage()    {}
func (*QueryInstantRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{41}
}
func (m *QueryInstantRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInstantRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInstantRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInstantRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInstantRequest.Merge(m, src)
}
func (m *QueryInstantRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryInstantRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInstantRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInstantRequest proto.InternalMessageInfo

func (m *QueryInstantRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryInstantRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryInstantRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type QueryInstantResponse struct {
	Series  []*InstantSeries `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	Metrics *SearchMetrics   `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
	Status  PartialStatus    `protobuf:"varint,3,opt,name=status,proto3,enum=tempopb.PartialStatus" json:"status,omitempty"`
	Message string           `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *QueryInstantResponse) Reset()         { *m = QueryInstantResponse{} }
func (m *QueryInstantResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInstantResponse) ProtoMessage()    {}
func (*QueryInstantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{42}
}
func (m *QueryInstantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInstantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInstantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInstantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInstantResponse.Merge(m, src)
}
func (m *QueryInstantResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInstantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInstantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInstantResponse proto.InternalMessageInfo

func (m *QueryInstantResponse) GetSeries() []*InstantSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryInstantResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *QueryInstantResponse) GetStatus() PartialStatus {
	if m != nil {
		return m.Status
	}
	return PartialStatus_COMPLETE
}

func (m *QueryInstantResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type InstantSeries struct {
	// Series labels containing name and value. Data-type aware.
	Labels []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Value  float64       `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	// prom_labels are a flattened string-only version of the typed labels.
	// They are used internally and may differ from official prometheus conventions.
	PromLabels string `protobuf:"bytes,3,opt,name=prom_labels,json=promLabels,proto3" json:"prom_labels,omitempty"`
}

func (m *InstantSeries) Reset()         { *m = InstantSeries{} }
func (m *InstantSeries) String() string { return proto.CompactTextString(m) }
func (*InstantSeries) ProtoMessage()    {}
func (*InstantSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{43}
}
func (m *InstantSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstantSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstantSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstantSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstantSeries.Merge(m, src)
}
func (m *InstantSeries) XXX_Size() int {
	return m.Size()
}
func (m *InstantSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_InstantSeries.DiscardUnknown(m)
}

var xxx_messageInfo_InstantSeries proto.InternalMessageInfo

func (m *InstantSeries) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *InstantSeries) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *InstantSeries) GetPromLabels() string {
	if m != nil {
		return m.PromLabels
	}
	return ""
}

type QueryRangeRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Start uint64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Step  uint64 `protobuf:"varint,4,opt,name=step,proto3" json:"step,omitempty"`
	//uint32 shardID = 5; // removed
	//uint32 shardCount = 6; // removed
	QueryMode string `protobuf:"bytes,7,opt,name=queryMode,proto3" json:"queryMode,omitempty"`
	// New RF1 fields
	BlockID          string             `protobuf:"bytes,8,opt,name=blockID,proto3" json:"blockID,omitempty"`
	StartPage        uint32             `protobuf:"varint,9,opt,name=startPage,proto3" json:"startPage,omitempty"`
	PagesToSearch    uint32             `protobuf:"varint,10,opt,name=pagesToSearch,proto3" json:"pagesToSearch,omitempty"`
	Version          string             `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	Encoding         string             `protobuf:"bytes,12,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Size_            uint64             `protobuf:"varint,13,opt,name=size,proto3" json:"size,omitempty"`
	FooterSize       uint32             `protobuf:"varint,14,opt,name=footerSize,proto3" json:"footerSize,omitempty"`
	DedicatedColumns []*DedicatedColumn `protobuf:"bytes,15,rep,name=dedicatedColumns,proto3" json:"dedicatedColumns,omitempty"`
	// Exemplars are optional and can be empty.
	Exemplars uint32 `protobuf:"varint,16,opt,name=exemplars,proto3" json:"exemplars,omitempty"`
	MaxSeries uint32 `protobuf:"varint,17,opt,name=maxSeries,proto3" json:"maxSeries,omitempty"`
}

func (m *QueryRangeRequest) Reset()         { *m = QueryRangeRequest{} }
func (m *QueryRangeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRangeRequest) ProtoMessage()    {}
func (*QueryRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{44}
}
func (m *QueryRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeRequest.Merge(m, src)
}
func (m *QueryRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeRequest proto.InternalMessageInfo

func (m *QueryRangeRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryRangeRequest) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryRangeRequest) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *QueryRangeRequest) GetStep() uint64 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *QueryRangeRequest) GetQueryMode() string {
	if m != nil {
		return m.QueryMode
	}
	return ""
}

func (m *QueryRangeRequest) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *QueryRangeRequest) GetStartPage() uint32 {
	if m != nil {
		return m.StartPage
	}
	return 0
}

func (m *QueryRangeRequest) GetPagesToSearch() uint32 {
	if m != nil {
		return m.PagesToSearch
	}
	return 0
}

func (m *QueryRangeRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *QueryRangeRequest) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *QueryRangeRequest) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *QueryRangeRequest) GetFooterSize() uint32 {
	if m != nil {
		return m.FooterSize
	}
	return 0
}

func (m *QueryRangeRequest) GetDedicatedColumns() []*DedicatedColumn {
	if m != nil {
		return m.DedicatedColumns
	}
	return nil
}

func (m *QueryRangeRequest) GetExemplars() uint32 {
	if m != nil {
		return m.Exemplars
	}
	return 0
}

func (m *QueryRangeRequest) GetMaxSeries() uint32 {
	if m != nil {
		return m.MaxSeries
	}
	return 0
}

type QueryRangeResponse struct {
	Series  []*TimeSeries  `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	Metrics *SearchMetrics `protobuf:"bytes,2,opt,name=metrics,proto3" json:"metrics,omitempty"`
	Status  PartialStatus  `protobuf:"varint,3,opt,name=status,proto3,enum=tempopb.PartialStatus" json:"status,omitempty"`
	Message string         `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *QueryRangeResponse) Reset()         { *m = QueryRangeResponse{} }
func (m *QueryRangeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRangeResponse) ProtoMessage()    {}
func (*QueryRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{45}
}
func (m *QueryRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeResponse.Merge(m, src)
}
func (m *QueryRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeResponse proto.InternalMessageInfo

func (m *QueryRangeResponse) GetSeries() []*TimeSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryRangeResponse) GetMetrics() *SearchMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *QueryRangeResponse) GetStatus() PartialStatus {
	if m != nil {
		return m.Status
	}
	return PartialStatus_COMPLETE
}

func (m *QueryRangeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Exemplar struct {
	// Optional, can be empty.
	Labels      []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Value       float64       `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMs int64         `protobuf:"varint,3,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
}

func (m *Exemplar) Reset()         { *m = Exemplar{} }
func (m *Exemplar) String() string { return proto.CompactTextString(m) }
func (*Exemplar) ProtoMessage()    {}
func (*Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{46}
}
func (m *Exemplar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exemplar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exemplar.Merge(m, src)
}
func (m *Exemplar) XXX_Size() int {
	return m.Size()
}
func (m *Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Exemplar proto.InternalMessageInfo

func (m *Exemplar) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Exemplar) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

type Sample struct {
	// Fields order MUST match promql.FPoint so that we can cast types between them.
	TimestampMs int64   `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	Value       float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Sample) Reset()         { *m = Sample{} }
func (m *Sample) String() string { return proto.CompactTextString(m) }
func (*Sample) ProtoMessage()    {}
func (*Sample) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{47}
}
func (m *Sample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sample.Merge(m, src)
}
func (m *Sample) XXX_Size() int {
	return m.Size()
}
func (m *Sample) XXX_DiscardUnknown() {
	xxx_messageInfo_Sample.DiscardUnknown(m)
}

var xxx_messageInfo_Sample proto.InternalMessageInfo

func (m *Sample) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *Sample) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TimeSeries struct {
	// Series labels containing name and value. Data-type aware.
	Labels []v1.KeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	// Sorted by time, oldest sample first.
	Samples []Sample `protobuf:"bytes,2,rep,name=samples,proto3" json:"samples"`
	// prom_labels are a flattened string-only version of the typed labels.
	// They are used internally and may differ from official prometheus conventions.
	PromLabels string `protobuf:"bytes,3,opt,name=prom_labels,json=promLabels,proto3" json:"prom_labels,omitempty"`
	// Exemplars are optional and can be empty.
	// Sorted by time, oldest exemplar first.
	Exemplars []Exemplar `protobuf:"bytes,4,rep,name=exemplars,proto3" json:"exemplars"`
}

func (m *TimeSeries) Reset()         { *m = TimeSeries{} }
func (m *TimeSeries) String() string { return proto.CompactTextString(m) }
func (*TimeSeries) ProtoMessage()    {}
func (*TimeSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_f22805646f4f62b6, []int{48}
}
func (m *TimeSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeries.Merge(m, src)
}
func (m *TimeSeries) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeries.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeries proto.InternalMessageInfo

func (m *TimeSeries) GetLabels() []v1.KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TimeSeries) GetSamples() []Sample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *TimeSeries) GetPromLabels() string {
	if m != nil {
		return m.PromLabels
	}
	return ""
}

func (m *TimeSeries) GetExemplars() []Exemplar {
	if m != nil {
		return m.Exemplars
	}
	return nil
}

func init() {
	proto.RegisterEnum("tempopb.PushErrorReason", PushErrorReason_name, PushErrorReason_value)
	proto.RegisterEnum("tempopb.PartialStatus", PartialStatus_name, PartialStatus_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Scope", DedicatedColumn_Scope_name, DedicatedColumn_Scope_value)
	proto.RegisterEnum("tempopb.DedicatedColumn_Type", DedicatedColumn_Type_name, DedicatedColumn_Type_value)
	proto.RegisterType((*TraceByIDRequest)(nil), "tempopb.TraceByIDRequest")
	proto.RegisterType((*TraceByIDResponse)(nil), "tempopb.TraceByIDResponse")
	proto.RegisterType((*TraceByIDMetrics)(nil), "tempopb.TraceByIDMetrics")
	proto.RegisterType((*SearchRequest)(nil), "tempopb.SearchRequest")
	proto.RegisterMapType((map[string]string)(nil), "tempopb.SearchRequest.TagsEntry")
	proto.RegisterType((*SearchBlockRequest)(nil), "tempopb.SearchBlockRequest")
	proto.RegisterType((*DedicatedColumn)(nil), "tempopb.DedicatedColumn")
	proto.RegisterType((*SearchResponse)(nil), "tempopb.SearchResponse")
	proto.RegisterType((*TraceSearchMetadata)(nil), "tempopb.TraceSearchMetadata")
	proto.RegisterMapType((map[string]*ServiceStats)(nil), "tempopb.TraceSearchMetadata.ServiceStatsEntry")
	proto.RegisterType((*ServiceStats)(nil), "tempopb.ServiceStats")
	proto.RegisterType((*SpanSet)(nil), "tempopb.SpanSet")
	proto.RegisterType((*Span)(nil), "tempopb.Span")
	proto.RegisterType((*SearchMetrics)(nil), "tempopb.SearchMetrics")
	proto.RegisterType((*SearchTagsRequest)(nil), "tempopb.SearchTagsRequest")
	proto.RegisterType((*SearchTagsBlockRequest)(nil), "tempopb.SearchTagsBlockRequest")
	proto.RegisterType((*SearchTagValuesBlockRequest)(nil), "tempopb.SearchTagValuesBlockRequest")
	proto.RegisterType((*SearchTagsResponse)(nil), "tempopb.SearchTagsResponse")
	proto.RegisterType((*SearchTagsV2Response)(nil), "tempopb.SearchTagsV2Response")
	proto.RegisterType((*SearchTagsV2Scope)(nil), "tempopb.SearchTagsV2Scope")
	proto.RegisterType((*SearchTagValuesRequest)(nil), "tempopb.SearchTagValuesRequest")
	proto.RegisterType((*SearchTagValuesResponse)(nil), "tempopb.SearchTagValuesResponse")
	proto.RegisterType((*TagValue)(nil), "tempopb.TagValue")
	proto.RegisterType((*SearchTagValuesV2Response)(nil), "tempopb.SearchTagValuesV2Response")
	proto.RegisterType((*MetadataMetrics)(nil), "tempopb.MetadataMetrics")
	proto.RegisterType((*Trace)(nil), "tempopb.Trace")
	proto.RegisterType((*PushResponse)(nil), "tempopb.PushResponse")
	proto.RegisterType((*PushBytesRequest)(nil), "tempopb.PushBytesRequest")
	proto.RegisterType((*PushSpansRequest)(nil), "tempopb.PushSpansRequest")
	proto.RegisterType((*TraceBytes)(nil), "tempopb.TraceBytes")
	proto.RegisterType((*LinkSlice)(nil), "tempopb.LinkSlice")
	proto.RegisterType((*SpanMetricsRequest)(nil), "tempopb.SpanMetricsRequest")
	proto.RegisterType((*SpanMetricsSummaryRequest)(nil), "tempopb.SpanMetricsSummaryRequest")
	proto.RegisterType((*SpanMetricsResponse)(nil), "tempopb.SpanMetricsResponse")
	proto.RegisterType((*RawHistogram)(nil), "tempopb.RawHistogram")
	proto.RegisterType((*KeyValue)(nil), "tempopb.KeyValue")
	proto.RegisterType((*SpanMetrics)(nil), "tempopb.SpanMetrics")
	proto.RegisterType((*SpanMetricsSummary)(nil), "tempopb.SpanMetricsSummary")
	proto.RegisterType((*SpanMetricsSummaryResponse)(nil), "tempopb.SpanMetricsSummaryResponse")
	proto.RegisterType((*TraceQLStatic)(nil), "tempopb.TraceQLStatic")
	proto.RegisterType((*SpanMetricsData)(nil), "tempopb.SpanMetricsData")
	proto.RegisterType((*SpanMetricsResult)(nil), "tempopb.SpanMetricsResult")
	proto.RegisterType((*SpanMetricsResultPoint)(nil), "tempopb.SpanMetricsResultPoint")
	proto.RegisterType((*QueryInstantRequest)(nil), "tempopb.QueryInstantRequest")
	proto.RegisterType((*QueryInstantResponse)(nil), "tempopb.QueryInstantResponse")
	proto.RegisterType((*InstantSeries)(nil), "tempopb.InstantSeries")
	proto.RegisterType((*QueryRangeRequest)(nil), "tempopb.QueryRangeRequest")
	proto.RegisterType((*QueryRangeResponse)(nil), "tempopb.QueryRangeResponse")
	proto.RegisterType((*Exemplar)(nil), "tempopb.Exemplar")
	proto.RegisterType((*Sample)(nil), "tempopb.Sample")
	proto.RegisterType((*TimeSeries)(nil), "tempopb.TimeSeries")
}

func init() { proto.RegisterFile("pkg/tempopb/tempo.proto", fileDescriptor_f22805646f4f62b6) }

var fileDescriptor_f22805646f4f62b6 = []byte{
	// 3047 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3a, 0x4b, 0x6f, 0x23, 0xc7,
	0xd1, 0x1a, 0xbe, 0x55, 0x24, 0x25, 0xaa, 0xa5, 0x95, 0xb9, 0xdc, 0xb5, 0xa4, 0x6f, 0xbc, 0x30,
	0xf4, 0xad, 0x6d, 0x4a, 0x4b, 0xaf, 0xf1, 0x79, 0xed, 0x2f, 0x4e, 0xa4, 0x15, 0xbd, 0x96, 0xad,
	0x97, 0x9b, 0xb4, 0x6c, 0x04, 0x06, 0x84, 0x11, 0xd9, 0xcb, 0x1d, 0x88, 0x9c, 0xa1, 0x67, 0x86,
	0xb2, 0x94, 0x83, 0x91, 0x07, 0x82, 0x24, 0x40, 0x0e, 0x3e, 0x24, 0x87, 0xfc, 0x82, 0x20, 0xb9,
	0xe6, 0x92, 0x4b, 0x2e, 0x09, 0x10, 0x38, 0x08, 0x0c, 0x18, 0xc8, 0xc5, 0xc8, 0xc1, 0x09, 0xec,
	0x43, 0xfe, 0x41, 0xce, 0x41, 0x57, 0x77, 0xcf, 0x8b, 0x23, 0x69, 0x77, 0x2d, 0x23, 0x3e, 0xf8,
	0xc4, 0xee, 0xea, 0xea, 0xea, 0xea, 0x7a, 0x57, 0x0f, 0xe1, 0x89, 0xe1, 0x51, 0x6f, 0xc5, 0x63,
	0x83, 0xa1, 0x3d, 0x3c, 0x14, 0xbf, 0xf5, 0xa1, 0x63, 0x7b, 0x36, 0xc9, 0x4b, 0x60, 0x6d, 0xbe,
	0x63, 0x0f, 0x06, 0xb6, 0xb5, 0x72, 0x7c, 0x6b, 0x45, 0x8c, 0x04, 0x42, 0xed, 0xb9, 0x9e, 0xe9,
	0x3d, 0x18, 0x1d, 0xd6, 0x3b, 0xf6, 0x60, 0xa5, 0x67, 0xf7, 0xec, 0x15, 0x04, 0x1f, 0x8e, 0xee,
	0xe3, 0x0c, 0x27, 0x38, 0x92, 0xe8, 0x73, 0x9e, 0x63, 0x74, 0x18, 0xa7, 0x82, 0x03, 0x09, 0x5d,
	0xec, 0xd9, 0x76, 0xaf, 0xcf, 0x82, 0xbd, 0x9e, 0x39, 0x60, 0xae, 0x67, 0x0c, 0x86, 0x02, 0x41,
	0xff, 0xb7, 0x06, 0x95, 0x36, 0xdf, 0xb0, 0x7e, 0xba, 0xb9, 0x41, 0xd9, 0x7b, 0x23, 0xe6, 0x7a,
	0xa4, 0x0a, 0x79, 0x24, 0xb2, 0xb9, 0x51, 0xd5, 0x96, 0xb4, 0xe5, 0x12, 0x55, 0x53, 0xb2, 0x00,
	0x70, 0xd8, 0xb7, 0x3b, 0x47, 0x2d, 0xcf, 0x70, 0xbc, 0x6a, 0x6a, 0x49, 0x5b, 0x9e, 0xa4, 0x21,
	0x08, 0xa9, 0x41, 0x01, 0x67, 0x4d, 0xab, 0x5b, 0x4d, 0xe3, 0xaa, 0x3f, 0x27, 0xd7, 0x61, 0xf2,
	0xbd, 0x11, 0x73, 0x4e, 0xb7, 0xed, 0x2e, 0xab, 0x66, 0x71, 0x31, 0x00, 0x90, 0x67, 0x61, 0xc6,
	0xe8, 0xf7, 0xed, 0xf7, 0xf7, 0x0c, 0xc7, 0x33, 0x8d, 0x3e, 0xf2, 0x54, 0xcd, 0x2d, 0x69, 0xcb,
	0x05, 0x3a, 0xbe, 0x40, 0xbe, 0x03, 0x05, 0xfa, 0xea, 0xad, 0xb5, 0xfb, 0x1e, 0x73, 0xaa, 0xf9,
	0x25, 0x6d, 0xb9, 0xd8, 0xa8, 0xd5, 0xc5, 0x55, 0xeb, 0xea, 0xaa, 0xf5, 0xb6, 0xba, 0xea, 0x7a,
	0xe1, 0xa3, 0xcf, 0x16, 0x27, 0x3e, 0xfc, 0xc7, 0xa2, 0x46, 0xfd, 0x5d, 0xfa, 0xef, 0x35, 0x98,
	0x09, 0x5d, 0xdc, 0x1d, 0xda, 0x96, 0xcb, 0xc8, 0x0d, 0xc8, 0xe2, 0x55, 0xf1, 0xde, 0xc5, 0xc6,
	0x54, 0x5d, 0x6a, 0xa9, 0x8e, 0xa8, 0x54, 0x2c, 0x92, 0xe7, 0x21, 0x3f, 0x60, 0x9e, 0x63, 0x76,
	0x5c, 0x14, 0x41, 0xb1, 0x71, 0x35, 0x8a, 0xc7, 0x49, 0x6e, 0x0b, 0x04, 0xaa, 0x30, 0x49, 0x1d,
	0x72, 0xae, 0x67, 0x78, 0x23, 0x17, 0x05, 0x33, 0xd5, 0x98, 0xf7, 0xf7, 0xc8, 0x9b, 0xb5, 0x70,
	0x95, 0x4a, 0x2c, 0xae, 0x84, 0x01, 0x73, 0x5d, 0xa3, 0xc7, 0xaa, 0x19, 0x14, 0x96, 0x9a, 0xea,
	0x2f, 0x85, 0x54, 0x26, 0x8f, 0x21, 0x4f, 0xc3, 0x94, 0x69, 0xb9, 0x43, 0xd6, 0xf1, 0x58, 0x77,
	0xfd, 0xd4, 0x63, 0x2e, 0xde, 0x20, 0x43, 0x63, 0x50, 0xfd, 0xc3, 0x34, 0x94, 0x5b, 0xcc, 0x70,
	0x3a, 0x0f, 0x94, 0xb2, 0x5f, 0x82, 0x4c, 0xdb, 0xe8, 0x71, 0xfc, 0xf4, 0x72, 0xb1, 0xb1, 0xe4,
	0x73, 0x15, 0xc1, 0xaa, 0x73, 0x94, 0xa6, 0xe5, 0x39, 0xa7, 0xeb, 0x19, 0x2e, 0x4c, 0x8a, 0x7b,
	0xc8, 0x0d, 0x28, 0x6f, 0x9b, 0xd6, 0xc6, 0xc8, 0x31, 0x3c, 0xd3, 0xb6, 0xb6, 0x85, 0x38, 0xca,
	0x34, 0x0a, 0x44, 0x2c, 0xe3, 0x24, 0x84, 0x95, 0x96, 0x58, 0x61, 0x20, 0x99, 0x83, 0xec, 0x96,
	0x39, 0x30, 0x3d, 0xbc, 0x6d, 0x99, 0x8a, 0x09, 0x87, 0xba, 0x68, 0x6b, 0x59, 0x01, 0xc5, 0x09,
	0xa9, 0x40, 0x9a, 0x59, 0x5d, 0x34, 0x8f, 0x32, 0xe5, 0x43, 0x8e, 0xf7, 0x26, 0xb7, 0xa5, 0x6a,
	0x01, 0x65, 0x25, 0x26, 0x64, 0x19, 0xa6, 0x5b, 0x43, 0xc3, 0x72, 0xf7, 0x98, 0xc3, 0x7f, 0x5b,
	0xcc, 0xab, 0x4e, 0xe2, 0x9e, 0x38, 0x38, 0x62, 0x50, 0xf0, 0x38, 0x06, 0x55, 0xfb, 0x3f, 0x98,
	0xf4, 0x85, 0xc4, 0x19, 0x3c, 0x62, 0xa7, 0xa8, 0x83, 0x49, 0xca, 0x87, 0x9c, 0xc1, 0x63, 0xa3,
	0x3f, 0x62, 0xd2, 0x69, 0xc4, 0xe4, 0xa5, 0xd4, 0x8b, 0x9a, 0xfe, 0xe7, 0x34, 0x10, 0x21, 0xec,
	0x75, 0xee, 0x2a, 0x4a, 0x2f, 0xb7, 0x61, 0xd2, 0x55, 0x2a, 0x90, 0xe6, 0x38, 0x9f, 0xac, 0x1c,
	0x1a, 0x20, 0x72, 0xab, 0x41, 0x87, 0xdb, 0xdc, 0x90, 0x07, 0xa9, 0x29, 0x77, 0x3f, 0x14, 0xde,
	0x1e, 0xb7, 0x28, 0xa1, 0x81, 0x00, 0xc0, 0x75, 0x34, 0x34, 0x7a, 0xcc, 0x6d, 0xdb, 0x82, 0xb4,
	0xd4, 0x42, 0x14, 0xc8, 0xdd, 0x9b, 0x59, 0x1d, 0xbb, 0x6b, 0x5a, 0x3d, 0xe9, 0xc1, 0xfe, 0x9c,
	0x53, 0x30, 0xad, 0x2e, 0x3b, 0xe1, 0xe4, 0x5a, 0xe6, 0xf7, 0x98, 0xd4, 0x4e, 0x14, 0x48, 0x74,
	0x28, 0x79, 0xb6, 0x67, 0xf4, 0x29, 0xeb, 0xd8, 0x4e, 0xd7, 0x45, 0xe7, 0x2d, 0xd3, 0x08, 0x8c,
	0xe3, 0x74, 0x0d, 0xcf, 0x68, 0xaa, 0x93, 0x84, 0x4a, 0x23, 0x30, 0x7e, 0xcf, 0x63, 0xe6, 0xb8,
	0xa6, 0x6d, 0xa1, 0x46, 0x27, 0xa9, 0x9a, 0x12, 0x02, 0x19, 0x97, 0x1f, 0x0f, 0x68, 0xff, 0x38,
	0xe6, 0x61, 0xeb, 0xbe, 0x6d, 0x7b, 0xcc, 0x41, 0xc6, 0x8a, 0x78, 0x66, 0x08, 0x42, 0x36, 0xa0,
	0xd2, 0x65, 0x5d, 0xb3, 0x63, 0x78, 0xac, 0x7b, 0xd7, 0xee, 0x8f, 0x06, 0x96, 0x5b, 0x2d, 0xa1,
	0x3f, 0x54, 0x7d, 0x91, 0x6f, 0x44, 0x11, 0xe8, 0xd8, 0x0e, 0xfd, 0x4f, 0x1a, 0x4c, 0xc7, 0xb0,
	0xc8, 0x6d, 0xc8, 0xba, 0x1d, 0x7b, 0xc8, 0xa4, 0xd3, 0x2f, 0x9c, 0x45, 0xae, 0xde, 0xe2, 0x58,
	0x54, 0x20, 0xf3, 0x3b, 0x58, 0xc6, 0x40, 0xd9, 0x0a, 0x8e, 0xc9, 0x2d, 0xc8, 0x78, 0xa7, 0x43,
	0x11, 0x99, 0xa6, 0x1a, 0x4f, 0x9e, 0x49, 0xa8, 0x7d, 0x3a, 0x64, 0x14, 0x51, 0xf5, 0x45, 0xc8,
	0x22, 0x59, 0x52, 0x80, 0x4c, 0x6b, 0x6f, 0x6d, 0xa7, 0x32, 0x41, 0x4a, 0x50, 0xa0, 0xcd, 0xd6,
	0xee, 0x5b, 0xf4, 0x6e, 0xb3, 0xa2, 0xe9, 0x04, 0x32, 0x1c, 0x9d, 0x00, 0xe4, 0x5a, 0x6d, 0xba,
	0xb9, 0x73, 0xaf, 0x32, 0xa1, 0x9f, 0xc0, 0x94, 0xb2, 0x2e, 0x19, 0x14, 0x6f, 0x43, 0x0e, 0xe3,
	0x9e, 0x8a, 0x11, 0xd7, 0xa3, 0xd1, 0x4e, 0x60, 0x6f, 0x33, 0xcf, 0xe0, 0x1a, 0xa2, 0x12, 0x97,
	0xac, 0xc6, 0x83, 0x64, 0xdc, 0x7a, 0xe3, 0x11, 0x52, 0xff, 0x5b, 0x1a, 0x66, 0x13, 0x28, 0xc6,
	0xd3, 0xd1, 0x64, 0x90, 0x8e, 0x96, 0x61, 0xda, 0xb1, 0x6d, 0xaf, 0xc5, 0x9c, 0x63, 0xb3, 0xc3,
	0x76, 0x02, 0x91, 0xc5, 0xc1, 0xdc, 0x3a, 0x39, 0x08, 0xc9, 0x23, 0x9e, 0xc8, 0x4e, 0x51, 0x20,
	0x4f, 0x42, 0xe8, 0x12, 0xdc, 0xd3, 0xdf, 0xb2, 0xcc, 0x93, 0x1d, 0xc3, 0xb2, 0xd1, 0x13, 0x32,
	0x74, 0x7c, 0x81, 0x5b, 0x55, 0x37, 0x08, 0x6a, 0x22, 0x40, 0x85, 0x20, 0xe4, 0x26, 0xe4, 0x5d,
	0x19, 0x75, 0x72, 0x28, 0x81, 0x4a, 0x20, 0x01, 0x01, 0xa7, 0x0a, 0x81, 0x3c, 0x0b, 0x05, 0x39,
	0xe4, 0x3e, 0x91, 0x4e, 0x44, 0xf6, 0x31, 0x08, 0x85, 0x92, 0x2b, 0x2e, 0xc7, 0x93, 0x86, 0x5b,
	0x2d, 0xe0, 0x8e, 0xfa, 0x79, 0x7a, 0xa9, 0xb7, 0x42, 0x1b, 0x30, 0x48, 0xd1, 0x08, 0x8d, 0xda,
	0x3e, 0xcc, 0x8c, 0xa1, 0x24, 0xc4, 0xb1, 0x67, 0xc2, 0x71, 0xac, 0xd8, 0xb8, 0x12, 0x52, 0x6a,
	0xb0, 0x39, 0x1c, 0xde, 0xb6, 0xa0, 0x14, 0x5e, 0xc2, 0x38, 0x34, 0x34, 0xac, 0xbb, 0xf6, 0xc8,
	0xf2, 0x90, 0x30, 0x8f, 0x43, 0x0a, 0xc0, 0x65, 0xca, 0x1c, 0xc7, 0x76, 0xc4, 0xb2, 0x48, 0x27,
	0x21, 0x88, 0xfe, 0x63, 0x0d, 0xf2, 0x2a, 0x66, 0x3f, 0x05, 0x59, 0xbe, 0x51, 0x99, 0x65, 0x39,
	0x22, 0x30, 0x2a, 0xd6, 0x30, 0x8d, 0x1a, 0x5e, 0xe7, 0x01, 0xeb, 0x4a, 0x6a, 0x6a, 0x4a, 0x5e,
	0x06, 0x30, 0x3c, 0xcf, 0x31, 0x0f, 0x47, 0x3c, 0x5d, 0xa6, 0x91, 0xc6, 0x35, 0x9f, 0x86, 0xac,
	0xc5, 0x8e, 0x6f, 0xd5, 0xdf, 0x60, 0xa7, 0xfb, 0xfc, 0x36, 0x34, 0x84, 0xce, 0x7d, 0x3d, 0xc3,
	0x8f, 0x21, 0xf3, 0x90, 0xe3, 0x07, 0xf9, 0xb6, 0x29, 0x67, 0x89, 0x2e, 0x9c, 0x68, 0x5e, 0xe9,
	0xb3, 0xcc, 0xeb, 0x06, 0x94, 0x95, 0x31, 0xf1, 0xb9, 0x2b, 0x0d, 0x31, 0x0a, 0x8c, 0xdd, 0x22,
	0xfb, 0x68, 0xb7, 0xf8, 0x55, 0x4a, 0x55, 0x03, 0xaa, 0x8e, 0x58, 0x86, 0x69, 0xbf, 0x62, 0x68,
	0x2b, 0xa7, 0xc7, 0x8c, 0x19, 0x03, 0x27, 0x54, 0x1c, 0xa9, 0xa4, 0x8a, 0x83, 0x2c, 0x41, 0x11,
	0xa3, 0x3b, 0x26, 0x37, 0x95, 0xfb, 0xc3, 0x20, 0x7e, 0xd1, 0x8e, 0x3d, 0x18, 0xf6, 0x99, 0xc7,
	0xba, 0xaf, 0xdb, 0x87, 0xae, 0xca, 0x3d, 0x11, 0x20, 0xb7, 0x1b, 0xdc, 0x84, 0x18, 0xc2, 0xd9,
	0x02, 0x00, 0xe7, 0x3b, 0x20, 0x29, 0xd8, 0xc9, 0x21, 0x3b, 0x71, 0x70, 0x84, 0x6f, 0xac, 0x02,
	0x30, 0x07, 0x85, 0xf9, 0x46, 0xa8, 0xfe, 0x93, 0x14, 0x77, 0x08, 0x2e, 0x1b, 0x9e, 0xd6, 0x55,
	0x56, 0x9e, 0x53, 0xf1, 0x5c, 0x68, 0x5b, 0xc6, 0xeb, 0x39, 0xc8, 0x62, 0x25, 0xab, 0x92, 0x3b,
	0x4e, 0x82, 0xda, 0x25, 0x9d, 0x50, 0xbb, 0x64, 0x82, 0xda, 0x65, 0x19, 0xa6, 0x07, 0xc6, 0x09,
	0x3f, 0x85, 0x17, 0x24, 0x48, 0x5d, 0xdc, 0x2f, 0x0e, 0x26, 0x0d, 0x98, 0x73, 0x3d, 0xa3, 0xcf,
	0x50, 0x93, 0x6e, 0xfb, 0x81, 0xc3, 0xdc, 0x07, 0x76, 0x5f, 0x15, 0x42, 0x89, 0x6b, 0x97, 0x50,
	0x2a, 0xff, 0x36, 0x03, 0xf3, 0x81, 0x24, 0x22, 0x45, 0xca, 0x8b, 0xe3, 0x45, 0x4a, 0x2d, 0x16,
	0xe6, 0x43, 0xd2, 0xfb, 0xa6, 0x50, 0xf9, 0x5a, 0x14, 0x2a, 0x49, 0x06, 0x57, 0x4e, 0x36, 0xb8,
	0x55, 0x98, 0x0d, 0x8c, 0x2a, 0xb0, 0xb7, 0x29, 0xc4, 0x4e, 0x5a, 0xd2, 0x3f, 0x4d, 0xc3, 0x35,
	0x5f, 0xf1, 0xc2, 0x16, 0x23, 0x16, 0xf3, 0xad, 0x71, 0x8b, 0x59, 0x1c, 0xb7, 0x18, 0xb1, 0xf1,
	0x1b, 0xb3, 0xf9, 0x5a, 0xd5, 0xb7, 0x5d, 0xd5, 0xa7, 0x08, 0x97, 0x96, 0xd5, 0x61, 0x0d, 0x0a,
	0x9e, 0xd1, 0xe3, 0xe5, 0x93, 0x48, 0xc4, 0x93, 0xd4, 0x9f, 0x93, 0x46, 0xbc, 0x06, 0x0c, 0x8e,
	0x53, 0x75, 0xc9, 0x58, 0x15, 0xf8, 0x01, 0xcc, 0x05, 0xa7, 0xec, 0x37, 0xfc, 0x73, 0x1a, 0x90,
	0xc3, 0x60, 0xab, 0xd2, 0x7d, 0x52, 0x9c, 0xd9, 0x6f, 0x88, 0x32, 0x5a, 0x62, 0x3e, 0xd6, 0xf9,
	0x2f, 0x87, 0xc3, 0xbe, 0x24, 0xe8, 0x67, 0x73, 0x2d, 0x94, 0xcd, 0x09, 0x64, 0x3c, 0xde, 0x38,
	0xa7, 0xf0, 0xd2, 0x38, 0xd6, 0x7f, 0x9a, 0x0a, 0x85, 0xca, 0x88, 0x11, 0x63, 0x15, 0x2b, 0xe4,
	0xe2, 0x57, 0xb1, 0x62, 0x7a, 0x51, 0xf6, 0xc8, 0x24, 0x64, 0x8f, 0x6c, 0x90, 0x3d, 0x74, 0x28,
	0x09, 0xaf, 0x15, 0xc7, 0x49, 0xb3, 0x8c, 0xc0, 0xce, 0x72, 0xe3, 0xfc, 0x99, 0x6e, 0x1c, 0xc9,
	0x1a, 0x85, 0xc7, 0xca, 0x1a, 0x47, 0xf0, 0xc4, 0x98, 0x24, 0xa4, 0x2a, 0x79, 0x2a, 0xf7, 0xf9,
	0x15, 0x36, 0x13, 0x00, 0x1e, 0x4b, 0x69, 0xb7, 0xa1, 0xa0, 0x8e, 0x41, 0xbd, 0x9c, 0xfa, 0x19,
	0x1a, 0xc7, 0xc9, 0xdd, 0xb7, 0xfe, 0x7d, 0x0d, 0xae, 0xc6, 0x78, 0x0c, 0x19, 0xdc, 0x4a, 0x9c,
	0xcb, 0x62, 0x63, 0x26, 0xa8, 0xb0, 0xe5, 0xca, 0x97, 0x65, 0xfc, 0x2f, 0x1a, 0x4c, 0xc7, 0x16,
	0x1f, 0xf6, 0x2d, 0x27, 0x5a, 0x11, 0xa5, 0xe2, 0x15, 0xd1, 0x58, 0x55, 0x95, 0x4e, 0xaa, 0xaa,
	0x62, 0xd5, 0x59, 0x66, 0xbc, 0x3a, 0x4b, 0xa8, 0xac, 0xb2, 0x89, 0x95, 0x95, 0xbe, 0x03, 0x59,
	0xf1, 0x3a, 0xd7, 0x84, 0xb2, 0xc3, 0x5c, 0x7b, 0xe4, 0x74, 0x58, 0x2b, 0x54, 0xa0, 0x07, 0x71,
	0x5e, 0x3c, 0x51, 0x1e, 0xdf, 0xaa, 0xd3, 0x30, 0x1a, 0x8d, 0xee, 0xd2, 0x77, 0xa0, 0xb4, 0x37,
	0x72, 0x83, 0x3e, 0xf4, 0x15, 0x28, 0x63, 0x27, 0xe0, 0xae, 0x9f, 0xb6, 0xe5, 0x23, 0x5d, 0x7a,
	0x79, 0x2a, 0x24, 0x65, 0x8e, 0xdd, 0xe4, 0x18, 0x94, 0x19, 0xae, 0x6d, 0xd1, 0x28, 0xba, 0xfe,
	0x33, 0x0d, 0x2a, 0x1c, 0x05, 0xb9, 0x55, 0x6e, 0xf9, 0x9c, 0xdf, 0xdc, 0x72, 0x3f, 0x2e, 0xad,
	0x5f, 0xe1, 0xa6, 0xfc, 0xf7, 0xcf, 0x16, 0xcb, 0x7b, 0x0e, 0x33, 0xfa, 0x7d, 0xbb, 0x23, 0xb0,
	0x55, 0x57, 0x5b, 0x81, 0xb4, 0xd9, 0x15, 0xdd, 0x42, 0x89, 0xf2, 0x21, 0xb9, 0x0d, 0x57, 0xdc,
	0x23, 0x73, 0x28, 0x95, 0x77, 0x8f, 0x59, 0x4c, 0x94, 0xe7, 0x28, 0xa5, 0x02, 0x4d, 0x5e, 0xd4,
	0x7f, 0x24, 0x79, 0x11, 0x17, 0x97, 0xbc, 0xdc, 0x81, 0xfc, 0x21, 0x36, 0x27, 0x0f, 0x2d, 0x31,
	0x85, 0x7f, 0x36, 0x17, 0xa9, 0xf3, 0xb8, 0xb8, 0x01, 0x20, 0x5f, 0x12, 0xb9, 0x3d, 0xcd, 0x47,
	0xfa, 0xfc, 0x92, 0xba, 0xb3, 0xfe, 0x0a, 0x4c, 0x6e, 0x99, 0xd6, 0x51, 0xab, 0x6f, 0x76, 0x18,
	0xb9, 0x05, 0xd9, 0xbe, 0x69, 0x1d, 0x29, 0x0e, 0xaf, 0x8d, 0x73, 0xc8, 0x39, 0xab, 0xf3, 0x0d,
	0x54, 0x60, 0xea, 0x3f, 0xd4, 0x80, 0x70, 0xa0, 0x32, 0xfe, 0xa0, 0x94, 0x16, 0x61, 0x4f, 0x0b,
	0x87, 0xbd, 0x2a, 0xe4, 0x7b, 0x8e, 0x3d, 0x1a, 0xae, 0xab, 0x70, 0xa8, 0xa6, 0x1c, 0xbf, 0x8f,
	0x0f, 0x84, 0xa2, 0x63, 0x12, 0x93, 0x87, 0x0d, 0x93, 0x5c, 0xf9, 0x57, 0x43, 0x4c, 0xb4, 0x46,
	0x83, 0x81, 0xe1, 0x9c, 0xfe, 0x77, 0x78, 0xf9, 0x8d, 0x06, 0xb3, 0x11, 0x81, 0x04, 0x71, 0x91,
	0xb9, 0x9e, 0x39, 0xe0, 0x49, 0x17, 0x39, 0x29, 0xd0, 0x00, 0x10, 0x6d, 0x9c, 0x45, 0xaf, 0x15,
	0x6a, 0x9c, 0x9f, 0x86, 0x29, 0xb4, 0xf6, 0x96, 0x8f, 0x22, 0x58, 0x8b, 0x41, 0x49, 0x3d, 0x08,
	0x52, 0x19, 0xd4, 0xe0, 0x5c, 0xa4, 0x6d, 0x1e, 0x0b, 0x50, 0xff, 0x0f, 0x25, 0x6a, 0xbc, 0xff,
	0x9a, 0xe9, 0x7a, 0x76, 0xcf, 0x31, 0x06, 0xdc, 0x48, 0x0e, 0x47, 0x9d, 0x23, 0xe6, 0xc9, 0xa0,
	0x24, 0x67, 0xfc, 0xee, 0x9d, 0x10, 0x67, 0x62, 0xa2, 0xbf, 0x0e, 0x05, 0xd5, 0x78, 0x26, 0xbc,
	0x25, 0x3c, 0x1b, 0x7d, 0x4b, 0x98, 0x8f, 0xbe, 0x5f, 0xbc, 0xb9, 0xd5, 0xf2, 0x0c, 0xcf, 0xec,
	0xa8, 0x68, 0xfd, 0x0b, 0x0d, 0x8a, 0x21, 0x16, 0xc9, 0x3a, 0xcc, 0xf4, 0x0d, 0x8f, 0x59, 0x9d,
	0xd3, 0x83, 0x07, 0x8a, 0x3d, 0x69, 0x95, 0xc1, 0xab, 0x44, 0x98, 0x77, 0x5a, 0x91, 0xf8, 0xc1,
	0x6d, 0xfe, 0x17, 0x72, 0x2e, 0x73, 0x4c, 0xe9, 0xfd, 0xe1, 0x00, 0xef, 0xf7, 0xcb, 0x12, 0x81,
	0x5f, 0x5c, 0x84, 0x13, 0x29, 0x58, 0x39, 0xd3, 0x3f, 0x8e, 0x5a, 0xb7, 0x34, 0xac, 0xf1, 0x67,
	0x8e, 0x0b, 0xb4, 0x95, 0x4a, 0xd4, 0x56, 0xc0, 0x5f, 0xfa, 0x22, 0xfe, 0x2a, 0x90, 0x1e, 0xde,
	0xb9, 0x23, 0x1f, 0x09, 0xf8, 0x50, 0x40, 0x5e, 0x90, 0xd1, 0x9a, 0x0f, 0x05, 0x64, 0x55, 0x76,
	0xc6, 0x7c, 0x88, 0x90, 0x17, 0x56, 0x65, 0x0b, 0xcc, 0x87, 0xfa, 0xdb, 0x50, 0x4b, 0xf2, 0x13,
	0x69, 0xa2, 0x77, 0x60, 0xd2, 0x45, 0x90, 0xc9, 0xc6, 0x43, 0x40, 0xc2, 0xbe, 0x00, 0x5b, 0xff,
	0xa5, 0x06, 0xe5, 0x88, 0x62, 0x23, 0x99, 0x3a, 0x2b, 0x33, 0x75, 0x09, 0x34, 0x11, 0xb4, 0xd2,
	0x54, 0xb3, 0xf8, 0xec, 0x3e, 0xca, 0x5b, 0xa3, 0xda, 0x7d, 0x3e, 0x73, 0xe5, 0xc7, 0x10, 0xcd,
	0xe5, 0xb3, 0x43, 0x19, 0x64, 0xb5, 0x43, 0x3e, 0xeb, 0xca, 0x8b, 0x69, 0x5d, 0x7c, 0x95, 0x11,
	0x1f, 0x5b, 0xf2, 0x48, 0x5b, 0x7d, 0x54, 0x21, 0x90, 0x39, 0x32, 0xad, 0x2e, 0x96, 0x34, 0x59,
	0x8a, 0x63, 0x9d, 0x89, 0x8f, 0x04, 0x92, 0xf1, 0x0d, 0xc3, 0x33, 0x78, 0x3d, 0xed, 0x30, 0x77,
	0xd4, 0xf7, 0xda, 0x41, 0x21, 0x11, 0x82, 0xf0, 0x5a, 0x54, 0xcc, 0xa4, 0xd9, 0xd4, 0x12, 0x7d,
	0x08, 0x31, 0xa8, 0xc4, 0xe4, 0x51, 0x70, 0x66, 0x6c, 0x95, 0x9b, 0x49, 0xdf, 0x38, 0x64, 0xfd,
	0x50, 0x5d, 0x18, 0x00, 0x38, 0x1f, 0x38, 0xd9, 0x0f, 0xd5, 0x2e, 0x21, 0x08, 0x59, 0x81, 0x94,
	0xa7, 0x4c, 0x63, 0xf1, 0x6c, 0x1e, 0xf6, 0x6c, 0xd3, 0xf2, 0x68, 0xca, 0x73, 0xb9, 0x0f, 0xcd,
	0x27, 0x2f, 0xa3, 0x32, 0x4c, 0xc9, 0x44, 0x99, 0xe2, 0x98, 0x5b, 0xc7, 0xb1, 0xd1, 0xc7, 0x83,
	0x35, 0xca, 0x87, 0xbc, 0x1a, 0x60, 0x27, 0x6c, 0x30, 0xec, 0x1b, 0x4e, 0x5b, 0xbe, 0xc9, 0xa6,
	0xf1, 0x13, 0x61, 0x1c, 0x4c, 0x6e, 0x42, 0x45, 0x81, 0xd4, 0x57, 0x1e, 0x69, 0x9c, 0x63, 0x70,
	0xbd, 0x05, 0xb3, 0xf8, 0xc1, 0x66, 0xd3, 0x72, 0x3d, 0xc3, 0xf2, 0xce, 0x8f, 0xca, 0x7e, 0x94,
	0x95, 0x91, 0x26, 0x12, 0x65, 0x85, 0x6f, 0x62, 0x94, 0xfd, 0xa3, 0x06, 0x73, 0x51, 0xaa, 0xd2,
	0x86, 0xeb, 0xbe, 0x53, 0x09, 0x03, 0x0e, 0xe2, 0x8e, 0xc4, 0x6c, 0xe1, 0xaa, 0xef, 0x59, 0x8f,
	0xfc, 0x92, 0x7d, 0x89, 0xdf, 0xfa, 0x7e, 0xa0, 0x41, 0x39, 0xc2, 0x15, 0xb9, 0x03, 0x39, 0xb4,
	0x80, 0x71, 0xf7, 0x1b, 0x7f, 0xec, 0x93, 0x1f, 0xeb, 0xe4, 0x86, 0x68, 0x15, 0xac, 0xc9, 0xb8,
	0x4a, 0x16, 0xa1, 0x38, 0x74, 0xec, 0xc1, 0x81, 0xa4, 0x2a, 0x1e, 0xc6, 0x81, 0x83, 0xb6, 0x10,
	0xa2, 0x7f, 0x9c, 0x86, 0x19, 0x14, 0x24, 0x35, 0xac, 0x1e, 0xbb, 0x14, 0xe5, 0x60, 0x17, 0xeb,
	0xb1, 0xa1, 0xb4, 0x08, 0x1c, 0x47, 0x3f, 0x10, 0xe7, 0xe3, 0x1f, 0x88, 0x43, 0x9d, 0x7f, 0xe1,
	0x9c, 0xce, 0x7f, 0xf2, 0xc2, 0xce, 0x1f, 0x92, 0x3a, 0xff, 0x50, 0xbf, 0x5d, 0x8c, 0xf6, 0xdb,
	0xe1, 0x37, 0x81, 0x52, 0xec, 0x4d, 0x40, 0xf5, 0xe2, 0xe5, 0x33, 0x7b, 0xf1, 0xa9, 0x87, 0xea,
	0xc5, 0xa7, 0x1f, 0xf9, 0x09, 0x87, 0x97, 0x0a, 0xd2, 0x8b, 0xdc, 0x6a, 0x45, 0xdc, 0xd9, 0x07,
	0xf0, 0xd5, 0x81, 0x71, 0x22, 0x0c, 0xa6, 0x3a, 0x23, 0x56, 0x7d, 0x80, 0xfe, 0x07, 0x0d, 0x48,
	0x58, 0x9f, 0xd2, 0x2d, 0x9e, 0x89, 0xb9, 0xc5, 0x6c, 0x90, 0x8e, 0xcd, 0x01, 0xfb, 0x1a, 0xf9,
	0xc4, 0x07, 0x50, 0x68, 0xca, 0xab, 0x5e, 0xbe, 0x37, 0xfc, 0x0f, 0x94, 0xfc, 0xff, 0x48, 0x1c,
	0x0c, 0x04, 0xb3, 0x69, 0x5a, 0xf4, 0x61, 0xdb, 0xae, 0xbe, 0x06, 0xb9, 0x96, 0xc1, 0x9b, 0xa8,
	0x31, 0xe4, 0xd4, 0x18, 0x72, 0x70, 0x8a, 0x16, 0x3a, 0x45, 0xff, 0x44, 0x03, 0x08, 0xa4, 0xfa,
	0x65, 0x6e, 0xb1, 0x02, 0x79, 0x17, 0x99, 0x51, 0x25, 0xcc, 0x74, 0xa0, 0x08, 0x84, 0x4b, 0x7c,
	0x85, 0x75, 0xa1, 0xbb, 0x93, 0x17, 0xc2, 0xa6, 0x95, 0x89, 0x95, 0x1d, 0x4a, 0xf0, 0x92, 0x6a,
	0x80, 0x79, 0xf3, 0x5d, 0x98, 0x8e, 0xf5, 0x5f, 0xa4, 0x04, 0x85, 0x9d, 0xdd, 0x83, 0x26, 0xa5,
	0xbb, 0xb4, 0x32, 0x41, 0x66, 0x61, 0x7a, 0x7b, 0xed, 0x9d, 0x83, 0xad, 0xcd, 0xfd, 0xe6, 0x41,
	0x9b, 0xae, 0xdd, 0x6d, 0xb6, 0x2a, 0x1a, 0x07, 0xe2, 0xf8, 0xa0, 0xbd, 0xbb, 0x7b, 0xb0, 0xb5,
	0x46, 0xef, 0x35, 0x2b, 0x29, 0x32, 0x03, 0xe5, 0xb7, 0x76, 0xde, 0xd8, 0xd9, 0x7d, 0x7b, 0x47,
	0x6e, 0x4e, 0xdf, 0xbc, 0x09, 0xe5, 0x88, 0x99, 0x70, 0xda, 0x77, 0x77, 0xb7, 0xf7, 0xb6, 0x9a,
	0xed, 0x66, 0x65, 0x82, 0x14, 0x21, 0xbf, 0xb7, 0x46, 0xdb, 0x9b, 0x6b, 0x5b, 0x15, 0xad, 0xf1,
	0x73, 0x0d, 0x72, 0x9c, 0x15, 0xe6, 0x90, 0x6f, 0xc3, 0xa4, 0xdf, 0xf1, 0x91, 0xab, 0x91, 0x46,
	0x31, 0xdc, 0x05, 0xd6, 0xae, 0x44, 0x96, 0x94, 0x4b, 0xe8, 0x13, 0x64, 0x0d, 0x8a, 0x3e, 0xf2,
	0x7e, 0xe3, 0x71, 0x48, 0x34, 0xfe, 0xa5, 0x41, 0x25, 0xda, 0x7a, 0xd9, 0x3e, 0x63, 0xd8, 0xc5,
	0xc5, 0xa8, 0x86, 0x5b, 0xc2, 0xb3, 0x19, 0xdb, 0x04, 0xb8, 0xc7, 0x3c, 0x55, 0x0b, 0x5f, 0x4b,
	0x4e, 0xfe, 0x82, 0xc6, 0xf5, 0x33, 0x2a, 0x03, 0x45, 0xea, 0x1e, 0x40, 0x10, 0x0e, 0x48, 0x50,
	0xcb, 0x8c, 0xc5, 0xfc, 0xda, 0xb5, 0xc4, 0x35, 0xff, 0xa6, 0xbf, 0xce, 0x40, 0x9e, 0x2f, 0x98,
	0xcc, 0x21, 0xaf, 0x41, 0xf9, 0x55, 0xd3, 0xea, 0xfa, 0x7f, 0x54, 0x21, 0x09, 0xff, 0x91, 0x51,
	0x64, 0x6b, 0x49, 0x4b, 0x21, 0x15, 0x94, 0xd4, 0x07, 0xe9, 0x0e, 0xb3, 0x3c, 0x72, 0xc6, 0xbf,
	0x20, 0x6a, 0x4f, 0x8c, 0xc1, 0x7d, 0x12, 0x4d, 0x28, 0x86, 0xfe, 0x61, 0x11, 0x96, 0xd6, 0xd8,
	0xff, 0x2e, 0xce, 0x23, 0x73, 0x0f, 0x20, 0x78, 0x1a, 0x24, 0xe7, 0x7c, 0xe8, 0xa8, 0x5d, 0x4b,
	0x5c, 0xf3, 0x09, 0xbd, 0xa1, 0xae, 0x24, 0xde, 0x18, 0xcf, 0x25, 0xf5, 0x64, 0xe2, 0x3b, 0x67,
	0x88, 0xd8, 0x3e, 0x4c, 0xc7, 0x1e, 0xb1, 0xc8, 0x45, 0x2f, 0xea, 0xb5, 0xa5, 0xb3, 0x11, 0x7c,
	0xba, 0xdf, 0x0d, 0x3d, 0x84, 0xaa, 0xc7, 0xb1, 0x8b, 0x29, 0xeb, 0x67, 0x21, 0x84, 0x79, 0x6e,
	0xfc, 0x35, 0x03, 0x95, 0x96, 0xe7, 0x30, 0x63, 0x60, 0x5a, 0x3d, 0x65, 0x32, 0x2f, 0x43, 0x4e,
	0x66, 0xe3, 0x47, 0x55, 0xf1, 0xaa, 0xc6, 0xfd, 0xe1, 0x52, 0x74, 0xb3, 0xaa, 0x91, 0xed, 0x4b,
	0xd4, 0xce, 0xaa, 0x46, 0xde, 0xf9, 0x6a, 0xf4, 0xb3, 0xaa, 0x91, 0x77, 0xbf, 0x3a, 0x0d, 0xad,
	0x6a, 0x64, 0x0f, 0x66, 0x64, 0xac, 0xb8, 0x94, 0xe8, 0xb0, 0xaa, 0x91, 0x7d, 0x98, 0x0d, 0x53,
	0x94, 0x75, 0x2d, 0xb9, 0x1e, 0xdd, 0x17, 0x6d, 0x02, 0x42, 0x12, 0x4e, 0x2a, 0xe6, 0x39, 0xdd,
	0xc6, 0xef, 0x34, 0xc8, 0xab, 0x48, 0x78, 0x90, 0xd8, 0x8d, 0xeb, 0xe7, 0xf5, 0xa8, 0xf2, 0xa0,
	0xa7, 0xce, 0xc5, 0xb9, 0xf4, 0x68, 0xb9, 0x5e, 0xfd, 0xe8, 0xf3, 0x05, 0xed, 0x93, 0xcf, 0x17,
	0xb4, 0x7f, 0x7e, 0xbe, 0xa0, 0x7d, 0xf8, 0xc5, 0xc2, 0xc4, 0x27, 0x5f, 0x2c, 0x4c, 0x7c, 0xfa,
	0xc5, 0xc2, 0xc4, 0x61, 0x0e, 0x9f, 0xd8, 0x9f, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0,
	0x4e, 0x3e, 0x6c, 0x3d, 0x2a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PusherClient is the client API for Pusher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PusherClient interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
	PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error)
}

type pusherClient struct {
	cc *grpc.ClientConn
}

func NewPusherClient(cc *grpc.ClientConn) PusherClient {
	return &pusherClient{cc}
}

func (c *pusherClient) PushBytes(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pusherClient) PushBytesV2(ctx context.Context, in *PushBytesRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Pusher/PushBytesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PusherServer is the server API for Pusher service.
type PusherServer interface {
	// different versions of PushBytes expect the trace data to be pushed in
	// different formats
	PushBytes(context.Context, *PushBytesRequest) (*PushResponse, error)
	PushBytesV2(context.Context, *PushBytesRequest) (*PushResponse, error)
}

// UnimplementedPusherServer can be embedded to have forward compatible implementations.
type UnimplementedPusherServer struct {
}

func (*UnimplementedPusherServer) PushBytes(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytes not implemented")
}
func (*UnimplementedPusherServer) PushBytesV2(ctx context.Context, req *PushBytesRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushBytesV2 not implemented")
}

func RegisterPusherServer(s *grpc.Server, srv PusherServer) {
	s.RegisterService(&_Pusher_serviceDesc, srv)
}

func _Pusher_PushBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytes(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pusher_PushBytesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).PushBytesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Pusher/PushBytesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).PushBytesV2(ctx, req.(*PushBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pusher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Pusher",
	HandlerType: (*PusherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushBytes",
			Handler:    _Pusher_PushBytes_Handler,
		},
		{
			MethodName: "PushBytesV2",
			Handler:    _Pusher_PushBytesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsGeneratorClient is the client API for MetricsGenerator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsGeneratorClient interface {
	PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error)
	GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsGeneratorClient struct {
	cc *grpc.ClientConn
}

func NewMetricsGeneratorClient(cc *grpc.ClientConn) MetricsGeneratorClient {
	return &metricsGeneratorClient{cc}
}

func (c *metricsGeneratorClient) PushSpans(ctx context.Context, in *PushSpansRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/PushSpans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) GetMetrics(ctx context.Context, in *SpanMetricsRequest, opts ...grpc.CallOption) (*SpanMetricsResponse, error) {
	out := new(SpanMetricsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/GetMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsGeneratorClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.MetricsGenerator/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsGeneratorServer is the server API for MetricsGenerator service.
type MetricsGeneratorServer interface {
	PushSpans(context.Context, *PushSpansRequest) (*PushResponse, error)
	GetMetrics(context.Context, *SpanMetricsRequest) (*SpanMetricsResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsGeneratorServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsGeneratorServer struct {
}

func (*UnimplementedMetricsGeneratorServer) PushSpans(ctx context.Context, req *PushSpansRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpans not implemented")
}
func (*UnimplementedMetricsGeneratorServer) GetMetrics(ctx context.Context, req *SpanMetricsRequest) (*SpanMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (*UnimplementedMetricsGeneratorServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsGeneratorServer(s *grpc.Server, srv MetricsGeneratorServer) {
	s.RegisterService(&_MetricsGenerator_serviceDesc, srv)
}

func _MetricsGenerator_PushSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/PushSpans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).PushSpans(ctx, req.(*PushSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/GetMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).GetMetrics(ctx, req.(*SpanMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsGenerator_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.MetricsGenerator/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsGeneratorServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetricsGenerator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.MetricsGenerator",
	HandlerType: (*MetricsGeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushSpans",
			Handler:    _MetricsGenerator_PushSpans_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _MetricsGenerator_GetMetrics_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _MetricsGenerator_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error)
	SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) FindTraceByID(ctx context.Context, in *TraceByIDRequest, opts ...grpc.CallOption) (*TraceByIDResponse, error) {
	out := new(TraceByIDResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/FindTraceByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchRecent(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchRecent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchBlock(ctx context.Context, in *SearchBlockRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsResponse, error) {
	out := new(SearchTagsResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (*SearchTagsV2Response, error) {
	out := new(SearchTagsV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesResponse, error) {
	out := new(SearchTagValuesResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *querierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (*SearchTagValuesV2Response, error) {
	out := new(SearchTagValuesV2Response)
	err := c.cc.Invoke(ctx, "/tempopb.Querier/SearchTagValuesV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	FindTraceByID(context.Context, *TraceByIDRequest) (*TraceByIDResponse, error)
	SearchRecent(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchBlock(context.Context, *SearchBlockRequest) (*SearchResponse, error)
	SearchTags(context.Context, *SearchTagsRequest) (*SearchTagsResponse, error)
	SearchTagsV2(context.Context, *SearchTagsRequest) (*SearchTagsV2Response, error)
	SearchTagValues(context.Context, *SearchTagValuesRequest) (*SearchTagValuesResponse, error)
	SearchTagValuesV2(context.Context, *SearchTagValuesRequest) (*SearchTagValuesV2Response, error)
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) FindTraceByID(ctx context.Context, req *TraceByIDRequest) (*TraceByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTraceByID not implemented")
}
func (*UnimplementedQuerierServer) SearchRecent(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRecent not implemented")
}
func (*UnimplementedQuerierServer) SearchBlock(ctx context.Context, req *SearchBlockRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBlock not implemented")
}
func (*UnimplementedQuerierServer) SearchTags(ctx context.Context, req *SearchTagsRequest) (*SearchTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedQuerierServer) SearchTagsV2(ctx context.Context, req *SearchTagsRequest) (*SearchTagsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValues(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedQuerierServer) SearchTagValuesV2(ctx context.Context, req *SearchTagValuesRequest) (*SearchTagValuesV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_FindTraceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).FindTraceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/FindTraceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).FindTraceByID(ctx, req.(*TraceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchRecent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchRecent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchRecent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchRecent(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchBlock(ctx, req.(*SearchBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTags(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagsV2(ctx, req.(*SearchTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValues(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Querier_SearchTagValuesV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTagValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Querier/SearchTagValuesV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuerierServer).SearchTagValuesV2(ctx, req.(*SearchTagValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindTraceByID",
			Handler:    _Querier_FindTraceByID_Handler,
		},
		{
			MethodName: "SearchRecent",
			Handler:    _Querier_SearchRecent_Handler,
		},
		{
			MethodName: "SearchBlock",
			Handler:    _Querier_SearchBlock_Handler,
		},
		{
			MethodName: "SearchTags",
			Handler:    _Querier_SearchTags_Handler,
		},
		{
			MethodName: "SearchTagsV2",
			Handler:    _Querier_SearchTagsV2_Handler,
		},
		{
			MethodName: "SearchTagValues",
			Handler:    _Querier_SearchTagValues_Handler,
		},
		{
			MethodName: "SearchTagValuesV2",
			Handler:    _Querier_SearchTagValuesV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

// StreamingQuerierClient is the client API for StreamingQuerier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingQuerierClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error)
	SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error)
	SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error)
	SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error)
	SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error)
	MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error)
	MetricsQueryInstant(ctx context.Context, in *QueryInstantRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryInstantClient, error)
}

type streamingQuerierClient struct {
	cc *grpc.ClientConn
}

func NewStreamingQuerierClient(cc *grpc.ClientConn) StreamingQuerierClient {
	return &streamingQuerierClient{cc}
}

func (c *streamingQuerierClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[0], "/tempopb.StreamingQuerier/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTags(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[1], "/tempopb.StreamingQuerier/SearchTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsClient interface {
	Recv() (*SearchTagsResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsClient) Recv() (*SearchTagsResponse, error) {
	m := new(SearchTagsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagsV2(ctx context.Context, in *SearchTagsRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagsV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[2], "/tempopb.StreamingQuerier/SearchTagsV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagsV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagsV2Client interface {
	Recv() (*SearchTagsV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagsV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagsV2Client) Recv() (*SearchTagsV2Response, error) {
	m := new(SearchTagsV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValues(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[3], "/tempopb.StreamingQuerier/SearchTagValues", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesClient interface {
	Recv() (*SearchTagValuesResponse, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesClient) Recv() (*SearchTagValuesResponse, error) {
	m := new(SearchTagValuesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) SearchTagValuesV2(ctx context.Context, in *SearchTagValuesRequest, opts ...grpc.CallOption) (StreamingQuerier_SearchTagValuesV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[4], "/tempopb.StreamingQuerier/SearchTagValuesV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierSearchTagValuesV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_SearchTagValuesV2Client interface {
	Recv() (*SearchTagValuesV2Response, error)
	grpc.ClientStream
}

type streamingQuerierSearchTagValuesV2Client struct {
	grpc.ClientStream
}

func (x *streamingQuerierSearchTagValuesV2Client) Recv() (*SearchTagValuesV2Response, error) {
	m := new(SearchTagValuesV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) MetricsQueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[5], "/tempopb.StreamingQuerier/MetricsQueryRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierMetricsQueryRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_MetricsQueryRangeClient interface {
	Recv() (*QueryRangeResponse, error)
	grpc.ClientStream
}

type streamingQuerierMetricsQueryRangeClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierMetricsQueryRangeClient) Recv() (*QueryRangeResponse, error) {
	m := new(QueryRangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingQuerierClient) MetricsQueryInstant(ctx context.Context, in *QueryInstantRequest, opts ...grpc.CallOption) (StreamingQuerier_MetricsQueryInstantClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingQuerier_serviceDesc.Streams[6], "/tempopb.StreamingQuerier/MetricsQueryInstant", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingQuerierMetricsQueryInstantClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingQuerier_MetricsQueryInstantClient interface {
	Recv() (*QueryInstantResponse, error)
	grpc.ClientStream
}

type streamingQuerierMetricsQueryInstantClient struct {
	grpc.ClientStream
}

func (x *streamingQuerierMetricsQueryInstantClient) Recv() (*QueryInstantResponse, error) {
	m := new(QueryInstantResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingQuerierServer is the server API for StreamingQuerier service.
type StreamingQuerierServer interface {
	Search(*SearchRequest, StreamingQuerier_SearchServer) error
	SearchTags(*SearchTagsRequest, StreamingQuerier_SearchTagsServer) error
	SearchTagsV2(*SearchTagsRequest, StreamingQuerier_SearchTagsV2Server) error
	SearchTagValues(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesServer) error
	SearchTagValuesV2(*SearchTagValuesRequest, StreamingQuerier_SearchTagValuesV2Server) error
	MetricsQueryRange(*QueryRangeRequest, StreamingQuerier_MetricsQueryRangeServer) error
	MetricsQueryInstant(*QueryInstantRequest, StreamingQuerier_MetricsQueryInstantServer) error
}

// UnimplementedStreamingQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingQuerierServer struct {
}

func (*UnimplementedStreamingQuerierServer) Search(req *SearchRequest, srv StreamingQuerier_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTags(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTags not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagsV2(req *SearchTagsRequest, srv StreamingQuerier_SearchTagsV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagsV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValues(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValues not implemented")
}
func (*UnimplementedStreamingQuerierServer) SearchTagValuesV2(req *SearchTagValuesRequest, srv StreamingQuerier_SearchTagValuesV2Server) error {
	return status.Errorf(codes.Unimplemented, "method SearchTagValuesV2 not implemented")
}
func (*UnimplementedStreamingQuerierServer) MetricsQueryRange(req *QueryRangeRequest, srv StreamingQuerier_MetricsQueryRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method MetricsQueryRange not implemented")
}
func (*UnimplementedStreamingQuerierServer) MetricsQueryInstant(req *QueryInstantRequest, srv StreamingQuerier_MetricsQueryInstantServer) error {
	return status.Errorf(codes.Unimplemented, "method MetricsQueryInstant not implemented")
}

func RegisterStreamingQuerierServer(s *grpc.Server, srv StreamingQuerierServer) {
	s.RegisterService(&_StreamingQuerier_serviceDesc, srv)
}

func _StreamingQuerier_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).Search(m, &streamingQuerierSearchServer{stream})
}

type StreamingQuerier_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTags(m, &streamingQuerierSearchTagsServer{stream})
}

type StreamingQuerier_SearchTagsServer interface {
	Send(*SearchTagsResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsServer) Send(m *SearchTagsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagsV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagsV2(m, &streamingQuerierSearchTagsV2Server{stream})
}

type StreamingQuerier_SearchTagsV2Server interface {
	Send(*SearchTagsV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagsV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagsV2Server) Send(m *SearchTagsV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValues(m, &streamingQuerierSearchTagValuesServer{stream})
}

type StreamingQuerier_SearchTagValuesServer interface {
	Send(*SearchTagValuesResponse) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesServer) Send(m *SearchTagValuesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_SearchTagValuesV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchTagValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).SearchTagValuesV2(m, &streamingQuerierSearchTagValuesV2Server{stream})
}

type StreamingQuerier_SearchTagValuesV2Server interface {
	Send(*SearchTagValuesV2Response) error
	grpc.ServerStream
}

type streamingQuerierSearchTagValuesV2Server struct {
	grpc.ServerStream
}

func (x *streamingQuerierSearchTagValuesV2Server) Send(m *SearchTagValuesV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_MetricsQueryRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).MetricsQueryRange(m, &streamingQuerierMetricsQueryRangeServer{stream})
}

type StreamingQuerier_MetricsQueryRangeServer interface {
	Send(*QueryRangeResponse) error
	grpc.ServerStream
}

type streamingQuerierMetricsQueryRangeServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierMetricsQueryRangeServer) Send(m *QueryRangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamingQuerier_MetricsQueryInstant_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryInstantRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingQuerierServer).MetricsQueryInstant(m, &streamingQuerierMetricsQueryInstantServer{stream})
}

type StreamingQuerier_MetricsQueryInstantServer interface {
	Send(*QueryInstantResponse) error
	grpc.ServerStream
}

type streamingQuerierMetricsQueryInstantServer struct {
	grpc.ServerStream
}

func (x *streamingQuerierMetricsQueryInstantServer) Send(m *QueryInstantResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingQuerier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.StreamingQuerier",
	HandlerType: (*StreamingQuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Search",
			Handler:       _StreamingQuerier_Search_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTags",
			Handler:       _StreamingQuerier_SearchTags_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagsV2",
			Handler:       _StreamingQuerier_SearchTagsV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValues",
			Handler:       _StreamingQuerier_SearchTagValues_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchTagValuesV2",
			Handler:       _StreamingQuerier_SearchTagValuesV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MetricsQueryRange",
			Handler:       _StreamingQuerier_MetricsQueryRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MetricsQueryInstant",
			Handler:       _StreamingQuerier_MetricsQueryInstant_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/tempopb/tempo.proto",
}

// MetricsClient is the client API for Metrics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetricsClient interface {
	SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error)
}

type metricsClient struct {
	cc *grpc.ClientConn
}

func NewMetricsClient(cc *grpc.ClientConn) MetricsClient {
	return &metricsClient{cc}
}

func (c *metricsClient) SpanMetricsSummary(ctx context.Context, in *SpanMetricsSummaryRequest, opts ...grpc.CallOption) (*SpanMetricsSummaryResponse, error) {
	out := new(SpanMetricsSummaryResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/SpanMetricsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (*QueryRangeResponse, error) {
	out := new(QueryRangeResponse)
	err := c.cc.Invoke(ctx, "/tempopb.Metrics/QueryRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsServer is the server API for Metrics service.
type MetricsServer interface {
	SpanMetricsSummary(context.Context, *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error)
	QueryRange(context.Context, *QueryRangeRequest) (*QueryRangeResponse, error)
}

// UnimplementedMetricsServer can be embedded to have forward compatible implementations.
type UnimplementedMetricsServer struct {
}

func (*UnimplementedMetricsServer) SpanMetricsSummary(ctx context.Context, req *SpanMetricsSummaryRequest) (*SpanMetricsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpanMetricsSummary not implemented")
}
func (*UnimplementedMetricsServer) QueryRange(ctx context.Context, req *QueryRangeRequest) (*QueryRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterMetricsServer(s *grpc.Server, srv MetricsServer) {
	s.RegisterService(&_Metrics_serviceDesc, srv)
}

func _Metrics_SpanMetricsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanMetricsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/SpanMetricsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).SpanMetricsSummary(ctx, req.(*SpanMetricsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metrics_QueryRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServer).QueryRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tempopb.Metrics/QueryRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServer).QueryRange(ctx, req.(*QueryRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metrics_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tempopb.Metrics",
	HandlerType: (*MetricsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpanMetricsSummary",
			Handler:    _Metrics_SpanMetricsSummary_Handler,
		},
		{
			MethodName: "QueryRange",
			Handler:    _Metrics_QueryRange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/tempopb/tempo.proto",
}

func (m *TraceByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RF1After, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTempo(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x3a
	if m.AllowPartialTrace {
		i--
		if m.AllowPartialTrace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BlockEnd) > 0 {
		i -= len(m.BlockEnd)
		copy(dAtA[i:], m.BlockEnd)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockStart) > 0 {
		i -= len(m.BlockStart)
		copy(dAtA[i:], m.BlockStart)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceByIDMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceByIDMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceByIDMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RF1After, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTempo(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x52
	if m.SpansPerSpanSet != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpansPerSpanSet))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x42
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x30
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxDurationMs))
		i--
		dAtA[i] = 0x18
	}
	if m.MinDurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MinDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTempo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceSearchMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceSearchMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceSearchMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceStats) > 0 {
		for k := range m.ServiceStats {
			v := m.ServiceStats[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTempo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTempo(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTempo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpanSets) > 0 {
		for iNdEx := len(m.SpanSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SpanSet != nil {
		{
			size, err := m.SpanSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DurationMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationMs))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RootTraceName) > 0 {
		i -= len(m.RootTraceName)
		copy(dAtA[i:], m.RootTraceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootTraceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RootServiceName) > 0 {
		i -= len(m.RootServiceName)
		copy(dAtA[i:], m.RootServiceName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.RootServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceID) > 0 {
		i -= len(m.TraceID)
		copy(dAtA[i:], m.TraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TraceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ErrorCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Matched != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Matched))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DurationNanos != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.DurationNanos))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTimeUnixNano != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpanID) > 0 {
		i -= len(m.SpanID)
		copy(dAtA[i:], m.SpanID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.SpanID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InspectedSpans != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedSpans))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x28
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedTraces != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedTraces))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RF1After, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintTempo(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x3a
	if m.StaleValuesThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValuesThreshold))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTagsPerScope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagsPerScope))
		i--
		dAtA[i] = 0x28
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StaleValueThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValueThreshold))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxTagsPerScope != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagsPerScope))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DataEncoding) > 0 {
		i -= len(m.DataEncoding)
		copy(dAtA[i:], m.DataEncoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.DataEncoding)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalRecords != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalRecords))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexPageSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.IndexPageSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x20
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x12
	}
	if m.SearchReq != nil {
		{
			size, err := m.SearchReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagNames) > 0 {
		for iNdEx := len(m.TagNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagNames[iNdEx])
			copy(dAtA[i:], m.TagNames[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagsV2Scope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagsV2Scope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagsV2Scope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RF1After, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintTempo(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x42
	if m.StaleValueThreshold != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StaleValueThreshold))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxTagValues != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxTagValues))
		i--
		dAtA[i] = 0x30
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagName) > 0 {
		i -= len(m.TagName)
		copy(dAtA[i:], m.TagName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.TagName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagValues[iNdEx])
			copy(dAtA[i:], m.TagValues[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.TagValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchTagValuesV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchTagValuesV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchTagValuesV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TagValues) > 0 {
		for iNdEx := len(m.TagValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetadataMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalBlockBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlockBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalBlocks != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalBlocks))
		i--
		dAtA[i] = 0x20
	}
	if m.CompletedJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.CompletedJobs))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalJobs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TotalJobs))
		i--
		dAtA[i] = 0x10
	}
	if m.InspectedBytes != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.InspectedBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceSpans) > 0 {
		for iNdEx := len(m.ResourceSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		dAtA18 := make([]byte, len(m.ErrorsByTrace)*10)
		var j17 int
		for _, num := range m.ErrorsByTrace {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintTempo(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PushBytesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushBytesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushBytesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipMetricsGeneration {
		i--
		if m.SkipMetricsGeneration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ids[iNdEx])
			copy(dAtA[i:], m.Ids[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Ids[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Traces[iNdEx].Size()
				i -= size
				if _, err := m.Traces[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *PushSpansRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushSpansRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushSpansRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipMetricsGeneration {
		i--
		if m.SkipMetricsGeneration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Traces[iNdEx])
			copy(dAtA[i:], m.Traces[iNdEx])
			i = encodeVarintTempo(dAtA, i, uint64(len(m.Traces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LinkSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Estimated {
		i--
		if m.Estimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawHistogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawHistogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Bucket != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Bucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Errors != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Errors))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LatencyHistogram) > 0 {
		for iNdEx := len(m.LatencyHistogram) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LatencyHistogram[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.P50 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P50))
		i--
		dAtA[i] = 0x38
	}
	if m.P90 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P90))
		i--
		dAtA[i] = 0x30
	}
	if m.P95 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P95))
		i--
		dAtA[i] = 0x28
	}
	if m.P99 != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.P99))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ErrorSpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ErrorSpanCount))
		i--
		dAtA[i] = 0x10
	}
	if m.SpanCount != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.SpanCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for iNdEx := len(m.Summaries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summaries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TraceQLStatic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceQLStatic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceQLStatic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.D != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.D))
		i--
		dAtA[i] = 0x30
	}
	if m.B {
		i--
		if m.B {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x22
	}
	if m.F != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.F))))
		i--
		dAtA[i] = 0x19
	}
	if m.N != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ResultType) > 0 {
		i -= len(m.ResultType)
		copy(dAtA[i:], m.ResultType)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ResultType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ts) > 0 {
		for iNdEx := len(m.Ts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LabelValue) > 0 {
		i -= len(m.LabelValue)
		copy(dAtA[i:], m.LabelValue)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LabelName) > 0 {
		i -= len(m.LabelName)
		copy(dAtA[i:], m.LabelName)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.LabelName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanMetricsResultPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanMetricsResultPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanMetricsResultPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExemplarDuration != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.ExemplarDuration))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExemplarTraceID) > 0 {
		i -= len(m.ExemplarTraceID)
		copy(dAtA[i:], m.ExemplarTraceID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.ExemplarTraceID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Val != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i--
		dAtA[i] = 0x11
	}
	if m.Time != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryInstantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInstantRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInstantRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInstantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInstantResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInstantResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstantSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstantSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstantSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PromLabels) > 0 {
		i -= len(m.PromLabels)
		copy(dAtA[i:], m.PromLabels)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.PromLabels)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSeries != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.MaxSeries))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Exemplars != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Exemplars))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.DedicatedColumns) > 0 {
		for iNdEx := len(m.DedicatedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DedicatedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.FooterSize != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.FooterSize))
		i--
		dAtA[i] = 0x70
	}
	if m.Size_ != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PagesToSearch != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.PagesToSearch))
		i--
		dAtA[i] = 0x50
	}
	if m.StartPage != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.StartPage))
		i--
		dAtA[i] = 0x48
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryMode) > 0 {
		i -= len(m.QueryMode)
		copy(dAtA[i:], m.QueryMode)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.QueryMode)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Step != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTempo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Exemplar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exemplar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exemplar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampMs != 0 {
		i = encodeVarintTempo(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exemplars) > 0 {
		for iNdEx := len(m.Exemplars) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exemplars[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PromLabels) > 0 {
		i -= len(m.PromLabels)
		copy(dAtA[i:], m.PromLabels)
		i = encodeVarintTempo(dAtA, i, uint64(len(m.PromLabels)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTempo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTempo(dAtA []byte, offset int, v uint64) int {
	offset -= sovTempo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TraceByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockStart)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockEnd)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.AllowPartialTrace {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After)
	n += 1 + l + sovTempo(uint64(l))
	return n
}

func (m *TraceByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceByIDMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + 1 + len(v) + sovTempo(uint64(len(v)))
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	if m.MinDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MinDurationMs))
	}
	if m.MaxDurationMs != 0 {
		n += 1 + sovTempo(uint64(m.MaxDurationMs))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.SpansPerSpanSet != 0 {
		n += 1 + sovTempo(uint64(m.SpansPerSpanSet))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After)
	n += 1 + l + sovTempo(uint64(l))
	return n
}

func (m *SearchBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *DedicatedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovTempo(uint64(m.Scope))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TraceSearchMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootServiceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.RootTraceName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationMs != 0 {
		n += 1 + sovTempo(uint64(m.DurationMs))
	}
	if m.SpanSet != nil {
		l = m.SpanSet.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.SpanSets) > 0 {
		for _, e := range m.SpanSets {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.ServiceStats) > 0 {
		for k, v := range m.ServiceStats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTempo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTempo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTempo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorCount))
	}
	return n
}

func (m *SpanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Matched != 0 {
		n += 1 + sovTempo(uint64(m.Matched))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpanID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartTimeUnixNano != 0 {
		n += 1 + sovTempo(uint64(m.StartTimeUnixNano))
	}
	if m.DurationNanos != 0 {
		n += 1 + sovTempo(uint64(m.DurationNanos))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedTraces != 0 {
		n += 1 + sovTempo(uint64(m.InspectedTraces))
	}
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	if m.InspectedSpans != 0 {
		n += 1 + sovTempo(uint64(m.InspectedSpans))
	}
	return n
}

func (m *SearchTagsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.MaxTagsPerScope != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagsPerScope))
	}
	if m.StaleValuesThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValuesThreshold))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After)
	n += 1 + l + sovTempo(uint64(l))
	return n
}

func (m *SearchTagsBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.MaxTagsPerScope != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagsPerScope))
	}
	if m.StaleValueThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValueThreshold))
	}
	return n
}

func (m *SearchTagValuesBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SearchReq != nil {
		l = m.SearchReq.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.IndexPageSize != 0 {
		n += 1 + sovTempo(uint64(m.IndexPageSize))
	}
	if m.TotalRecords != 0 {
		n += 1 + sovTempo(uint64(m.TotalRecords))
	}
	l = len(m.DataEncoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagNames) > 0 {
		for _, s := range m.TagNames {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagsV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagsV2Scope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SearchTagValuesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.MaxTagValues != 0 {
		n += 1 + sovTempo(uint64(m.MaxTagValues))
	}
	if m.StaleValueThreshold != 0 {
		n += 1 + sovTempo(uint64(m.StaleValueThreshold))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RF1After)
	n += 1 + l + sovTempo(uint64(l))
	return n
}

func (m *SearchTagValuesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, s := range m.TagValues {
			l = len(s)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *TagValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SearchTagValuesV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TagValues) > 0 {
		for _, e := range m.TagValues {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *MetadataMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InspectedBytes != 0 {
		n += 1 + sovTempo(uint64(m.InspectedBytes))
	}
	if m.TotalJobs != 0 {
		n += 1 + sovTempo(uint64(m.TotalJobs))
	}
	if m.CompletedJobs != 0 {
		n += 1 + sovTempo(uint64(m.CompletedJobs))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlocks))
	}
	if m.TotalBlockBytes != 0 {
		n += 1 + sovTempo(uint64(m.TotalBlockBytes))
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceSpans) > 0 {
		for _, e := range m.ResourceSpans {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *PushResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ErrorsByTrace) > 0 {
		l = 0
		for _, e := range m.ErrorsByTrace {
			l += sovTempo(uint64(e))
		}
		n += 1 + sovTempo(uint64(l)) + l
	}
	return n
}

func (m *PushBytesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Ids) > 0 {
		for _, b := range m.Ids {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.SkipMetricsGeneration {
		n += 2
	}
	return n
}

func (m *PushSpansRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.SkipMetricsGeneration {
		n += 2
	}
	return n
}

func (m *TraceBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Traces) > 0 {
		for _, b := range m.Traces {
			l = len(b)
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *LinkSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovTempo(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *SpanMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Estimated {
		n += 2
	}
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *RawHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != 0 {
		n += 1 + sovTempo(uint64(m.Bucket))
	}
	if m.Count != 0 {
		n += 1 + sovTempo(uint64(m.Count))
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *SpanMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LatencyHistogram) > 0 {
		for _, e := range m.LatencyHistogram {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Errors != 0 {
		n += 1 + sovTempo(uint64(m.Errors))
	}
	return n
}

func (m *SpanMetricsSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpanCount != 0 {
		n += 1 + sovTempo(uint64(m.SpanCount))
	}
	if m.ErrorSpanCount != 0 {
		n += 1 + sovTempo(uint64(m.ErrorSpanCount))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.P99 != 0 {
		n += 1 + sovTempo(uint64(m.P99))
	}
	if m.P95 != 0 {
		n += 1 + sovTempo(uint64(m.P95))
	}
	if m.P90 != 0 {
		n += 1 + sovTempo(uint64(m.P90))
	}
	if m.P50 != 0 {
		n += 1 + sovTempo(uint64(m.P50))
	}
	return n
}

func (m *SpanMetricsSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Summaries) > 0 {
		for _, e := range m.Summaries {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *TraceQLStatic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTempo(uint64(m.Type))
	}
	if m.N != 0 {
		n += 1 + sovTempo(uint64(m.N))
	}
	if m.F != 0 {
		n += 9
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.B {
		n += 2
	}
	if m.D != 0 {
		n += 1 + sovTempo(uint64(m.D))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	if m.Kind != 0 {
		n += 1 + sovTempo(uint64(m.Kind))
	}
	return n
}

func (m *SpanMetricsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResultType)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LabelName)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.LabelValue)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Ts) > 0 {
		for _, e := range m.Ts {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func (m *SpanMetricsResultPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovTempo(uint64(m.Time))
	}
	if m.Val != 0 {
		n += 9
	}
	l = len(m.ExemplarTraceID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.ExemplarDuration != 0 {
		n += 1 + sovTempo(uint64(m.ExemplarDuration))
	}
	return n
}

func (m *QueryInstantRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	return n
}

func (m *QueryInstantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *InstantSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Value != 0 {
		n += 9
	}
	l = len(m.PromLabels)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *QueryRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovTempo(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovTempo(uint64(m.End))
	}
	if m.Step != 0 {
		n += 1 + sovTempo(uint64(m.Step))
	}
	l = len(m.QueryMode)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.StartPage != 0 {
		n += 1 + sovTempo(uint64(m.StartPage))
	}
	if m.PagesToSearch != 0 {
		n += 1 + sovTempo(uint64(m.PagesToSearch))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTempo(uint64(m.Size_))
	}
	if m.FooterSize != 0 {
		n += 1 + sovTempo(uint64(m.FooterSize))
	}
	if len(m.DedicatedColumns) > 0 {
		for _, e := range m.DedicatedColumns {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Exemplars != 0 {
		n += 2 + sovTempo(uint64(m.Exemplars))
	}
	if m.MaxSeries != 0 {
		n += 2 + sovTempo(uint64(m.MaxSeries))
	}
	return n
}

func (m *QueryRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovTempo(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTempo(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	return n
}

func (m *Exemplar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovTempo(uint64(m.TimestampMs))
	}
	return n
}

func (m *Sample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovTempo(uint64(m.TimestampMs))
	}
	return n
}

func (m *TimeSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	l = len(m.PromLabels)
	if l > 0 {
		n += 1 + l + sovTempo(uint64(l))
	}
	if len(m.Exemplars) > 0 {
		for _, e := range m.Exemplars {
			l = e.Size()
			n += 1 + l + sovTempo(uint64(l))
		}
	}
	return n
}

func sovTempo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTempo(x uint64) (n int) {
	return sovTempo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TraceByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = append(m.TraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.TraceID == nil {
				m.TraceID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPartialTrace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPartialTrace = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RF1After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RF1After, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &TraceByIDMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PartialStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceByIDMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceByIDMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceByIDMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationMs", wireType)
			}
			m.MinDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDurationMs", wireType)
			}
			m.MaxDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpansPerSpanSet", wireType)
			}
			m.SpansPerSpanSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpansPerSpanSet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RF1After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RF1After, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DedicatedColumn_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= DedicatedColumn_Scope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &TraceSearchMetadata{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceSearchMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceSearchMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceSearchMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootTraceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootTraceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationMs", wireType)
			}
			m.DurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanSet == nil {
				m.SpanSet = &SpanSet{}
			}
			if err := m.SpanSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanSets = append(m.SpanSets, &SpanSet{})
			if err := m.SpanSets[len(m.SpanSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceStats == nil {
				m.ServiceStats = make(map[string]*ServiceStats)
			}
			var mapkey string
			var mapvalue *ServiceStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTempo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTempo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTempo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTempo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTempo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceStats[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			m.Matched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matched |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeUnixNano |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedTraces", wireType)
			}
			m.InspectedTraces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedTraces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedSpans", wireType)
			}
			m.InspectedSpans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedSpans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagsPerScope", wireType)
			}
			m.MaxTagsPerScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagsPerScope |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValuesThreshold", wireType)
			}
			m.StaleValuesThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValuesThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RF1After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RF1After, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagsRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagsPerScope", wireType)
			}
			m.MaxTagsPerScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagsPerScope |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValueThreshold", wireType)
			}
			m.StaleValueThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValueThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchReq == nil {
				m.SearchReq = &SearchTagValuesRequest{}
			}
			if err := m.SearchReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPageSize", wireType)
			}
			m.IndexPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexPageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagNames = append(m.TagNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, &SearchTagsV2Scope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagsV2Scope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagsV2Scope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagsV2Scope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTagValues", wireType)
			}
			m.MaxTagValues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTagValues |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleValueThreshold", wireType)
			}
			m.StaleValueThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleValueThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RF1After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RF1After, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchTagValuesV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchTagValuesV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValues = append(m.TagValues, &TagValue{})
			if err := m.TagValues[len(m.TagValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &MetadataMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectedBytes", wireType)
			}
			m.InspectedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InspectedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalJobs", wireType)
			}
			m.TotalJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedJobs", wireType)
			}
			m.CompletedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlockBytes", wireType)
			}
			m.TotalBlockBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBlockBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSpans = append(m.ResourceSpans, &v11.ResourceSpans{})
			if err := m.ResourceSpans[len(m.ResourceSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v PushErrorReason
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PushErrorReason(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ErrorsByTrace = append(m.ErrorsByTrace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTempo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTempo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTempo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ErrorsByTrace) == 0 {
					m.ErrorsByTrace = make([]PushErrorReason, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PushErrorReason
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTempo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PushErrorReason(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ErrorsByTrace = append(m.ErrorsByTrace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByTrace", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushBytesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushBytesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushBytesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v PreallocBytes
			m.Traces = append(m.Traces, v)
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, make([]byte, postIndex-iNdEx))
			copy(m.Ids[len(m.Ids)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMetricsGeneration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMetricsGeneration = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushSpansRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushSpansRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushSpansRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, &v11.ResourceSpans{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMetricsGeneration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMetricsGeneration = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceBytes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, make([]byte, postIndex-iNdEx))
			copy(m.Traces[len(m.Traces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &v11.Span_Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Estimated = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &SpanMetrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			m.Bucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &TraceQLStatic{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyHistogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyHistogram = append(m.LatencyHistogram, &RawHistogram{})
			if err := m.LatencyHistogram[len(m.LatencyHistogram)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanCount", wireType)
			}
			m.SpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorSpanCount", wireType)
			}
			m.ErrorSpanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorSpanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &KeyValue{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P99", wireType)
			}
			m.P99 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P99 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P95", wireType)
			}
			m.P95 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P95 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			m.P90 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P90 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			m.P50 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P50 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summaries = append(m.Summaries, &SpanMetricsSummary{})
			if err := m.Summaries[len(m.Summaries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceQLStatic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceQLStatic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceQLStatic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.F = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.B = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			m.D = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.D |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &SpanMetricsResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ts = append(m.Ts, &SpanMetricsResultPoint{})
			if err := m.Ts[len(m.Ts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanMetricsResultPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanMetricsResultPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarTraceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExemplarTraceID = append(m.ExemplarTraceID[:0], dAtA[iNdEx:postIndex]...)
			if m.ExemplarTraceID == nil {
				m.ExemplarTraceID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemplarDuration", wireType)
			}
			m.ExemplarDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExemplarDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInstantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInstantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInstantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInstantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInstantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInstantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &InstantSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PartialStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstantSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstantSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstantSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromLabels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPage", wireType)
			}
			m.StartPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagesToSearch", wireType)
			}
			m.PagesToSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PagesToSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FooterSize", wireType)
			}
			m.FooterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FooterSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DedicatedColumns = append(m.DedicatedColumns, &DedicatedColumn{})
			if err := m.DedicatedColumns[len(m.DedicatedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			m.Exemplars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exemplars |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSeries", wireType)
			}
			m.MaxSeries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSeries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &TimeSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &SearchMetrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PartialStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exemplar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exemplar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exemplar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, v1.KeyValue{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromLabels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTempo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTempo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exemplars = append(m.Exemplars, Exemplar{})
			if err := m.Exemplars[len(m.Exemplars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTempo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTempo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTempo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTempo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTempo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTempo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTempo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTempo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTempo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTempo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTempo = fmt.Errorf("proto: unexpected end of group")
)
