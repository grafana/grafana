// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/grafana/nanogit"
	"github.com/grafana/nanogit/protocol/hash"
)

type FakeClient struct {
	CloneStub        func(context.Context, nanogit.CloneOptions) (*nanogit.CloneResult, error)
	cloneMutex       sync.RWMutex
	cloneArgsForCall []struct {
		arg1 context.Context
		arg2 nanogit.CloneOptions
	}
	cloneReturns struct {
		result1 *nanogit.CloneResult
		result2 error
	}
	cloneReturnsOnCall map[int]struct {
		result1 *nanogit.CloneResult
		result2 error
	}
	CompareCommitsStub        func(context.Context, hash.Hash, hash.Hash) ([]nanogit.CommitFile, error)
	compareCommitsMutex       sync.RWMutex
	compareCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 hash.Hash
	}
	compareCommitsReturns struct {
		result1 []nanogit.CommitFile
		result2 error
	}
	compareCommitsReturnsOnCall map[int]struct {
		result1 []nanogit.CommitFile
		result2 error
	}
	CreateRefStub        func(context.Context, nanogit.Ref) error
	createRefMutex       sync.RWMutex
	createRefArgsForCall []struct {
		arg1 context.Context
		arg2 nanogit.Ref
	}
	createRefReturns struct {
		result1 error
	}
	createRefReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRefStub        func(context.Context, string) error
	deleteRefMutex       sync.RWMutex
	deleteRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteRefReturns struct {
		result1 error
	}
	deleteRefReturnsOnCall map[int]struct {
		result1 error
	}
	GetBlobStub        func(context.Context, hash.Hash) (*nanogit.Blob, error)
	getBlobMutex       sync.RWMutex
	getBlobArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
	}
	getBlobReturns struct {
		result1 *nanogit.Blob
		result2 error
	}
	getBlobReturnsOnCall map[int]struct {
		result1 *nanogit.Blob
		result2 error
	}
	GetBlobByPathStub        func(context.Context, hash.Hash, string) (*nanogit.Blob, error)
	getBlobByPathMutex       sync.RWMutex
	getBlobByPathArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 string
	}
	getBlobByPathReturns struct {
		result1 *nanogit.Blob
		result2 error
	}
	getBlobByPathReturnsOnCall map[int]struct {
		result1 *nanogit.Blob
		result2 error
	}
	GetCommitStub        func(context.Context, hash.Hash) (*nanogit.Commit, error)
	getCommitMutex       sync.RWMutex
	getCommitArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
	}
	getCommitReturns struct {
		result1 *nanogit.Commit
		result2 error
	}
	getCommitReturnsOnCall map[int]struct {
		result1 *nanogit.Commit
		result2 error
	}
	GetFlatTreeStub        func(context.Context, hash.Hash) (*nanogit.FlatTree, error)
	getFlatTreeMutex       sync.RWMutex
	getFlatTreeArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
	}
	getFlatTreeReturns struct {
		result1 *nanogit.FlatTree
		result2 error
	}
	getFlatTreeReturnsOnCall map[int]struct {
		result1 *nanogit.FlatTree
		result2 error
	}
	GetRefStub        func(context.Context, string) (nanogit.Ref, error)
	getRefMutex       sync.RWMutex
	getRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getRefReturns struct {
		result1 nanogit.Ref
		result2 error
	}
	getRefReturnsOnCall map[int]struct {
		result1 nanogit.Ref
		result2 error
	}
	GetTreeStub        func(context.Context, hash.Hash) (*nanogit.Tree, error)
	getTreeMutex       sync.RWMutex
	getTreeArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
	}
	getTreeReturns struct {
		result1 *nanogit.Tree
		result2 error
	}
	getTreeReturnsOnCall map[int]struct {
		result1 *nanogit.Tree
		result2 error
	}
	GetTreeByPathStub        func(context.Context, hash.Hash, string) (*nanogit.Tree, error)
	getTreeByPathMutex       sync.RWMutex
	getTreeByPathArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 string
	}
	getTreeByPathReturns struct {
		result1 *nanogit.Tree
		result2 error
	}
	getTreeByPathReturnsOnCall map[int]struct {
		result1 *nanogit.Tree
		result2 error
	}
	IsAuthorizedStub        func(context.Context) (bool, error)
	isAuthorizedMutex       sync.RWMutex
	isAuthorizedArgsForCall []struct {
		arg1 context.Context
	}
	isAuthorizedReturns struct {
		result1 bool
		result2 error
	}
	isAuthorizedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListCommitsStub        func(context.Context, hash.Hash, nanogit.ListCommitsOptions) ([]nanogit.Commit, error)
	listCommitsMutex       sync.RWMutex
	listCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 nanogit.ListCommitsOptions
	}
	listCommitsReturns struct {
		result1 []nanogit.Commit
		result2 error
	}
	listCommitsReturnsOnCall map[int]struct {
		result1 []nanogit.Commit
		result2 error
	}
	ListRefsStub        func(context.Context) ([]nanogit.Ref, error)
	listRefsMutex       sync.RWMutex
	listRefsArgsForCall []struct {
		arg1 context.Context
	}
	listRefsReturns struct {
		result1 []nanogit.Ref
		result2 error
	}
	listRefsReturnsOnCall map[int]struct {
		result1 []nanogit.Ref
		result2 error
	}
	NewStagedWriterStub        func(context.Context, nanogit.Ref, ...nanogit.WriterOption) (nanogit.StagedWriter, error)
	newStagedWriterMutex       sync.RWMutex
	newStagedWriterArgsForCall []struct {
		arg1 context.Context
		arg2 nanogit.Ref
		arg3 []nanogit.WriterOption
	}
	newStagedWriterReturns struct {
		result1 nanogit.StagedWriter
		result2 error
	}
	newStagedWriterReturnsOnCall map[int]struct {
		result1 nanogit.StagedWriter
		result2 error
	}
	RepoExistsStub        func(context.Context) (bool, error)
	repoExistsMutex       sync.RWMutex
	repoExistsArgsForCall []struct {
		arg1 context.Context
	}
	repoExistsReturns struct {
		result1 bool
		result2 error
	}
	repoExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateRefStub        func(context.Context, nanogit.Ref) error
	updateRefMutex       sync.RWMutex
	updateRefArgsForCall []struct {
		arg1 context.Context
		arg2 nanogit.Ref
	}
	updateRefReturns struct {
		result1 error
	}
	updateRefReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Clone(arg1 context.Context, arg2 nanogit.CloneOptions) (*nanogit.CloneResult, error) {
	fake.cloneMutex.Lock()
	ret, specificReturn := fake.cloneReturnsOnCall[len(fake.cloneArgsForCall)]
	fake.cloneArgsForCall = append(fake.cloneArgsForCall, struct {
		arg1 context.Context
		arg2 nanogit.CloneOptions
	}{arg1, arg2})
	stub := fake.CloneStub
	fakeReturns := fake.cloneReturns
	fake.recordInvocation("Clone", []interface{}{arg1, arg2})
	fake.cloneMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CloneCallCount() int {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	return len(fake.cloneArgsForCall)
}

func (fake *FakeClient) CloneCalls(stub func(context.Context, nanogit.CloneOptions) (*nanogit.CloneResult, error)) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = stub
}

func (fake *FakeClient) CloneArgsForCall(i int) (context.Context, nanogit.CloneOptions) {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	argsForCall := fake.cloneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CloneReturns(result1 *nanogit.CloneResult, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	fake.cloneReturns = struct {
		result1 *nanogit.CloneResult
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CloneReturnsOnCall(i int, result1 *nanogit.CloneResult, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	if fake.cloneReturnsOnCall == nil {
		fake.cloneReturnsOnCall = make(map[int]struct {
			result1 *nanogit.CloneResult
			result2 error
		})
	}
	fake.cloneReturnsOnCall[i] = struct {
		result1 *nanogit.CloneResult
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CompareCommits(arg1 context.Context, arg2 hash.Hash, arg3 hash.Hash) ([]nanogit.CommitFile, error) {
	fake.compareCommitsMutex.Lock()
	ret, specificReturn := fake.compareCommitsReturnsOnCall[len(fake.compareCommitsArgsForCall)]
	fake.compareCommitsArgsForCall = append(fake.compareCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 hash.Hash
	}{arg1, arg2, arg3})
	stub := fake.CompareCommitsStub
	fakeReturns := fake.compareCommitsReturns
	fake.recordInvocation("CompareCommits", []interface{}{arg1, arg2, arg3})
	fake.compareCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CompareCommitsCallCount() int {
	fake.compareCommitsMutex.RLock()
	defer fake.compareCommitsMutex.RUnlock()
	return len(fake.compareCommitsArgsForCall)
}

func (fake *FakeClient) CompareCommitsCalls(stub func(context.Context, hash.Hash, hash.Hash) ([]nanogit.CommitFile, error)) {
	fake.compareCommitsMutex.Lock()
	defer fake.compareCommitsMutex.Unlock()
	fake.CompareCommitsStub = stub
}

func (fake *FakeClient) CompareCommitsArgsForCall(i int) (context.Context, hash.Hash, hash.Hash) {
	fake.compareCommitsMutex.RLock()
	defer fake.compareCommitsMutex.RUnlock()
	argsForCall := fake.compareCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CompareCommitsReturns(result1 []nanogit.CommitFile, result2 error) {
	fake.compareCommitsMutex.Lock()
	defer fake.compareCommitsMutex.Unlock()
	fake.CompareCommitsStub = nil
	fake.compareCommitsReturns = struct {
		result1 []nanogit.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CompareCommitsReturnsOnCall(i int, result1 []nanogit.CommitFile, result2 error) {
	fake.compareCommitsMutex.Lock()
	defer fake.compareCommitsMutex.Unlock()
	fake.CompareCommitsStub = nil
	if fake.compareCommitsReturnsOnCall == nil {
		fake.compareCommitsReturnsOnCall = make(map[int]struct {
			result1 []nanogit.CommitFile
			result2 error
		})
	}
	fake.compareCommitsReturnsOnCall[i] = struct {
		result1 []nanogit.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateRef(arg1 context.Context, arg2 nanogit.Ref) error {
	fake.createRefMutex.Lock()
	ret, specificReturn := fake.createRefReturnsOnCall[len(fake.createRefArgsForCall)]
	fake.createRefArgsForCall = append(fake.createRefArgsForCall, struct {
		arg1 context.Context
		arg2 nanogit.Ref
	}{arg1, arg2})
	stub := fake.CreateRefStub
	fakeReturns := fake.createRefReturns
	fake.recordInvocation("CreateRef", []interface{}{arg1, arg2})
	fake.createRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CreateRefCallCount() int {
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	return len(fake.createRefArgsForCall)
}

func (fake *FakeClient) CreateRefCalls(stub func(context.Context, nanogit.Ref) error) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = stub
}

func (fake *FakeClient) CreateRefArgsForCall(i int) (context.Context, nanogit.Ref) {
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	argsForCall := fake.createRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CreateRefReturns(result1 error) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = nil
	fake.createRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateRefReturnsOnCall(i int, result1 error) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = nil
	if fake.createRefReturnsOnCall == nil {
		fake.createRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRef(arg1 context.Context, arg2 string) error {
	fake.deleteRefMutex.Lock()
	ret, specificReturn := fake.deleteRefReturnsOnCall[len(fake.deleteRefArgsForCall)]
	fake.deleteRefArgsForCall = append(fake.deleteRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteRefStub
	fakeReturns := fake.deleteRefReturns
	fake.recordInvocation("DeleteRef", []interface{}{arg1, arg2})
	fake.deleteRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteRefCallCount() int {
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	return len(fake.deleteRefArgsForCall)
}

func (fake *FakeClient) DeleteRefCalls(stub func(context.Context, string) error) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = stub
}

func (fake *FakeClient) DeleteRefArgsForCall(i int) (context.Context, string) {
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	argsForCall := fake.deleteRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeleteRefReturns(result1 error) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = nil
	fake.deleteRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRefReturnsOnCall(i int, result1 error) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = nil
	if fake.deleteRefReturnsOnCall == nil {
		fake.deleteRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetBlob(arg1 context.Context, arg2 hash.Hash) (*nanogit.Blob, error) {
	fake.getBlobMutex.Lock()
	ret, specificReturn := fake.getBlobReturnsOnCall[len(fake.getBlobArgsForCall)]
	fake.getBlobArgsForCall = append(fake.getBlobArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
	}{arg1, arg2})
	stub := fake.GetBlobStub
	fakeReturns := fake.getBlobReturns
	fake.recordInvocation("GetBlob", []interface{}{arg1, arg2})
	fake.getBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetBlobCallCount() int {
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	return len(fake.getBlobArgsForCall)
}

func (fake *FakeClient) GetBlobCalls(stub func(context.Context, hash.Hash) (*nanogit.Blob, error)) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = stub
}

func (fake *FakeClient) GetBlobArgsForCall(i int) (context.Context, hash.Hash) {
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	argsForCall := fake.getBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetBlobReturns(result1 *nanogit.Blob, result2 error) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = nil
	fake.getBlobReturns = struct {
		result1 *nanogit.Blob
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlobReturnsOnCall(i int, result1 *nanogit.Blob, result2 error) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = nil
	if fake.getBlobReturnsOnCall == nil {
		fake.getBlobReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Blob
			result2 error
		})
	}
	fake.getBlobReturnsOnCall[i] = struct {
		result1 *nanogit.Blob
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlobByPath(arg1 context.Context, arg2 hash.Hash, arg3 string) (*nanogit.Blob, error) {
	fake.getBlobByPathMutex.Lock()
	ret, specificReturn := fake.getBlobByPathReturnsOnCall[len(fake.getBlobByPathArgsForCall)]
	fake.getBlobByPathArgsForCall = append(fake.getBlobByPathArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetBlobByPathStub
	fakeReturns := fake.getBlobByPathReturns
	fake.recordInvocation("GetBlobByPath", []interface{}{arg1, arg2, arg3})
	fake.getBlobByPathMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetBlobByPathCallCount() int {
	fake.getBlobByPathMutex.RLock()
	defer fake.getBlobByPathMutex.RUnlock()
	return len(fake.getBlobByPathArgsForCall)
}

func (fake *FakeClient) GetBlobByPathCalls(stub func(context.Context, hash.Hash, string) (*nanogit.Blob, error)) {
	fake.getBlobByPathMutex.Lock()
	defer fake.getBlobByPathMutex.Unlock()
	fake.GetBlobByPathStub = stub
}

func (fake *FakeClient) GetBlobByPathArgsForCall(i int) (context.Context, hash.Hash, string) {
	fake.getBlobByPathMutex.RLock()
	defer fake.getBlobByPathMutex.RUnlock()
	argsForCall := fake.getBlobByPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetBlobByPathReturns(result1 *nanogit.Blob, result2 error) {
	fake.getBlobByPathMutex.Lock()
	defer fake.getBlobByPathMutex.Unlock()
	fake.GetBlobByPathStub = nil
	fake.getBlobByPathReturns = struct {
		result1 *nanogit.Blob
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlobByPathReturnsOnCall(i int, result1 *nanogit.Blob, result2 error) {
	fake.getBlobByPathMutex.Lock()
	defer fake.getBlobByPathMutex.Unlock()
	fake.GetBlobByPathStub = nil
	if fake.getBlobByPathReturnsOnCall == nil {
		fake.getBlobByPathReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Blob
			result2 error
		})
	}
	fake.getBlobByPathReturnsOnCall[i] = struct {
		result1 *nanogit.Blob
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetCommit(arg1 context.Context, arg2 hash.Hash) (*nanogit.Commit, error) {
	fake.getCommitMutex.Lock()
	ret, specificReturn := fake.getCommitReturnsOnCall[len(fake.getCommitArgsForCall)]
	fake.getCommitArgsForCall = append(fake.getCommitArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
	}{arg1, arg2})
	stub := fake.GetCommitStub
	fakeReturns := fake.getCommitReturns
	fake.recordInvocation("GetCommit", []interface{}{arg1, arg2})
	fake.getCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetCommitCallCount() int {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	return len(fake.getCommitArgsForCall)
}

func (fake *FakeClient) GetCommitCalls(stub func(context.Context, hash.Hash) (*nanogit.Commit, error)) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = stub
}

func (fake *FakeClient) GetCommitArgsForCall(i int) (context.Context, hash.Hash) {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	argsForCall := fake.getCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetCommitReturns(result1 *nanogit.Commit, result2 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	fake.getCommitReturns = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetCommitReturnsOnCall(i int, result1 *nanogit.Commit, result2 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	if fake.getCommitReturnsOnCall == nil {
		fake.getCommitReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Commit
			result2 error
		})
	}
	fake.getCommitReturnsOnCall[i] = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetFlatTree(arg1 context.Context, arg2 hash.Hash) (*nanogit.FlatTree, error) {
	fake.getFlatTreeMutex.Lock()
	ret, specificReturn := fake.getFlatTreeReturnsOnCall[len(fake.getFlatTreeArgsForCall)]
	fake.getFlatTreeArgsForCall = append(fake.getFlatTreeArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
	}{arg1, arg2})
	stub := fake.GetFlatTreeStub
	fakeReturns := fake.getFlatTreeReturns
	fake.recordInvocation("GetFlatTree", []interface{}{arg1, arg2})
	fake.getFlatTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetFlatTreeCallCount() int {
	fake.getFlatTreeMutex.RLock()
	defer fake.getFlatTreeMutex.RUnlock()
	return len(fake.getFlatTreeArgsForCall)
}

func (fake *FakeClient) GetFlatTreeCalls(stub func(context.Context, hash.Hash) (*nanogit.FlatTree, error)) {
	fake.getFlatTreeMutex.Lock()
	defer fake.getFlatTreeMutex.Unlock()
	fake.GetFlatTreeStub = stub
}

func (fake *FakeClient) GetFlatTreeArgsForCall(i int) (context.Context, hash.Hash) {
	fake.getFlatTreeMutex.RLock()
	defer fake.getFlatTreeMutex.RUnlock()
	argsForCall := fake.getFlatTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetFlatTreeReturns(result1 *nanogit.FlatTree, result2 error) {
	fake.getFlatTreeMutex.Lock()
	defer fake.getFlatTreeMutex.Unlock()
	fake.GetFlatTreeStub = nil
	fake.getFlatTreeReturns = struct {
		result1 *nanogit.FlatTree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetFlatTreeReturnsOnCall(i int, result1 *nanogit.FlatTree, result2 error) {
	fake.getFlatTreeMutex.Lock()
	defer fake.getFlatTreeMutex.Unlock()
	fake.GetFlatTreeStub = nil
	if fake.getFlatTreeReturnsOnCall == nil {
		fake.getFlatTreeReturnsOnCall = make(map[int]struct {
			result1 *nanogit.FlatTree
			result2 error
		})
	}
	fake.getFlatTreeReturnsOnCall[i] = struct {
		result1 *nanogit.FlatTree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetRef(arg1 context.Context, arg2 string) (nanogit.Ref, error) {
	fake.getRefMutex.Lock()
	ret, specificReturn := fake.getRefReturnsOnCall[len(fake.getRefArgsForCall)]
	fake.getRefArgsForCall = append(fake.getRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRefStub
	fakeReturns := fake.getRefReturns
	fake.recordInvocation("GetRef", []interface{}{arg1, arg2})
	fake.getRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetRefCallCount() int {
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	return len(fake.getRefArgsForCall)
}

func (fake *FakeClient) GetRefCalls(stub func(context.Context, string) (nanogit.Ref, error)) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = stub
}

func (fake *FakeClient) GetRefArgsForCall(i int) (context.Context, string) {
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	argsForCall := fake.getRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetRefReturns(result1 nanogit.Ref, result2 error) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = nil
	fake.getRefReturns = struct {
		result1 nanogit.Ref
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetRefReturnsOnCall(i int, result1 nanogit.Ref, result2 error) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = nil
	if fake.getRefReturnsOnCall == nil {
		fake.getRefReturnsOnCall = make(map[int]struct {
			result1 nanogit.Ref
			result2 error
		})
	}
	fake.getRefReturnsOnCall[i] = struct {
		result1 nanogit.Ref
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetTree(arg1 context.Context, arg2 hash.Hash) (*nanogit.Tree, error) {
	fake.getTreeMutex.Lock()
	ret, specificReturn := fake.getTreeReturnsOnCall[len(fake.getTreeArgsForCall)]
	fake.getTreeArgsForCall = append(fake.getTreeArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
	}{arg1, arg2})
	stub := fake.GetTreeStub
	fakeReturns := fake.getTreeReturns
	fake.recordInvocation("GetTree", []interface{}{arg1, arg2})
	fake.getTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetTreeCallCount() int {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	return len(fake.getTreeArgsForCall)
}

func (fake *FakeClient) GetTreeCalls(stub func(context.Context, hash.Hash) (*nanogit.Tree, error)) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = stub
}

func (fake *FakeClient) GetTreeArgsForCall(i int) (context.Context, hash.Hash) {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	argsForCall := fake.getTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetTreeReturns(result1 *nanogit.Tree, result2 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	fake.getTreeReturns = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetTreeReturnsOnCall(i int, result1 *nanogit.Tree, result2 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	if fake.getTreeReturnsOnCall == nil {
		fake.getTreeReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Tree
			result2 error
		})
	}
	fake.getTreeReturnsOnCall[i] = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetTreeByPath(arg1 context.Context, arg2 hash.Hash, arg3 string) (*nanogit.Tree, error) {
	fake.getTreeByPathMutex.Lock()
	ret, specificReturn := fake.getTreeByPathReturnsOnCall[len(fake.getTreeByPathArgsForCall)]
	fake.getTreeByPathArgsForCall = append(fake.getTreeByPathArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetTreeByPathStub
	fakeReturns := fake.getTreeByPathReturns
	fake.recordInvocation("GetTreeByPath", []interface{}{arg1, arg2, arg3})
	fake.getTreeByPathMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetTreeByPathCallCount() int {
	fake.getTreeByPathMutex.RLock()
	defer fake.getTreeByPathMutex.RUnlock()
	return len(fake.getTreeByPathArgsForCall)
}

func (fake *FakeClient) GetTreeByPathCalls(stub func(context.Context, hash.Hash, string) (*nanogit.Tree, error)) {
	fake.getTreeByPathMutex.Lock()
	defer fake.getTreeByPathMutex.Unlock()
	fake.GetTreeByPathStub = stub
}

func (fake *FakeClient) GetTreeByPathArgsForCall(i int) (context.Context, hash.Hash, string) {
	fake.getTreeByPathMutex.RLock()
	defer fake.getTreeByPathMutex.RUnlock()
	argsForCall := fake.getTreeByPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetTreeByPathReturns(result1 *nanogit.Tree, result2 error) {
	fake.getTreeByPathMutex.Lock()
	defer fake.getTreeByPathMutex.Unlock()
	fake.GetTreeByPathStub = nil
	fake.getTreeByPathReturns = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetTreeByPathReturnsOnCall(i int, result1 *nanogit.Tree, result2 error) {
	fake.getTreeByPathMutex.Lock()
	defer fake.getTreeByPathMutex.Unlock()
	fake.GetTreeByPathStub = nil
	if fake.getTreeByPathReturnsOnCall == nil {
		fake.getTreeByPathReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Tree
			result2 error
		})
	}
	fake.getTreeByPathReturnsOnCall[i] = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) IsAuthorized(arg1 context.Context) (bool, error) {
	fake.isAuthorizedMutex.Lock()
	ret, specificReturn := fake.isAuthorizedReturnsOnCall[len(fake.isAuthorizedArgsForCall)]
	fake.isAuthorizedArgsForCall = append(fake.isAuthorizedArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.IsAuthorizedStub
	fakeReturns := fake.isAuthorizedReturns
	fake.recordInvocation("IsAuthorized", []interface{}{arg1})
	fake.isAuthorizedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) IsAuthorizedCallCount() int {
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	return len(fake.isAuthorizedArgsForCall)
}

func (fake *FakeClient) IsAuthorizedCalls(stub func(context.Context) (bool, error)) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = stub
}

func (fake *FakeClient) IsAuthorizedArgsForCall(i int) context.Context {
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	argsForCall := fake.isAuthorizedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) IsAuthorizedReturns(result1 bool, result2 error) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = nil
	fake.isAuthorizedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) IsAuthorizedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = nil
	if fake.isAuthorizedReturnsOnCall == nil {
		fake.isAuthorizedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAuthorizedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListCommits(arg1 context.Context, arg2 hash.Hash, arg3 nanogit.ListCommitsOptions) ([]nanogit.Commit, error) {
	fake.listCommitsMutex.Lock()
	ret, specificReturn := fake.listCommitsReturnsOnCall[len(fake.listCommitsArgsForCall)]
	fake.listCommitsArgsForCall = append(fake.listCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 hash.Hash
		arg3 nanogit.ListCommitsOptions
	}{arg1, arg2, arg3})
	stub := fake.ListCommitsStub
	fakeReturns := fake.listCommitsReturns
	fake.recordInvocation("ListCommits", []interface{}{arg1, arg2, arg3})
	fake.listCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListCommitsCallCount() int {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	return len(fake.listCommitsArgsForCall)
}

func (fake *FakeClient) ListCommitsCalls(stub func(context.Context, hash.Hash, nanogit.ListCommitsOptions) ([]nanogit.Commit, error)) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = stub
}

func (fake *FakeClient) ListCommitsArgsForCall(i int) (context.Context, hash.Hash, nanogit.ListCommitsOptions) {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	argsForCall := fake.listCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ListCommitsReturns(result1 []nanogit.Commit, result2 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	fake.listCommitsReturns = struct {
		result1 []nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListCommitsReturnsOnCall(i int, result1 []nanogit.Commit, result2 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	if fake.listCommitsReturnsOnCall == nil {
		fake.listCommitsReturnsOnCall = make(map[int]struct {
			result1 []nanogit.Commit
			result2 error
		})
	}
	fake.listCommitsReturnsOnCall[i] = struct {
		result1 []nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListRefs(arg1 context.Context) ([]nanogit.Ref, error) {
	fake.listRefsMutex.Lock()
	ret, specificReturn := fake.listRefsReturnsOnCall[len(fake.listRefsArgsForCall)]
	fake.listRefsArgsForCall = append(fake.listRefsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListRefsStub
	fakeReturns := fake.listRefsReturns
	fake.recordInvocation("ListRefs", []interface{}{arg1})
	fake.listRefsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListRefsCallCount() int {
	fake.listRefsMutex.RLock()
	defer fake.listRefsMutex.RUnlock()
	return len(fake.listRefsArgsForCall)
}

func (fake *FakeClient) ListRefsCalls(stub func(context.Context) ([]nanogit.Ref, error)) {
	fake.listRefsMutex.Lock()
	defer fake.listRefsMutex.Unlock()
	fake.ListRefsStub = stub
}

func (fake *FakeClient) ListRefsArgsForCall(i int) context.Context {
	fake.listRefsMutex.RLock()
	defer fake.listRefsMutex.RUnlock()
	argsForCall := fake.listRefsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListRefsReturns(result1 []nanogit.Ref, result2 error) {
	fake.listRefsMutex.Lock()
	defer fake.listRefsMutex.Unlock()
	fake.ListRefsStub = nil
	fake.listRefsReturns = struct {
		result1 []nanogit.Ref
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListRefsReturnsOnCall(i int, result1 []nanogit.Ref, result2 error) {
	fake.listRefsMutex.Lock()
	defer fake.listRefsMutex.Unlock()
	fake.ListRefsStub = nil
	if fake.listRefsReturnsOnCall == nil {
		fake.listRefsReturnsOnCall = make(map[int]struct {
			result1 []nanogit.Ref
			result2 error
		})
	}
	fake.listRefsReturnsOnCall[i] = struct {
		result1 []nanogit.Ref
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewStagedWriter(arg1 context.Context, arg2 nanogit.Ref, arg3 ...nanogit.WriterOption) (nanogit.StagedWriter, error) {
	fake.newStagedWriterMutex.Lock()
	ret, specificReturn := fake.newStagedWriterReturnsOnCall[len(fake.newStagedWriterArgsForCall)]
	fake.newStagedWriterArgsForCall = append(fake.newStagedWriterArgsForCall, struct {
		arg1 context.Context
		arg2 nanogit.Ref
		arg3 []nanogit.WriterOption
	}{arg1, arg2, arg3})
	stub := fake.NewStagedWriterStub
	fakeReturns := fake.newStagedWriterReturns
	fake.recordInvocation("NewStagedWriter", []interface{}{arg1, arg2, arg3})
	fake.newStagedWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) NewStagedWriterCallCount() int {
	fake.newStagedWriterMutex.RLock()
	defer fake.newStagedWriterMutex.RUnlock()
	return len(fake.newStagedWriterArgsForCall)
}

func (fake *FakeClient) NewStagedWriterCalls(stub func(context.Context, nanogit.Ref, ...nanogit.WriterOption) (nanogit.StagedWriter, error)) {
	fake.newStagedWriterMutex.Lock()
	defer fake.newStagedWriterMutex.Unlock()
	fake.NewStagedWriterStub = stub
}

func (fake *FakeClient) NewStagedWriterArgsForCall(i int) (context.Context, nanogit.Ref, []nanogit.WriterOption) {
	fake.newStagedWriterMutex.RLock()
	defer fake.newStagedWriterMutex.RUnlock()
	argsForCall := fake.newStagedWriterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) NewStagedWriterReturns(result1 nanogit.StagedWriter, result2 error) {
	fake.newStagedWriterMutex.Lock()
	defer fake.newStagedWriterMutex.Unlock()
	fake.NewStagedWriterStub = nil
	fake.newStagedWriterReturns = struct {
		result1 nanogit.StagedWriter
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewStagedWriterReturnsOnCall(i int, result1 nanogit.StagedWriter, result2 error) {
	fake.newStagedWriterMutex.Lock()
	defer fake.newStagedWriterMutex.Unlock()
	fake.NewStagedWriterStub = nil
	if fake.newStagedWriterReturnsOnCall == nil {
		fake.newStagedWriterReturnsOnCall = make(map[int]struct {
			result1 nanogit.StagedWriter
			result2 error
		})
	}
	fake.newStagedWriterReturnsOnCall[i] = struct {
		result1 nanogit.StagedWriter
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RepoExists(arg1 context.Context) (bool, error) {
	fake.repoExistsMutex.Lock()
	ret, specificReturn := fake.repoExistsReturnsOnCall[len(fake.repoExistsArgsForCall)]
	fake.repoExistsArgsForCall = append(fake.repoExistsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.RepoExistsStub
	fakeReturns := fake.repoExistsReturns
	fake.recordInvocation("RepoExists", []interface{}{arg1})
	fake.repoExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RepoExistsCallCount() int {
	fake.repoExistsMutex.RLock()
	defer fake.repoExistsMutex.RUnlock()
	return len(fake.repoExistsArgsForCall)
}

func (fake *FakeClient) RepoExistsCalls(stub func(context.Context) (bool, error)) {
	fake.repoExistsMutex.Lock()
	defer fake.repoExistsMutex.Unlock()
	fake.RepoExistsStub = stub
}

func (fake *FakeClient) RepoExistsArgsForCall(i int) context.Context {
	fake.repoExistsMutex.RLock()
	defer fake.repoExistsMutex.RUnlock()
	argsForCall := fake.repoExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) RepoExistsReturns(result1 bool, result2 error) {
	fake.repoExistsMutex.Lock()
	defer fake.repoExistsMutex.Unlock()
	fake.RepoExistsStub = nil
	fake.repoExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RepoExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.repoExistsMutex.Lock()
	defer fake.repoExistsMutex.Unlock()
	fake.RepoExistsStub = nil
	if fake.repoExistsReturnsOnCall == nil {
		fake.repoExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.repoExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateRef(arg1 context.Context, arg2 nanogit.Ref) error {
	fake.updateRefMutex.Lock()
	ret, specificReturn := fake.updateRefReturnsOnCall[len(fake.updateRefArgsForCall)]
	fake.updateRefArgsForCall = append(fake.updateRefArgsForCall, struct {
		arg1 context.Context
		arg2 nanogit.Ref
	}{arg1, arg2})
	stub := fake.UpdateRefStub
	fakeReturns := fake.updateRefReturns
	fake.recordInvocation("UpdateRef", []interface{}{arg1, arg2})
	fake.updateRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) UpdateRefCallCount() int {
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	return len(fake.updateRefArgsForCall)
}

func (fake *FakeClient) UpdateRefCalls(stub func(context.Context, nanogit.Ref) error) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = stub
}

func (fake *FakeClient) UpdateRefArgsForCall(i int) (context.Context, nanogit.Ref) {
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	argsForCall := fake.updateRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateRefReturns(result1 error) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = nil
	fake.updateRefReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateRefReturnsOnCall(i int, result1 error) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = nil
	if fake.updateRefReturnsOnCall == nil {
		fake.updateRefReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRefReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	fake.compareCommitsMutex.RLock()
	defer fake.compareCommitsMutex.RUnlock()
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	fake.getBlobByPathMutex.RLock()
	defer fake.getBlobByPathMutex.RUnlock()
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	fake.getFlatTreeMutex.RLock()
	defer fake.getFlatTreeMutex.RUnlock()
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	fake.getTreeByPathMutex.RLock()
	defer fake.getTreeByPathMutex.RUnlock()
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	fake.listRefsMutex.RLock()
	defer fake.listRefsMutex.RUnlock()
	fake.newStagedWriterMutex.RLock()
	defer fake.newStagedWriterMutex.RUnlock()
	fake.repoExistsMutex.RLock()
	defer fake.repoExistsMutex.RUnlock()
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nanogit.Client = new(FakeClient)
