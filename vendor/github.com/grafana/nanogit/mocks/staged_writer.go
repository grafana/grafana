// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/grafana/nanogit"
	"github.com/grafana/nanogit/protocol/hash"
)

type FakeStagedWriter struct {
	BlobExistsStub        func(context.Context, string) (bool, error)
	blobExistsMutex       sync.RWMutex
	blobExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	blobExistsReturns struct {
		result1 bool
		result2 error
	}
	blobExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CleanupStub        func(context.Context) error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
		arg1 context.Context
	}
	cleanupReturns struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	CommitStub        func(context.Context, string, nanogit.Author, nanogit.Committer) (*nanogit.Commit, error)
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 nanogit.Author
		arg4 nanogit.Committer
	}
	commitReturns struct {
		result1 *nanogit.Commit
		result2 error
	}
	commitReturnsOnCall map[int]struct {
		result1 *nanogit.Commit
		result2 error
	}
	CreateBlobStub        func(context.Context, string, []byte) (hash.Hash, error)
	createBlobMutex       sync.RWMutex
	createBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}
	createBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	createBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	DeleteBlobStub        func(context.Context, string) (hash.Hash, error)
	deleteBlobMutex       sync.RWMutex
	deleteBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	deleteBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	DeleteTreeStub        func(context.Context, string) (hash.Hash, error)
	deleteTreeMutex       sync.RWMutex
	deleteTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteTreeReturns struct {
		result1 hash.Hash
		result2 error
	}
	deleteTreeReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	GetTreeStub        func(context.Context, string) (*nanogit.Tree, error)
	getTreeMutex       sync.RWMutex
	getTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getTreeReturns struct {
		result1 *nanogit.Tree
		result2 error
	}
	getTreeReturnsOnCall map[int]struct {
		result1 *nanogit.Tree
		result2 error
	}
	MoveBlobStub        func(context.Context, string, string) (hash.Hash, error)
	moveBlobMutex       sync.RWMutex
	moveBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	moveBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	moveBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	MoveTreeStub        func(context.Context, string, string) (hash.Hash, error)
	moveTreeMutex       sync.RWMutex
	moveTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	moveTreeReturns struct {
		result1 hash.Hash
		result2 error
	}
	moveTreeReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	PushStub        func(context.Context) error
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 context.Context
	}
	pushReturns struct {
		result1 error
	}
	pushReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateBlobStub        func(context.Context, string, []byte) (hash.Hash, error)
	updateBlobMutex       sync.RWMutex
	updateBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}
	updateBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	updateBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStagedWriter) BlobExists(arg1 context.Context, arg2 string) (bool, error) {
	fake.blobExistsMutex.Lock()
	ret, specificReturn := fake.blobExistsReturnsOnCall[len(fake.blobExistsArgsForCall)]
	fake.blobExistsArgsForCall = append(fake.blobExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BlobExistsStub
	fakeReturns := fake.blobExistsReturns
	fake.recordInvocation("BlobExists", []interface{}{arg1, arg2})
	fake.blobExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) BlobExistsCallCount() int {
	fake.blobExistsMutex.RLock()
	defer fake.blobExistsMutex.RUnlock()
	return len(fake.blobExistsArgsForCall)
}

func (fake *FakeStagedWriter) BlobExistsCalls(stub func(context.Context, string) (bool, error)) {
	fake.blobExistsMutex.Lock()
	defer fake.blobExistsMutex.Unlock()
	fake.BlobExistsStub = stub
}

func (fake *FakeStagedWriter) BlobExistsArgsForCall(i int) (context.Context, string) {
	fake.blobExistsMutex.RLock()
	defer fake.blobExistsMutex.RUnlock()
	argsForCall := fake.blobExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) BlobExistsReturns(result1 bool, result2 error) {
	fake.blobExistsMutex.Lock()
	defer fake.blobExistsMutex.Unlock()
	fake.BlobExistsStub = nil
	fake.blobExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) BlobExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.blobExistsMutex.Lock()
	defer fake.blobExistsMutex.Unlock()
	fake.BlobExistsStub = nil
	if fake.blobExistsReturnsOnCall == nil {
		fake.blobExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.blobExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) Cleanup(arg1 context.Context) error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CleanupStub
	fakeReturns := fake.cleanupReturns
	fake.recordInvocation("Cleanup", []interface{}{arg1})
	fake.cleanupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStagedWriter) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeStagedWriter) CleanupCalls(stub func(context.Context) error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = stub
}

func (fake *FakeStagedWriter) CleanupArgsForCall(i int) context.Context {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	argsForCall := fake.cleanupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStagedWriter) CleanupReturns(result1 error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) CleanupReturnsOnCall(i int, result1 error) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) Commit(arg1 context.Context, arg2 string, arg3 nanogit.Author, arg4 nanogit.Committer) (*nanogit.Commit, error) {
	fake.commitMutex.Lock()
	ret, specificReturn := fake.commitReturnsOnCall[len(fake.commitArgsForCall)]
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 nanogit.Author
		arg4 nanogit.Committer
	}{arg1, arg2, arg3, arg4})
	stub := fake.CommitStub
	fakeReturns := fake.commitReturns
	fake.recordInvocation("Commit", []interface{}{arg1, arg2, arg3, arg4})
	fake.commitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeStagedWriter) CommitCalls(stub func(context.Context, string, nanogit.Author, nanogit.Committer) (*nanogit.Commit, error)) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *FakeStagedWriter) CommitArgsForCall(i int) (context.Context, string, nanogit.Author, nanogit.Committer) {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	argsForCall := fake.commitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStagedWriter) CommitReturns(result1 *nanogit.Commit, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CommitReturnsOnCall(i int, result1 *nanogit.Commit, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	if fake.commitReturnsOnCall == nil {
		fake.commitReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Commit
			result2 error
		})
	}
	fake.commitReturnsOnCall[i] = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CreateBlob(arg1 context.Context, arg2 string, arg3 []byte) (hash.Hash, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createBlobMutex.Lock()
	ret, specificReturn := fake.createBlobReturnsOnCall[len(fake.createBlobArgsForCall)]
	fake.createBlobArgsForCall = append(fake.createBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.CreateBlobStub
	fakeReturns := fake.createBlobReturns
	fake.recordInvocation("CreateBlob", []interface{}{arg1, arg2, arg3Copy})
	fake.createBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) CreateBlobCallCount() int {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	return len(fake.createBlobArgsForCall)
}

func (fake *FakeStagedWriter) CreateBlobCalls(stub func(context.Context, string, []byte) (hash.Hash, error)) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = stub
}

func (fake *FakeStagedWriter) CreateBlobArgsForCall(i int) (context.Context, string, []byte) {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	argsForCall := fake.createBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) CreateBlobReturns(result1 hash.Hash, result2 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	fake.createBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CreateBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	if fake.createBlobReturnsOnCall == nil {
		fake.createBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.createBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteBlob(arg1 context.Context, arg2 string) (hash.Hash, error) {
	fake.deleteBlobMutex.Lock()
	ret, specificReturn := fake.deleteBlobReturnsOnCall[len(fake.deleteBlobArgsForCall)]
	fake.deleteBlobArgsForCall = append(fake.deleteBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteBlobStub
	fakeReturns := fake.deleteBlobReturns
	fake.recordInvocation("DeleteBlob", []interface{}{arg1, arg2})
	fake.deleteBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) DeleteBlobCallCount() int {
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	return len(fake.deleteBlobArgsForCall)
}

func (fake *FakeStagedWriter) DeleteBlobCalls(stub func(context.Context, string) (hash.Hash, error)) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = stub
}

func (fake *FakeStagedWriter) DeleteBlobArgsForCall(i int) (context.Context, string) {
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	argsForCall := fake.deleteBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) DeleteBlobReturns(result1 hash.Hash, result2 error) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = nil
	fake.deleteBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = nil
	if fake.deleteBlobReturnsOnCall == nil {
		fake.deleteBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.deleteBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteTree(arg1 context.Context, arg2 string) (hash.Hash, error) {
	fake.deleteTreeMutex.Lock()
	ret, specificReturn := fake.deleteTreeReturnsOnCall[len(fake.deleteTreeArgsForCall)]
	fake.deleteTreeArgsForCall = append(fake.deleteTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteTreeStub
	fakeReturns := fake.deleteTreeReturns
	fake.recordInvocation("DeleteTree", []interface{}{arg1, arg2})
	fake.deleteTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) DeleteTreeCallCount() int {
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	return len(fake.deleteTreeArgsForCall)
}

func (fake *FakeStagedWriter) DeleteTreeCalls(stub func(context.Context, string) (hash.Hash, error)) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = stub
}

func (fake *FakeStagedWriter) DeleteTreeArgsForCall(i int) (context.Context, string) {
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	argsForCall := fake.deleteTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) DeleteTreeReturns(result1 hash.Hash, result2 error) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = nil
	fake.deleteTreeReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteTreeReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = nil
	if fake.deleteTreeReturnsOnCall == nil {
		fake.deleteTreeReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.deleteTreeReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) GetTree(arg1 context.Context, arg2 string) (*nanogit.Tree, error) {
	fake.getTreeMutex.Lock()
	ret, specificReturn := fake.getTreeReturnsOnCall[len(fake.getTreeArgsForCall)]
	fake.getTreeArgsForCall = append(fake.getTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTreeStub
	fakeReturns := fake.getTreeReturns
	fake.recordInvocation("GetTree", []interface{}{arg1, arg2})
	fake.getTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) GetTreeCallCount() int {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	return len(fake.getTreeArgsForCall)
}

func (fake *FakeStagedWriter) GetTreeCalls(stub func(context.Context, string) (*nanogit.Tree, error)) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = stub
}

func (fake *FakeStagedWriter) GetTreeArgsForCall(i int) (context.Context, string) {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	argsForCall := fake.getTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) GetTreeReturns(result1 *nanogit.Tree, result2 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	fake.getTreeReturns = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) GetTreeReturnsOnCall(i int, result1 *nanogit.Tree, result2 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	if fake.getTreeReturnsOnCall == nil {
		fake.getTreeReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Tree
			result2 error
		})
	}
	fake.getTreeReturnsOnCall[i] = struct {
		result1 *nanogit.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) MoveBlob(arg1 context.Context, arg2 string, arg3 string) (hash.Hash, error) {
	fake.moveBlobMutex.Lock()
	ret, specificReturn := fake.moveBlobReturnsOnCall[len(fake.moveBlobArgsForCall)]
	fake.moveBlobArgsForCall = append(fake.moveBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.MoveBlobStub
	fakeReturns := fake.moveBlobReturns
	fake.recordInvocation("MoveBlob", []interface{}{arg1, arg2, arg3})
	fake.moveBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) MoveBlobCallCount() int {
	fake.moveBlobMutex.RLock()
	defer fake.moveBlobMutex.RUnlock()
	return len(fake.moveBlobArgsForCall)
}

func (fake *FakeStagedWriter) MoveBlobCalls(stub func(context.Context, string, string) (hash.Hash, error)) {
	fake.moveBlobMutex.Lock()
	defer fake.moveBlobMutex.Unlock()
	fake.MoveBlobStub = stub
}

func (fake *FakeStagedWriter) MoveBlobArgsForCall(i int) (context.Context, string, string) {
	fake.moveBlobMutex.RLock()
	defer fake.moveBlobMutex.RUnlock()
	argsForCall := fake.moveBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) MoveBlobReturns(result1 hash.Hash, result2 error) {
	fake.moveBlobMutex.Lock()
	defer fake.moveBlobMutex.Unlock()
	fake.MoveBlobStub = nil
	fake.moveBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) MoveBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.moveBlobMutex.Lock()
	defer fake.moveBlobMutex.Unlock()
	fake.MoveBlobStub = nil
	if fake.moveBlobReturnsOnCall == nil {
		fake.moveBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.moveBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) MoveTree(arg1 context.Context, arg2 string, arg3 string) (hash.Hash, error) {
	fake.moveTreeMutex.Lock()
	ret, specificReturn := fake.moveTreeReturnsOnCall[len(fake.moveTreeArgsForCall)]
	fake.moveTreeArgsForCall = append(fake.moveTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.MoveTreeStub
	fakeReturns := fake.moveTreeReturns
	fake.recordInvocation("MoveTree", []interface{}{arg1, arg2, arg3})
	fake.moveTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) MoveTreeCallCount() int {
	fake.moveTreeMutex.RLock()
	defer fake.moveTreeMutex.RUnlock()
	return len(fake.moveTreeArgsForCall)
}

func (fake *FakeStagedWriter) MoveTreeCalls(stub func(context.Context, string, string) (hash.Hash, error)) {
	fake.moveTreeMutex.Lock()
	defer fake.moveTreeMutex.Unlock()
	fake.MoveTreeStub = stub
}

func (fake *FakeStagedWriter) MoveTreeArgsForCall(i int) (context.Context, string, string) {
	fake.moveTreeMutex.RLock()
	defer fake.moveTreeMutex.RUnlock()
	argsForCall := fake.moveTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) MoveTreeReturns(result1 hash.Hash, result2 error) {
	fake.moveTreeMutex.Lock()
	defer fake.moveTreeMutex.Unlock()
	fake.MoveTreeStub = nil
	fake.moveTreeReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) MoveTreeReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.moveTreeMutex.Lock()
	defer fake.moveTreeMutex.Unlock()
	fake.MoveTreeStub = nil
	if fake.moveTreeReturnsOnCall == nil {
		fake.moveTreeReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.moveTreeReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) Push(arg1 context.Context) error {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStagedWriter) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeStagedWriter) PushCalls(stub func(context.Context) error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeStagedWriter) PushArgsForCall(i int) context.Context {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStagedWriter) PushReturns(result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) PushReturnsOnCall(i int, result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) UpdateBlob(arg1 context.Context, arg2 string, arg3 []byte) (hash.Hash, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateBlobMutex.Lock()
	ret, specificReturn := fake.updateBlobReturnsOnCall[len(fake.updateBlobArgsForCall)]
	fake.updateBlobArgsForCall = append(fake.updateBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateBlobStub
	fakeReturns := fake.updateBlobReturns
	fake.recordInvocation("UpdateBlob", []interface{}{arg1, arg2, arg3Copy})
	fake.updateBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) UpdateBlobCallCount() int {
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	return len(fake.updateBlobArgsForCall)
}

func (fake *FakeStagedWriter) UpdateBlobCalls(stub func(context.Context, string, []byte) (hash.Hash, error)) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = stub
}

func (fake *FakeStagedWriter) UpdateBlobArgsForCall(i int) (context.Context, string, []byte) {
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	argsForCall := fake.updateBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) UpdateBlobReturns(result1 hash.Hash, result2 error) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = nil
	fake.updateBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) UpdateBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = nil
	if fake.updateBlobReturnsOnCall == nil {
		fake.updateBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.updateBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.blobExistsMutex.RLock()
	defer fake.blobExistsMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	fake.moveBlobMutex.RLock()
	defer fake.moveBlobMutex.RUnlock()
	fake.moveTreeMutex.RLock()
	defer fake.moveTreeMutex.RUnlock()
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStagedWriter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nanogit.StagedWriter = new(FakeStagedWriter)
