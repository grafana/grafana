// Package fetch provides the Chrome DevTools Protocol
// commands, types, and events for the Fetch domain.
//
// A domain for letting clients substitute browser's network layer with
// client code.
//
// Generated by the cdproto-gen command.
package fetch

// Code generated by cdproto-gen. DO NOT EDIT.

import (
	"context"
	"encoding/base64"

	"github.com/chromedp/cdproto/cdp"
	"github.com/chromedp/cdproto/io"
	"github.com/chromedp/cdproto/network"
)

// DisableParams disables the fetch domain.
type DisableParams struct{}

// Disable disables the fetch domain.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes Fetch.disable against the provided context.
func (p *DisableParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandDisable, nil, nil)
}

// EnableParams enables issuing of requestPaused events. A request will be
// paused until client calls one of failRequest, fulfillRequest or
// continueRequest/continueWithAuth.
type EnableParams struct {
	Patterns           []*RequestPattern `json:"patterns,omitempty"`           // If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
	HandleAuthRequests bool              `json:"handleAuthRequests,omitempty"` // If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
}

// Enable enables issuing of requestPaused events. A request will be paused
// until client calls one of failRequest, fulfillRequest or
// continueRequest/continueWithAuth.
//
// parameters:
func Enable() *EnableParams {
	return &EnableParams{}
}

// WithPatterns if specified, only requests matching any of these patterns
// will produce fetchRequested event and will be paused until clients response.
// If not set, all requests will be affected.
func (p EnableParams) WithPatterns(patterns []*RequestPattern) *EnableParams {
	p.Patterns = patterns
	return &p
}

// WithHandleAuthRequests if true, authRequired events will be issued and
// requests will be paused expecting a call to continueWithAuth.
func (p EnableParams) WithHandleAuthRequests(handleAuthRequests bool) *EnableParams {
	p.HandleAuthRequests = handleAuthRequests
	return &p
}

// Do executes Fetch.enable against the provided context.
func (p *EnableParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandEnable, p, nil)
}

// FailRequestParams causes the request to fail with specified reason.
type FailRequestParams struct {
	RequestID   RequestID           `json:"requestId"`   // An id the client received in requestPaused event.
	ErrorReason network.ErrorReason `json:"errorReason"` // Causes the request to fail with the given reason.
}

// FailRequest causes the request to fail with specified reason.
//
// parameters:
//   requestID - An id the client received in requestPaused event.
//   errorReason - Causes the request to fail with the given reason.
func FailRequest(requestID RequestID, errorReason network.ErrorReason) *FailRequestParams {
	return &FailRequestParams{
		RequestID:   requestID,
		ErrorReason: errorReason,
	}
}

// Do executes Fetch.failRequest against the provided context.
func (p *FailRequestParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandFailRequest, p, nil)
}

// FulfillRequestParams provides response to the request.
type FulfillRequestParams struct {
	RequestID       RequestID      `json:"requestId"`                // An id the client received in requestPaused event.
	ResponseCode    int64          `json:"responseCode"`             // An HTTP response code.
	ResponseHeaders []*HeaderEntry `json:"responseHeaders"`          // Response headers.
	Body            string         `json:"body,omitempty"`           // A response body.
	ResponsePhrase  string         `json:"responsePhrase,omitempty"` // A textual representation of responseCode. If absent, a standard phrase mathcing responseCode is used.
}

// FulfillRequest provides response to the request.
//
// parameters:
//   requestID - An id the client received in requestPaused event.
//   responseCode - An HTTP response code.
//   responseHeaders - Response headers.
func FulfillRequest(requestID RequestID, responseCode int64, responseHeaders []*HeaderEntry) *FulfillRequestParams {
	return &FulfillRequestParams{
		RequestID:       requestID,
		ResponseCode:    responseCode,
		ResponseHeaders: responseHeaders,
	}
}

// WithBody a response body.
func (p FulfillRequestParams) WithBody(body string) *FulfillRequestParams {
	p.Body = body
	return &p
}

// WithResponsePhrase a textual representation of responseCode. If absent, a
// standard phrase mathcing responseCode is used.
func (p FulfillRequestParams) WithResponsePhrase(responsePhrase string) *FulfillRequestParams {
	p.ResponsePhrase = responsePhrase
	return &p
}

// Do executes Fetch.fulfillRequest against the provided context.
func (p *FulfillRequestParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandFulfillRequest, p, nil)
}

// ContinueRequestParams continues the request, optionally modifying some of
// its parameters.
type ContinueRequestParams struct {
	RequestID RequestID      `json:"requestId"`          // An id the client received in requestPaused event.
	URL       string         `json:"url,omitempty"`      // If set, the request url will be modified in a way that's not observable by page.
	Method    string         `json:"method,omitempty"`   // If set, the request method is overridden.
	PostData  string         `json:"postData,omitempty"` // If set, overrides the post data in the request.
	Headers   []*HeaderEntry `json:"headers,omitempty"`  // If set, overrides the request headrts.
}

// ContinueRequest continues the request, optionally modifying some of its
// parameters.
//
// parameters:
//   requestID - An id the client received in requestPaused event.
func ContinueRequest(requestID RequestID) *ContinueRequestParams {
	return &ContinueRequestParams{
		RequestID: requestID,
	}
}

// WithURL if set, the request url will be modified in a way that's not
// observable by page.
func (p ContinueRequestParams) WithURL(url string) *ContinueRequestParams {
	p.URL = url
	return &p
}

// WithMethod if set, the request method is overridden.
func (p ContinueRequestParams) WithMethod(method string) *ContinueRequestParams {
	p.Method = method
	return &p
}

// WithPostData if set, overrides the post data in the request.
func (p ContinueRequestParams) WithPostData(postData string) *ContinueRequestParams {
	p.PostData = postData
	return &p
}

// WithHeaders if set, overrides the request headrts.
func (p ContinueRequestParams) WithHeaders(headers []*HeaderEntry) *ContinueRequestParams {
	p.Headers = headers
	return &p
}

// Do executes Fetch.continueRequest against the provided context.
func (p *ContinueRequestParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandContinueRequest, p, nil)
}

// ContinueWithAuthParams continues a request supplying authChallengeResponse
// following authRequired event.
type ContinueWithAuthParams struct {
	RequestID             RequestID              `json:"requestId"`             // An id the client received in authRequired event.
	AuthChallengeResponse *AuthChallengeResponse `json:"authChallengeResponse"` // Response to  with an authChallenge.
}

// ContinueWithAuth continues a request supplying authChallengeResponse
// following authRequired event.
//
// parameters:
//   requestID - An id the client received in authRequired event.
//   authChallengeResponse - Response to  with an authChallenge.
func ContinueWithAuth(requestID RequestID, authChallengeResponse *AuthChallengeResponse) *ContinueWithAuthParams {
	return &ContinueWithAuthParams{
		RequestID:             requestID,
		AuthChallengeResponse: authChallengeResponse,
	}
}

// Do executes Fetch.continueWithAuth against the provided context.
func (p *ContinueWithAuthParams) Do(ctxt context.Context, h cdp.Executor) (err error) {
	return h.Execute(ctxt, CommandContinueWithAuth, p, nil)
}

// GetResponseBodyParams causes the body of the response to be received from
// the server and returned as a single string. May only be issued for a request
// that is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that affect
// the request or disabling fetch domain before body is received results in an
// undefined behavior.
type GetResponseBodyParams struct {
	RequestID RequestID `json:"requestId"` // Identifier for the intercepted request to get body for.
}

// GetResponseBody causes the body of the response to be received from the
// server and returned as a single string. May only be issued for a request that
// is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that affect
// the request or disabling fetch domain before body is received results in an
// undefined behavior.
//
// parameters:
//   requestID - Identifier for the intercepted request to get body for.
func GetResponseBody(requestID RequestID) *GetResponseBodyParams {
	return &GetResponseBodyParams{
		RequestID: requestID,
	}
}

// GetResponseBodyReturns return values.
type GetResponseBodyReturns struct {
	Body          string `json:"body,omitempty"`          // Response body.
	Base64encoded bool   `json:"base64Encoded,omitempty"` // True, if content was sent as base64.
}

// Do executes Fetch.getResponseBody against the provided context.
//
// returns:
//   body - Response body.
func (p *GetResponseBodyParams) Do(ctxt context.Context, h cdp.Executor) (body []byte, err error) {
	// execute
	var res GetResponseBodyReturns
	err = h.Execute(ctxt, CommandGetResponseBody, p, &res)
	if err != nil {
		return nil, err
	}

	// decode
	var dec []byte
	if res.Base64encoded {
		dec, err = base64.StdEncoding.DecodeString(res.Body)
		if err != nil {
			return nil, err
		}
	} else {
		dec = []byte(res.Body)
	}
	return dec, nil
}

// TakeResponseBodyAsStreamParams returns a handle to the stream representing
// the response body. The request must be paused in the HeadersReceived stage.
// Note that after this command the request can't be continued as is -- client
// either needs to cancel it or to provide the response body. The stream only
// supports sequential read, IO.read will fail if the position is specified.
// This method is mutually exclusive with getResponseBody. Calling other methods
// that affect the request or disabling fetch domain before body is received
// results in an undefined behavior.
type TakeResponseBodyAsStreamParams struct {
	RequestID RequestID `json:"requestId"`
}

// TakeResponseBodyAsStream returns a handle to the stream representing the
// response body. The request must be paused in the HeadersReceived stage. Note
// that after this command the request can't be continued as is -- client either
// needs to cancel it or to provide the response body. The stream only supports
// sequential read, IO.read will fail if the position is specified. This method
// is mutually exclusive with getResponseBody. Calling other methods that affect
// the request or disabling fetch domain before body is received results in an
// undefined behavior.
//
// parameters:
//   requestID
func TakeResponseBodyAsStream(requestID RequestID) *TakeResponseBodyAsStreamParams {
	return &TakeResponseBodyAsStreamParams{
		RequestID: requestID,
	}
}

// TakeResponseBodyAsStreamReturns return values.
type TakeResponseBodyAsStreamReturns struct {
	Stream io.StreamHandle `json:"stream,omitempty"`
}

// Do executes Fetch.takeResponseBodyAsStream against the provided context.
//
// returns:
//   stream
func (p *TakeResponseBodyAsStreamParams) Do(ctxt context.Context, h cdp.Executor) (stream io.StreamHandle, err error) {
	// execute
	var res TakeResponseBodyAsStreamReturns
	err = h.Execute(ctxt, CommandTakeResponseBodyAsStream, p, &res)
	if err != nil {
		return "", err
	}

	return res.Stream, nil
}

// Command names.
const (
	CommandDisable                  = "Fetch.disable"
	CommandEnable                   = "Fetch.enable"
	CommandFailRequest              = "Fetch.failRequest"
	CommandFulfillRequest           = "Fetch.fulfillRequest"
	CommandContinueRequest          = "Fetch.continueRequest"
	CommandContinueWithAuth         = "Fetch.continueWithAuth"
	CommandGetResponseBody          = "Fetch.getResponseBody"
	CommandTakeResponseBodyAsStream = "Fetch.takeResponseBodyAsStream"
)
