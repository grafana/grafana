/**
 * Build hierarchical selector tree from flat list
 */
export function buildSelectorTree(selectors) {
  const tree = {};

  for (const selector of selectors) {
    const parts = selector.selectorPath.split('.');
    let current = tree;

    // Skip 'Components' prefix
    for (let i = 1; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    // Add final selector
    const finalPart = parts[parts.length - 1];
    current[finalPart] = selector.testIdValue || `data-testid ${selector.selectorPath.replace(/\./g, ' ')}`;
  }

  return tree;
}

/**
 * Generate TypeScript code for selector object
 */
export function generateSelectorCode(tree, indent = 0) {
  const spaces = '  '.repeat(indent);
  const lines = [];

  for (const [key, value] of Object.entries(tree)) {
    if (typeof value === 'string') {
      // Leaf node - actual selector
      lines.push(`${spaces}${key}: '${value}',`);
    } else {
      // Branch node - nested object
      lines.push(`${spaces}${key}: {`);
      lines.push(generateSelectorCode(value, indent + 1));
      lines.push(`${spaces}},`);
    }
  }

  return lines.join('\n');
}

/**
 * Merge new selectors into existing components structure
 */
export function mergeSelectors(existingCode, newSelectors) {
  // Parse existing structure (simplified - in reality would use AST)
  // For now, we'll append to end of relevant sections

  const tree = buildSelectorTree(newSelectors);
  const newCode = generateSelectorCode(tree, 1);

  return {
    tree,
    code: newCode,
  };
}

/**
 * Generate JSDoc comment for selector
 */
export function generateJSDoc(selector) {
  const lines = ['/**', ` * ${selector.description || 'Selector for ' + selector.componentName}`];

  if (selector.sourceFile) {
    lines.push(` * @source ${selector.sourceFile}:${selector.lineNumber}`);
  }

  if (selector.componentType) {
    lines.push(` * @type {${selector.componentType}}`);
  }

  lines.push(' */');

  return lines.join('\n');
}

/**
 * Sort selectors alphabetically by path
 */
export function sortSelectors(selectors) {
  return selectors.slice().sort((a, b) => {
    return a.selectorPath.localeCompare(b.selectorPath);
  });
}

/**
 * Group selectors by feature area
 */
export function groupByFeatureArea(selectors) {
  const groups = {};

  for (const selector of selectors) {
    const parts = selector.selectorPath.split('.');
    const featureArea = parts[1]; // Components.{FeatureArea}.

    if (!groups[featureArea]) {
      groups[featureArea] = [];
    }

    groups[featureArea].push(selector);
  }

  return groups;
}

/**
 * Generate markdown documentation for selectors
 */
export function generateMarkdownDocs(selectors) {
  const grouped = groupByFeatureArea(selectors);
  const lines = [
    '# Auto-Generated Selectors',
    '',
    'This document lists all selectors automatically generated by the add-testids script.',
    '',
  ];

  for (const [featureArea, selectorList] of Object.entries(grouped)) {
    lines.push(`## ${featureArea}`);
    lines.push('');
    lines.push('| Selector Path | Component | File |');
    lines.push('|---------------|-----------|------|');

    for (const selector of sortSelectors(selectorList)) {
      const file = selector.sourceFile ? selector.sourceFile.split('/').pop() : 'N/A';
      lines.push(`| \`${selector.selectorPath}\` | ${selector.componentName} | ${file} |`);
    }

    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Validate selector uniqueness
 */
export function validateUniqueness(selectors) {
  const paths = new Set();
  const duplicates = [];

  for (const selector of selectors) {
    if (paths.has(selector.selectorPath)) {
      duplicates.push(selector);
    } else {
      paths.add(selector.selectorPath);
    }
  }

  return {
    isValid: duplicates.length === 0,
    duplicates,
  };
}
