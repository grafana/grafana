/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
    "/admin/tsdb/clean_tombstones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Clean tombstones in the TSDB via PUT
         * @description Removes deleted data from disk and cleans up existing tombstones using PUT method.
         */
        put: operations["cleanTombstonesPut"];
        /**
         * Clean tombstones in the TSDB
         * @description Removes deleted data from disk and cleans up existing tombstones.
         */
        post: operations["cleanTombstonesPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/tsdb/delete_series": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Delete series matching selectors via PUT
         * @description Deletes data for a selection of series in a time range using PUT method.
         */
        put: operations["deleteSeriesPut"];
        /**
         * Delete series matching selectors
         * @description Deletes data for a selection of series in a time range.
         */
        post: operations["deleteSeriesPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/tsdb/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Create a snapshot of the TSDB via PUT
         * @description Creates a snapshot of all current data using PUT method.
         */
        put: operations["snapshotPut"];
        /**
         * Create a snapshot of the TSDB
         * @description Creates a snapshot of all current data.
         */
        post: operations["snapshotPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alertmanagers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Alertmanager discovery */
        get: operations["alertmanagers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alerts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get active alerts */
        get: operations["alerts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/features": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get features */
        get: operations["get-features"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/format_query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Format a PromQL query */
        get: operations["format-query"];
        put?: never;
        /** Format a PromQL query */
        post: operations["format-query-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/label/{name}/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get label values */
        get: operations["label-values"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get label names */
        get: operations["labels"];
        put?: never;
        /** Get label names */
        post: operations["labels-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get metadata */
        get: operations["get-metadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get notifications */
        get: operations["get-notifications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/otlp/v1/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * OTLP metrics write endpoint
         * @description OpenTelemetry Protocol metrics ingestion endpoint. Accepts OTLP/HTTP metrics in Protocol Buffer format.
         */
        post: operations["otlpWrite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/parse_query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Parse a PromQL query */
        get: operations["parse-query"];
        put?: never;
        /** Parse a PromQL query */
        post: operations["parse-query-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Evaluate an instant query */
        get: operations["query"];
        put?: never;
        /** Evaluate an instant query */
        post: operations["query-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query_exemplars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Query exemplars */
        get: operations["query-exemplars"];
        put?: never;
        /** Query exemplars */
        post: operations["query-exemplars-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query_range": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Evaluate a range query */
        get: operations["query-range"];
        put?: never;
        /** Evaluate a range query */
        post: operations["query-range-post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remote read endpoint
         * @description Prometheus remote read endpoint for federated queries. Accepts and returns Protocol Buffer encoded data.
         */
        post: operations["remoteRead"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get alerting and recording rules */
        get: operations["rules"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scrape_pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get scrape pools */
        get: operations["get-scrape-pools"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/series": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Find series by label matchers */
        get: operations["series"];
        put?: never;
        /** Find series by label matchers */
        post: operations["series-post"];
        /**
         * Delete series
         * @description Delete series matching selectors. Note: This is deprecated, use POST /admin/tsdb/delete_series instead.
         */
        delete: operations["delete-series"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/buildinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get status buildinfo */
        get: operations["get-status-buildinfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get status config */
        get: operations["get-status-config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/flags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get status flags */
        get: operations["get-status-flags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/runtimeinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get status runtimeinfo */
        get: operations["get-status-runtimeinfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/tsdb": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get TSDB status */
        get: operations["status-tsdb"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/tsdb/blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get TSDB blocks information */
        get: operations["status-tsdb-blocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/walreplay": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get status walreplay */
        get: operations["get-status-walreplay"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/targets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get targets */
        get: operations["get-targets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/targets/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get targets metadata */
        get: operations["get-targets-metadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/targets/relabel_steps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get targets relabel steps */
        get: operations["get-targets-relabel-steps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/write": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remote write endpoint
         * @description Prometheus remote write endpoint for sending metrics. Accepts Protocol Buffer encoded write requests.
         */
        post: operations["remoteWrite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
};
export type webhooks = Record<string, never>;
export type components = {
    schemas: {
        /** @description Alert information. */
        Alert: {
            /**
             * Format: date-time
             * @description Timestamp when the alert became active.
             */
            activeAt?: string;
            annotations: components["schemas"]["Labels"];
            /**
             * Format: date-time
             * @description Timestamp since the alert has been kept firing.
             */
            keepFiringSince?: string;
            labels: components["schemas"]["Labels"];
            /** @description State of the alert (pending, firing, or inactive). */
            state: string;
            /** @description Value of the alert expression. */
            value: string;
        };
        /** @description Alert discovery information containing all active alerts. */
        AlertDiscovery: {
            alerts: components["schemas"]["Alert"][];
        };
        /** @description Alertmanager discovery information including active and dropped instances. */
        AlertmanagerDiscovery: {
            activeAlertmanagers: components["schemas"]["AlertmanagerTarget"][];
            droppedAlertmanagers: components["schemas"]["AlertmanagerTarget"][];
        };
        /** @description Response body for alertmanagers endpoint. */
        AlertmanagersOutputBody: {
            data: components["schemas"]["AlertmanagerDiscovery"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Alertmanager target information. */
        AlertmanagerTarget: {
            /** @description URL of the Alertmanager instance. */
            url: string;
        };
        /** @description Response body for alerts endpoint. */
        AlertsOutputBody: {
            data: components["schemas"]["AlertDiscovery"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Block descriptor. */
        BlockDesc: {
            /** Format: int64 */
            maxTime: number;
            /** Format: int64 */
            minTime: number;
            ulid: string;
        };
        /** @description Block metadata. */
        BlockMeta: {
            compaction: components["schemas"]["BlockMetaCompaction"];
            /** Format: int64 */
            maxTime: number;
            /** Format: int64 */
            minTime: number;
            stats?: components["schemas"]["BlockStats"];
            ulid: string;
            /** Format: int64 */
            version: number;
        };
        /** @description Block compaction metadata. */
        BlockMetaCompaction: {
            deletable?: boolean;
            failed?: boolean;
            hints?: string[];
            /** Format: int64 */
            level: number;
            parents?: components["schemas"]["BlockDesc"][];
            sources?: string[];
        };
        /** @description Block statistics. */
        BlockStats: {
            /** Format: int64 */
            numChunks?: number;
            /** Format: int64 */
            numFloatSamples?: number;
            /** Format: int64 */
            numHistogramSamples?: number;
            /** Format: int64 */
            numSamples?: number;
            /** Format: int64 */
            numSeries?: number;
            /** Format: int64 */
            numTombstones?: number;
        };
        /** @description Response body containing only status. */
        CleanTombstonesOutputBody: {
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Relabel configuration. */
        Config: {
            /** @description Relabel action. */
            action?: string;
            /**
             * Format: int64
             * @description Modulus for hash-based relabeling.
             */
            modulus?: number;
            /** @description Regular expression for matching. */
            regex?: string;
            /** @description Replacement value. */
            replacement?: string;
            /** @description Separator for source label values. */
            separator?: string;
            /** @description Source labels for relabeling. */
            source_labels?: string[];
            /** @description Target label name. */
            target_label?: string;
        };
        /** @description Generic data structure with a name field. */
        DataStruct: {
            name: string;
        };
        /** @description Response body containing only status. */
        DeleteSeriesOutputBody: {
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Dropped target information. */
        DroppedTarget: {
            discoveredLabels: components["schemas"]["Labels"];
            /** @description Name of the scrape pool. */
            scrapePool: string;
        };
        /** @description Error response. */
        Error: {
            /**
             * @description Human-readable error message.
             * @example invalid parameter
             */
            error: string;
            /**
             * @description Type of error that occurred.
             * @example bad_data
             */
            errorType: string;
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        /** @description Generic response body. */
        FeaturesOutputBody: {
            /**
             * @description Response data (structure varies by endpoint).
             * @example {
             *       "result": "ok"
             *     }
             */
            data: unknown;
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description A sample with a float value. */
        FloatSample: {
            metric: components["schemas"]["Labels"];
            /**
             * @description Timestamp and float value as [unixTimestamp, stringValue].
             * @example [
             *       1767436620,
             *       "1"
             *     ]
             */
            value: (number | string)[];
        };
        /** @description A time series with float values. */
        FloatSeries: {
            metric: components["schemas"]["Labels"];
            /** @description Array of [timestamp, stringValue] pairs for float values. */
            values: (number | string)[][];
        };
        /** @description Response body for format query endpoint. */
        FormatQueryOutputBody: {
            /**
             * @description Formatted query string.
             * @example sum by(status) (rate(http_requests_total[5m]))
             */
            data: string;
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for format query. */
        FormatQueryPostInputBody: {
            /**
             * @description Form field: The query to format.
             * @example sum(rate(http_requests_total[5m])) by (status)
             */
            query: string;
        };
        /** @description TSDB head statistics. */
        HeadStats: {
            /** Format: int64 */
            chunkCount: number;
            /** Format: int64 */
            maxTime: number;
            /** Format: int64 */
            minTime: number;
            /** Format: int64 */
            numLabelPairs: number;
            /** Format: int64 */
            numSeries: number;
        };
        /** @description A sample with a native histogram value. */
        HistogramSample: {
            /**
             * @description Timestamp and histogram value as [unixTimestamp, histogramObject].
             * @example [
             *       1767436620,
             *       {
             *         "buckets": [],
             *         "count": "60",
             *         "sum": "120"
             *       }
             *     ]
             */
            histogram: (number | components["schemas"]["HistogramValue"])[];
            metric: components["schemas"]["Labels"];
        };
        /** @description A time series with native histogram values. */
        HistogramSeries: {
            /** @description Array of [timestamp, histogramObject] pairs for histogram values. */
            histograms: (number | components["schemas"]["HistogramValue"])[][];
            metric: components["schemas"]["Labels"];
        };
        /** @description Native histogram value representation. */
        HistogramValue: {
            /** @description Histogram buckets as [boundary_rule, lower, upper, count]. */
            buckets?: (number | string)[][];
            /** @description Total count of observations. */
            count: string;
            /** @description Sum of all observed values. */
            sum: string;
        };
        /** @description Label set represented as a key-value map. */
        Labels: {
            [key: string]: unknown;
        };
        /** @description Response body with an array of strings. */
        LabelsOutputBody: {
            /**
             * @example [
             *       "__name__",
             *       "job",
             *       "instance"
             *     ]
             */
            data: string[];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for labels query. */
        LabelsPostInputBody: {
            /**
             * @description Form field: The end time of the query.
             * @example 2023-07-21T21:00:00.000Z
             */
            end?: string;
            /**
             * Format: int64
             * @description Form field: The maximum number of label names to return.
             * @example 100
             */
            limit?: number;
            /**
             * @description Form field: Series selector argument that selects the series from which to read the label names.
             * @example [
             *       "{job=\"prometheus\"}"
             *     ]
             */
            "match[]"?: string[];
            /**
             * @description Form field: The start time of the query.
             * @example 2023-07-21T20:00:00.000Z
             */
            start?: string;
        };
        /** @description Response body with an array of strings. */
        LabelValuesOutputBody: {
            /**
             * @example [
             *       "__name__",
             *       "job",
             *       "instance"
             *     ]
             */
            data: string[];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Metric metadata. */
        Metadata: {
            /** @description Help text describing the metric. */
            help: string;
            /** @description Metric type (counter, gauge, histogram, summary, or untyped). */
            type: string;
            /** @description Unit of the metric. */
            unit: string;
        };
        /** @description Response body for metadata endpoint. */
        MetadataOutputBody: {
            data: {
                [key: string]: components["schemas"]["Metadata"][];
            };
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Target metric metadata. */
        MetricMetadata: {
            /** @description Help text describing the metric. */
            help: string;
            /** @description Metric name. */
            metric?: string;
            target: components["schemas"]["Labels"];
            /** @description Metric type (counter, gauge, histogram, summary, or untyped). */
            type: string;
            /** @description Unit of the metric. */
            unit: string;
        };
        /** @description Server notification. */
        Notification: {
            active: boolean;
            /** Format: date-time */
            date: string;
            text: string;
        };
        /** @description Response body with an array of notifications. */
        NotificationsOutputBody: {
            /**
             * @example [
             *       {
             *         "active": true,
             *         "date": "2023-07-21T20:00:00.000Z",
             *         "text": "Server is running"
             *       }
             *     ]
             */
            data: components["schemas"]["Notification"][];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Generic response body. */
        ParseQueryOutputBody: {
            /**
             * @description Response data (structure varies by endpoint).
             * @example {
             *       "result": "ok"
             *     }
             */
            data: unknown;
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for parse query. */
        ParseQueryPostInputBody: {
            /**
             * @description Form field: The query to parse.
             * @example sum(rate(http_requests_total[5m]))
             */
            query: string;
        };
        /** @description Prometheus version information. */
        PrometheusVersion: {
            branch: string;
            buildDate: string;
            buildUser: string;
            goVersion: string;
            revision: string;
            version: string;
        };
        /**
         * @description Query result data. The structure of 'result' depends on 'resultType'.
         * @example {
         *       "result": [
         *         {
         *           "metric": {
         *             "__name__": "up",
         *             "job": "prometheus"
         *           },
         *           "value": [
         *             1627845600,
         *             "1"
         *           ]
         *         }
         *       ],
         *       "resultType": "vector"
         *     }
         */
        QueryData: {
            /** @description Array of samples (either float or histogram). */
            result: (components["schemas"]["FloatSample"] | components["schemas"]["HistogramSample"])[];
            /** @enum {string} */
            resultType: "vector";
        } | {
            /** @description Array of time series (either float or histogram). */
            result: (components["schemas"]["FloatSeries"] | components["schemas"]["HistogramSeries"])[];
            /** @enum {string} */
            resultType: "matrix";
        } | {
            /** @description Scalar value as [timestamp, stringValue]. */
            result: (number | string)[];
            /** @enum {string} */
            resultType: "scalar";
        } | {
            /** @description String value as [timestamp, stringValue]. */
            result: string[];
            /** @enum {string} */
            resultType: "string";
        };
        /** @description Generic response body. */
        QueryExemplarsOutputBody: {
            /**
             * @description Response data (structure varies by endpoint).
             * @example {
             *       "result": "ok"
             *     }
             */
            data: unknown;
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for exemplars query. */
        QueryExemplarsPostInputBody: {
            /**
             * @description Form field: The end time of the query.
             * @example 2023-07-21T21:00:00.000Z
             */
            end?: string;
            /**
             * @description Form field: The query to execute.
             * @example http_requests_total
             */
            query: string;
            /**
             * @description Form field: The start time of the query.
             * @example 2023-07-21T20:00:00.000Z
             */
            start?: string;
        };
        /** @description Response body for instant query. */
        QueryOutputBody: {
            data: components["schemas"]["QueryData"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for instant query. */
        QueryPostInputBody: {
            /**
             * Format: int64
             * @description Form field: The maximum number of metrics to return.
             * @example 100
             */
            limit?: number;
            /**
             * @description Form field: Override the lookback period for this query (optional).
             * @example 5m
             */
            lookback_delta?: string;
            /**
             * @description Form field: The PromQL query to execute.
             * @example up
             */
            query: string;
            /**
             * @description Form field: When provided, include query statistics in the response (the special value 'all' enables more comprehensive statistics).
             * @example all
             */
            stats?: string;
            /**
             * @description Form field: The evaluation timestamp (optional, defaults to current time).
             * @example 2023-07-21T20:10:51.781Z
             */
            time?: string;
            /**
             * @description Form field: Evaluation timeout (optional, defaults to and is capped by the value of the -query.timeout flag).
             * @example 30s
             */
            timeout?: string;
        };
        /** @description Response body for range query. */
        QueryRangeOutputBody: {
            data: components["schemas"]["QueryData"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for range query. */
        QueryRangePostInputBody: {
            /**
             * @description Form field: The end time of the query.
             * @example 2023-07-21T20:20:30.781Z
             */
            end: string;
            /**
             * Format: int64
             * @description Form field: The maximum number of metrics to return.
             * @example 100
             */
            limit?: number;
            /**
             * @description Form field: Override the lookback period for this query (optional).
             * @example 5m
             */
            lookback_delta?: string;
            /**
             * @description Form field: The query to execute.
             * @example rate(http_requests_total[5m])
             */
            query: string;
            /**
             * @description Form field: The start time of the query.
             * @example 2023-07-21T20:10:30.781Z
             */
            start: string;
            /**
             * @description Form field: When provided, include query statistics in the response (the special value 'all' enables more comprehensive statistics).
             * @example all
             */
            stats?: string;
            /**
             * @description Form field: The step size of the query.
             * @example 15s
             */
            step: string;
            /**
             * @description Form field: Evaluation timeout (optional, defaults to and is capped by the value of the -query.timeout flag).
             * @example 30s
             */
            timeout?: string;
        };
        /** @description Relabel step showing the rule, output, and whether the target was kept. */
        RelabelStep: {
            keep: boolean;
            output: components["schemas"]["Labels"];
            rule: components["schemas"]["Config"];
        };
        /** @description Relabeling steps response. */
        RelabelStepsResponse: {
            steps: components["schemas"]["RelabelStep"][];
        };
        /** @description Rule discovery information containing all rule groups. */
        RuleDiscovery: {
            /** @description Pagination token for the next page of groups. */
            groupNextToken?: string;
            groups: components["schemas"]["RuleGroup"][];
        };
        /** @description Rule group information. */
        RuleGroup: {
            /**
             * Format: double
             * @description Time taken to evaluate the group in seconds.
             */
            evaluationTime: number;
            /** @description File containing the rule group. */
            file: string;
            /**
             * Format: double
             * @description Evaluation interval in seconds.
             */
            interval: number;
            /**
             * Format: date-time
             * @description Timestamp of the last evaluation.
             */
            lastEvaluation: string;
            /**
             * Format: int64
             * @description Maximum number of alerts for this group.
             */
            limit: number;
            /** @description Name of the rule group. */
            name: string;
            /** @description Rules in this group. */
            rules: Record<string, never>[];
        };
        /** @description Response body for rules endpoint. */
        RulesOutputBody: {
            data: components["schemas"]["RuleDiscovery"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Prometheus runtime information. */
        RuntimeInfo: {
            /** Format: int64 */
            corruptionCount: number;
            CWD: string;
            GODEBUG: string;
            GOGC: string;
            /** Format: int64 */
            GOMAXPROCS: number;
            /** Format: int64 */
            GOMEMLIMIT: number;
            /** Format: int64 */
            goroutineCount: number;
            hostname: string;
            /** Format: date-time */
            lastConfigTime: string;
            reloadConfigSuccess: boolean;
            /** Format: date-time */
            serverTime: string;
            /** Format: date-time */
            startTime: string;
            storageRetention: string;
        };
        /** @description List of all configured scrape pools. */
        ScrapePoolsDiscovery: {
            scrapePools: string[];
        };
        /** @description Response body for scrape pools endpoint. */
        ScrapePoolsOutputBody: {
            data: components["schemas"]["ScrapePoolsDiscovery"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Generic response body. */
        SeriesDeleteOutputBody: {
            /**
             * @description Response data (structure varies by endpoint).
             * @example {
             *       "result": "ok"
             *     }
             */
            data: unknown;
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body with an array of label sets. */
        SeriesOutputBody: {
            /**
             * @example [
             *       {
             *         "__name__": "up",
             *         "instance": "localhost:9090",
             *         "job": "prometheus"
             *       }
             *     ]
             */
            data: components["schemas"]["Labels"][];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description POST request body for series query. */
        SeriesPostInputBody: {
            /**
             * @description Form field: The end time of the query.
             * @example 2023-07-21T21:00:00.000Z
             */
            end?: string;
            /**
             * Format: int64
             * @description Form field: The maximum number of series to return.
             * @example 100
             */
            limit?: number;
            /**
             * @description Form field: Series selector argument that selects the series to return.
             * @example [
             *       "{job=\"prometheus\"}"
             *     ]
             */
            "match[]": string[];
            /**
             * @description Form field: The start time of the query.
             * @example 2023-07-21T20:00:00.000Z
             */
            start?: string;
        };
        /** @description Response body for snapshot endpoint. */
        SnapshotOutputBody: {
            data: components["schemas"]["DataStruct"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for status build info endpoint. */
        StatusBuildInfoOutputBody: {
            data: components["schemas"]["PrometheusVersion"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Prometheus configuration. */
        StatusConfigData: {
            /** @description Prometheus configuration in YAML format. */
            yaml: string;
        };
        /** @description Response body for status config endpoint. */
        StatusConfigOutputBody: {
            data: components["schemas"]["StatusConfigData"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for status flags endpoint. */
        StatusFlagsOutputBody: {
            data: {
                [key: string]: string;
            };
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for status runtime info endpoint. */
        StatusRuntimeInfoOutputBody: {
            data: components["schemas"]["RuntimeInfo"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description TSDB blocks information. */
        StatusTSDBBlocksData: {
            blocks: components["schemas"]["BlockMeta"][];
        };
        /** @description Response body for status TSDB blocks endpoint. */
        StatusTSDBBlocksOutputBody: {
            data: components["schemas"]["StatusTSDBBlocksData"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for status TSDB endpoint. */
        StatusTSDBOutputBody: {
            data: components["schemas"]["TSDBStatus"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description WAL replay status. */
        StatusWALReplayData: {
            /** Format: int64 */
            current: number;
            /** Format: int64 */
            max: number;
            /** Format: int64 */
            min: number;
        };
        /** @description Response body for status WAL replay endpoint. */
        StatusWALReplayOutputBody: {
            data: components["schemas"]["StatusWALReplayData"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Scrape target information. */
        Target: {
            discoveredLabels: components["schemas"]["Labels"];
            /** @description Global URL of the target. */
            globalUrl: string;
            /** @description Health status of the target (up, down, or unknown). */
            health: string;
            labels: components["schemas"]["Labels"];
            /** @description Last error message from scraping. */
            lastError: string;
            /**
             * Format: date-time
             * @description Timestamp of the last scrape.
             */
            lastScrape: string;
            /**
             * Format: double
             * @description Duration of the last scrape in seconds.
             */
            lastScrapeDuration: number;
            /** @description Scrape interval for this target. */
            scrapeInterval: string;
            /** @description Name of the scrape pool. */
            scrapePool: string;
            /** @description Scrape timeout for this target. */
            scrapeTimeout: string;
            /** @description URL of the target. */
            scrapeUrl: string;
        };
        /** @description Target discovery information including active and dropped targets. */
        TargetDiscovery: {
            activeTargets: components["schemas"]["Target"][];
            droppedTargetCounts: {
                [key: string]: number;
            };
            droppedTargets: components["schemas"]["DroppedTarget"][];
        };
        /** @description Response body with an array of metric metadata. */
        TargetMetadataOutputBody: {
            /**
             * @example [
             *       {
             *         "help": "The current health status of the target",
             *         "metric": "up",
             *         "target": {
             *           "instance": "localhost:9090",
             *           "job": "prometheus"
             *         },
             *         "type": "gauge",
             *         "unit": ""
             *       }
             *     ]
             */
            data: components["schemas"]["MetricMetadata"][];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for target relabel steps endpoint. */
        TargetRelabelStepsOutputBody: {
            data: components["schemas"]["RelabelStepsResponse"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description Response body for targets endpoint. */
        TargetsOutputBody: {
            data: components["schemas"]["TargetDiscovery"];
            /** @description Only set if there were info-level annotations while executing the request. */
            infos?: string[];
            /**
             * @description Response status.
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Only set if there were warnings while executing the request. There will still be data in the data field. */
            warnings?: string[];
        };
        /** @description TSDB statistic. */
        TSDBStat: {
            name: string;
            /** Format: int64 */
            value: number;
        };
        /** @description TSDB status information. */
        TSDBStatus: {
            headStats: components["schemas"]["HeadStats"];
            labelValueCountByLabelName: components["schemas"]["TSDBStat"][];
            memoryInBytesByLabelName: components["schemas"]["TSDBStat"][];
            seriesCountByLabelValuePair: components["schemas"]["TSDBStat"][];
            seriesCountByMetricName: components["schemas"]["TSDBStat"][];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
};
export type $defs = Record<string, never>;
export interface operations {
    cleanTombstonesPut: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tombstones cleaned successfully via PUT. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanTombstonesOutputBody"];
                };
            };
            /** @description Error cleaning tombstones via PUT. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    cleanTombstonesPost: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tombstones cleaned successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanTombstonesOutputBody"];
                };
            };
            /** @description Error cleaning tombstones. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteSeriesPut: {
        parameters: {
            query: {
                /** @description End timestamp for deletion. */
                end?: string | number;
                /** @description Series selectors to identify series to delete. */
                "match[]": string[];
                /** @description Start timestamp for deletion. */
                start?: string | number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Series deleted successfully via PUT. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteSeriesOutputBody"];
                };
            };
            /** @description Error deleting series via PUT. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteSeriesPost: {
        parameters: {
            query: {
                /** @description End timestamp for deletion. */
                end?: string | number;
                /** @description Series selectors to identify series to delete. */
                "match[]": string[];
                /** @description Start timestamp for deletion. */
                start?: string | number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Series deleted successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteSeriesOutputBody"];
                };
            };
            /** @description Error deleting series. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    snapshotPut: {
        parameters: {
            query?: {
                /** @description If true, do not snapshot data in the head block. */
                skip_head?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot created successfully via PUT. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SnapshotOutputBody"];
                };
            };
            /** @description Error creating snapshot via PUT. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    snapshotPost: {
        parameters: {
            query?: {
                /** @description If true, do not snapshot data in the head block. */
                skip_head?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SnapshotOutputBody"];
                };
            };
            /** @description Error creating snapshot. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    alertmanagers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Alertmanager targets retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertmanagersOutputBody"];
                };
            };
            /** @description Error retrieving Alertmanager targets. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    alerts: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Active alerts retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertsOutputBody"];
                };
            };
            /** @description Error retrieving alerts. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-features": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feature flags retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FeaturesOutputBody"];
                };
            };
            /** @description Error retrieving features. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "format-query": {
        parameters: {
            query: {
                /** @description PromQL expression to format. */
                query: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Query formatted successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormatQueryOutputBody"];
                };
            };
            /** @description Error formatting query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "format-query-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit a PromQL query to format. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["FormatQueryPostInputBody"];
            };
        };
        responses: {
            /** @description Query formatting completed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormatQueryOutputBody"];
                };
            };
            /** @description Error formatting query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "label-values": {
        parameters: {
            query?: {
                /** @description End timestamp for label values query. */
                end?: string | number;
                /** @description Maximum number of label values to return. */
                limit?: number;
                /** @description Series selector argument. */
                "match[]"?: string[];
                /** @description Start timestamp for label values query. */
                start?: string | number;
            };
            header?: never;
            path: {
                /** @description Label name. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Label values retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LabelValuesOutputBody"];
                };
            };
            /** @description Error retrieving label values. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    labels: {
        parameters: {
            query?: {
                /** @description End timestamp for label names query. */
                end?: string | number;
                /** @description Maximum number of label names to return. */
                limit?: number;
                /** @description Series selector argument. */
                "match[]"?: string[];
                /** @description Start timestamp for label names query. */
                start?: string | number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Label names retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LabelsOutputBody"];
                };
            };
            /** @description Error retrieving label names. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "labels-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit a label names query. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["LabelsPostInputBody"];
            };
        };
        responses: {
            /** @description Label names retrieved successfully via POST. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LabelsOutputBody"];
                };
            };
            /** @description Error retrieving label names via POST. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-metadata": {
        parameters: {
            query?: {
                /** @description The maximum number of metrics to return. */
                limit?: number;
                /** @description The maximum number of metadata entries per metric. */
                limit_per_metric?: number;
                /** @description A metric name to filter metadata for. */
                metric?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metric metadata retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetadataOutputBody"];
                };
            };
            /** @description Error retrieving metadata. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Notifications retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationsOutputBody"];
                };
            };
            /** @description Error retrieving notifications. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    otlpWrite: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "parse-query": {
        parameters: {
            query: {
                /** @description PromQL expression to parse. */
                query: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Query parsed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParseQueryOutputBody"];
                };
            };
            /** @description Error parsing query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "parse-query-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit a PromQL query to parse. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["ParseQueryPostInputBody"];
            };
        };
        responses: {
            /** @description Query parsed successfully via POST. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParseQueryOutputBody"];
                };
            };
            /** @description Error parsing query via POST. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    query: {
        parameters: {
            query: {
                /** @description The maximum number of metrics to return. */
                limit?: number;
                /** @description Override the lookback period for this query. Optional. */
                lookback_delta?: string;
                /** @description The PromQL query to execute. */
                query: string;
                /** @description When provided, include query statistics in the response. The special value 'all' enables more comprehensive statistics. */
                stats?: string;
                /** @description The evaluation timestamp (optional, defaults to current time). */
                time?: string | number;
                /** @description Evaluation timeout. Optional. Defaults to and is capped by the value of the -query.timeout flag. */
                timeout?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Query executed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryOutputBody"];
                };
            };
            /** @description Error executing query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "query-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit an instant query. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["QueryPostInputBody"];
            };
        };
        responses: {
            /** @description Instant query executed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryOutputBody"];
                };
            };
            /** @description Error executing instant query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "query-exemplars": {
        parameters: {
            query: {
                /** @description End timestamp for exemplars query. */
                end?: string | number;
                /** @description PromQL query to extract exemplars for. */
                query: string;
                /** @description Start timestamp for exemplars query. */
                start?: string | number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Exemplars retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryExemplarsOutputBody"];
                };
            };
            /** @description Error retrieving exemplars. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "query-exemplars-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit an exemplars query. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["QueryExemplarsPostInputBody"];
            };
        };
        responses: {
            /** @description Exemplars query completed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryExemplarsOutputBody"];
                };
            };
            /** @description Error processing exemplars query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "query-range": {
        parameters: {
            query: {
                /** @description The end time of the query. */
                end: string | number;
                /** @description The maximum number of metrics to return. */
                limit?: number;
                /** @description Override the lookback period for this query. Optional. */
                lookback_delta?: string;
                /** @description The query to execute. */
                query: string;
                /** @description The start time of the query. */
                start: string | number;
                /** @description When provided, include query statistics in the response. The special value 'all' enables more comprehensive statistics. */
                stats?: string;
                /** @description The step size of the query. */
                step: string;
                /** @description Evaluation timeout. Optional. Defaults to and is capped by the value of the -query.timeout flag. */
                timeout?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Range query executed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryRangeOutputBody"];
                };
            };
            /** @description Error executing range query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "query-range-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit a range query. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["QueryRangePostInputBody"];
            };
        };
        responses: {
            /** @description Range query executed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryRangeOutputBody"];
                };
            };
            /** @description Error executing range query. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    remoteRead: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    rules: {
        parameters: {
            query?: {
                /** @description Exclude active alerts from response. */
                exclude_alerts?: string;
                /** @description Filter by file path. */
                "file[]"?: string[];
                /** @description Maximum number of rule groups to return. */
                group_limit?: number;
                /** @description Pagination token for next page. */
                group_next_token?: string;
                /** @description Label matchers to filter rules. */
                "match[]"?: string[];
                /** @description Filter by rule group name. */
                "rule_group[]"?: string[];
                /** @description Filter by rule name. */
                "rule_name[]"?: string[];
                /** @description Filter by rule type: alert or record. */
                type?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Rules retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RulesOutputBody"];
                };
            };
            /** @description Error retrieving rules. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-scrape-pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scrape pools retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScrapePoolsOutputBody"];
                };
            };
            /** @description Error retrieving scrape pools. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    series: {
        parameters: {
            query: {
                /** @description End timestamp for series query. */
                end?: string | number;
                /** @description Maximum number of series to return. */
                limit?: number;
                /** @description Series selector argument. */
                "match[]": string[];
                /** @description Start timestamp for series query. */
                start?: string | number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Series returned matching the provided label matchers. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeriesOutputBody"];
                };
            };
            /** @description Error retrieving series. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "series-post": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Submit a series query. This endpoint accepts the same parameters as the GET version. */
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["SeriesPostInputBody"];
            };
        };
        responses: {
            /** @description Series returned matching the provided label matchers via POST. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeriesOutputBody"];
                };
            };
            /** @description Error retrieving series via POST. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "delete-series": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Series marked for deletion. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeriesDeleteOutputBody"];
                };
            };
            /** @description Error deleting series. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-status-buildinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Build information retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusBuildInfoOutputBody"];
                };
            };
            /** @description Error retrieving build information. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-status-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Configuration retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusConfigOutputBody"];
                };
            };
            /** @description Error retrieving configuration. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-status-flags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Command-line flags retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusFlagsOutputBody"];
                };
            };
            /** @description Error retrieving flags. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-status-runtimeinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Runtime information retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusRuntimeInfoOutputBody"];
                };
            };
            /** @description Error retrieving runtime information. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "status-tsdb": {
        parameters: {
            query?: {
                /** @description The maximum number of items to return per category. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description TSDB status retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusTSDBOutputBody"];
                };
            };
            /** @description Error retrieving TSDB status. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "status-tsdb-blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description TSDB blocks information retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusTSDBBlocksOutputBody"];
                };
            };
            /** @description Error retrieving TSDB blocks. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-status-walreplay": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WAL replay status retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusWALReplayOutputBody"];
                };
            };
            /** @description Error retrieving WAL replay status. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-targets": {
        parameters: {
            query?: {
                /** @description Filter targets by scrape pool name. */
                scrapePool?: string;
                /** @description Filter by state: active, dropped, or any. */
                state?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Target discovery information retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TargetsOutputBody"];
                };
            };
            /** @description Error retrieving targets. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-targets-metadata": {
        parameters: {
            query?: {
                /** @description Maximum number of targets to match. */
                limit?: number;
                /** @description Label selector to filter targets. */
                match_target?: string;
                /** @description Metric name to retrieve metadata for. */
                metric?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Target metadata retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TargetMetadataOutputBody"];
                };
            };
            /** @description Error retrieving target metadata. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    "get-targets-relabel-steps": {
        parameters: {
            query: {
                /** @description JSON-encoded labels to apply relabel rules to. */
                labels: string;
                /** @description Name of the scrape pool. */
                scrapePool: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Relabel steps retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TargetRelabelStepsOutputBody"];
                };
            };
            /** @description Error retrieving relabel steps. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    remoteWrite: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
