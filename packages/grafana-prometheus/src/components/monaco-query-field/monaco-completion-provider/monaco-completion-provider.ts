// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/index.ts
import { TimeRange } from '@grafana/data';
import type { Monaco, monacoTypes } from '@grafana/ui';

import { CompletionType, getCompletions } from './completions';
import { DataProvider } from './data_provider';
import { getSituation } from './situation';
import { NeverCaseError } from './util';

export type TriggerType = 'partial' | 'full';

export function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {
  return {
    // monaco-editor sometimes provides suggestions automatically, i am not
    // sure based on what, seems to be by analyzing the words already
    // written.
    // to try it out:
    // - enter `go_goroutines{job~`
    // - have the cursor at the end of the string
    // - press ctrl-enter
    // - you will get two suggestions
    // those were not provided by grafana, they are offered automatically.
    // i want to remove those. the only way i found is:
    // - every suggestion-item has a `kind` attribute,
    //   that controls the icon to the left of the suggestion.
    // - items auto-generated by monaco have `kind` set to `text`.
    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.
    // - and then we tell monaco not to show suggestions of kind `text`
    showWords: false,
  };
}

function getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {
  switch (type) {
    case 'DURATION':
      return monaco.languages.CompletionItemKind.Unit;
    case 'FUNCTION':
      return monaco.languages.CompletionItemKind.Variable;
    case 'HISTORY':
      return monaco.languages.CompletionItemKind.Snippet;
    case 'LABEL_NAME':
      return monaco.languages.CompletionItemKind.Enum;
    case 'LABEL_VALUE':
      return monaco.languages.CompletionItemKind.EnumMember;
    case 'METRIC_NAME':
      return monaco.languages.CompletionItemKind.Constructor;
    default:
      throw new NeverCaseError(type);
  }
}

function getTriggerType(
  context: monacoTypes.languages.CompletionContext,
  word: monacoTypes.editor.IWordAtPosition | null,
  model: monacoTypes.editor.ITextModel,
  position: monacoTypes.Position,
  isManualTrigger: boolean
): TriggerType {
  // Manual trigger (Ctrl+Space)
  if (isManualTrigger) {
    return 'full';
  }

  // Trigger characters
  const triggerChars = ['{', ',', '[', '(', '=', '~', ' ', '"'];
  const charBeforeCursor = model.getValueInRange({
    startLineNumber: position.lineNumber,
    endLineNumber: position.lineNumber,
    startColumn: Math.max(1, position.column - 1),
    endColumn: position.column,
  });

  if (triggerChars.includes(charBeforeCursor)) {
    return 'full';
  }

  // Word length >= 3
  if (word && word.word.length >= 3) {
    return 'full';
  }

  return 'partial';
}

export function getCompletionProvider(
  monaco: Monaco,
  dataProvider: DataProvider,
  timeRange: TimeRange
): { provider: monacoTypes.languages.CompletionItemProvider; state: { isManualTriggerRequested: boolean } } {
  // Short debounce to catch rapid typing
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;
  const DEBOUNCE_DELAY = 150; // Much shorter delay to catch rapid typing

  // Simple local state
  const state = {
    isManualTriggerRequested: false,
  };

  const provideCompletionItems = (
    model: monacoTypes.editor.ITextModel,
    position: monacoTypes.Position,
    context: monacoTypes.languages.CompletionContext
  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {
    const word = model.getWordAtPosition(position);
    const range =
      word != null
        ? monaco.Range.lift({
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn,
          })
        : monaco.Range.fromPositions(position);

    const isManualTrigger = state.isManualTriggerRequested;
    if (isManualTrigger) {
      state.isManualTriggerRequested = false;
    }

    const triggerType: TriggerType = getTriggerType(context, word, model, position, isManualTrigger);

    // For immediate triggers (manual, trigger chars, or already 3+ chars), execute immediately
    const isImmediate = isManualTrigger || triggerType === 'full';

    if (isImmediate) {
      if (debounceTimer) {
        clearTimeout(debounceTimer);
        debounceTimer = null;
      }
      return executeCompletionLogic(model, position, range, dataProvider, timeRange, word?.word, triggerType);
    }

    // For typing scenarios, use short debounce to catch rapid typing
    if (debounceTimer) {
      clearTimeout(debounceTimer);
    }

    return new Promise((resolve) => {
      debounceTimer = setTimeout(() => {
        // Re-check if we should use full completions after debounce
        const updatedWord = model.getWordAtPosition(position);
        const updatedTriggerType: TriggerType = getTriggerType(context, updatedWord, model, position, false)
          ? 'full'
          : 'partial';

        executeCompletionLogic(
          model,
          position,
          range,
          dataProvider,
          timeRange,
          updatedWord?.word,
          updatedTriggerType
        ).then(resolve);
      }, DEBOUNCE_DELAY);
    });
  };

  const executeCompletionLogic = async (
    model: monacoTypes.editor.ITextModel,
    position: monacoTypes.Position,
    range: monacoTypes.Range,
    dataProvider: DataProvider,
    timeRange: TimeRange,
    wordText?: string,
    triggerType: TriggerType = 'full'
  ): Promise<monacoTypes.languages.CompletionList> => {
    // documentation says `position` will be "adjusted" in `getOffsetAt`
    // i don't know what that means, to be sure i clone it
    const positionClone = {
      column: position.column,
      lineNumber: position.lineNumber,
    };

    dataProvider.monacoSettings.setInputInRange(model.getValueInRange(range));

    // Check to see if the browser supports window.getSelection()
    if (window.getSelection) {
      const selectedText = window.getSelection()?.toString();
      // If the user has selected text, adjust the cursor position to be at the start of the selection, instead of the end
      if (selectedText && selectedText.length > 0) {
        positionClone.column = positionClone.column - selectedText.length;
      }
    }

    const offset = model.getOffsetAt(positionClone);
    const situation = getSituation(model.getValue(), offset);
    const completionsPromise =
      situation != null
        ? getCompletions(situation, dataProvider, timeRange, wordText, triggerType)
        : Promise.resolve([]);

    return completionsPromise.then((items) => {
      // monaco by-default alphabetically orders the items.
      // to stop it, we use a number-as-string sortkey,
      // so that monaco keeps the order we use
      const maxIndexDigits = items.length.toString().length;
      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({
        range,
        label: item.label,
        detail: item.detail,
        insertText: item.insertText,
        documentation: item.documentation,
        insertTextRules: item.insertTextRules,
        kind: getMonacoCompletionItemKind(item.type, monaco),
        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have
        command: item.triggerOnInsert ? { id: 'editor.action.triggerSuggest', title: '' } : undefined,
      }));

      return {
        suggestions,
        incomplete: dataProvider.monacoSettings.suggestionsIncomplete,
      };
    });
  };

  return {
    provider: {
      triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '"'],
      provideCompletionItems,
    },
    state,
  };
}
