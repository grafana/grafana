{"version":3,"sources":["../../../../../src/datasource/services/netCrunchAPI/adrem/counters.js"],"names":["NetCrunchCounters","adremClient","netCrunchConnection","isOid","stringData","indexOf","C_PERSEC","replace","match","stringToCntType","type","MIB_CNT_SRC_ID","counterConsts","CNT_TYPE","cstMIB","cstXML","getCounterPathType","counterPath","pathType","cstSimple","CNT_SRC_SEPARATOR","split","removeCounterPathType","resultPath","parseSNMPPath","snmpPath","objectType","objectValue","snmpPathParts","value","displayStringToSnmpFunc","functionMap","result","SNMP_FUNC","scfUnknown","OVERALL_TOTAL","scfSum","OVERALL_AVERAGE","scfAvg","OVERALL_MAXIMUM","scfMax","OVERALL_MINIMUM","scfMin","OVERALL_COUNT","scfCount","parseShortPath","decodePath","parseOIDPath","oidPath","decodedPath","instOID","obj","objOID","cnt","inst","instType","isPerSec","decodedObjOID","length","SNMP_INSTANCE_TYPE","sitNone","sitByIndex","charAt","substr","sitComputable","sitByLookup","parseXMLPath","xmlPath","hasInstance","getOidPath","oid","oidCache","getOidFunc","updateOidPath","Promise","resolve","initSnmpMibData","snmpMibData","NetCrunch","SnmpMibData","getShortOidPath","shortOidPathsCache","getFullOidPath","fullOidPathsCache","path","parts","CNT_SEPARATOR","slice","join","encodeDisplayPath","withPerSec","ix","perSec","counterToString","decodedCounter","makeShortPath","object","counter","instance","getSNMPDisplayPath","shortPath","showPerSecondValue","displayPath","then","resolvedPath","isKnownMillisecondCounter","toLowerCase","isMillisecondsCounter","c","cnRTT","cnSCT","toUpperCase","contains","isBytesCounter","displayName","resources","metrics","bytes","memory","mbytes","kbytes","getValueFormatting","base1","base","units","range","getValueRange","kilo","getTimeRange","Object","create","counterTypes","NETCRUNCH_COUNTER_TYPES","NETCRUNCH_COUNTER_CONST","unitsToMetric","counterName","counterDisplayName","getMetric","multiplier","percentage","milliseconds","bytesBitsPS","getDisplayValue","metric","mparts","m","isBPS","isBytes","bytesBps","isMS","v","isNaN","Math","round","isMIBCnt","counterPathObject","counterType","XML_CNT_SRC_ID","removePerSecond","parseCounterPath","counterPathType","parsedCounterPath","encodePath","p","push","addInstance","decodeDisplayPath","objParts","fmt","some","s","forEach","i","removePerSec","counterPathToDisplayStr","showPerSecValue","knownMSCounters","sitValue"],"mappings":"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","file":"counters.js","sourcesContent":["/**\r\n * @license\r\n * Copyright AdRem Software. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\r\n * found in the LICENSE file.\r\n */\r\n\r\n/* eslint-disable no-param-reassign */\r\n\r\nconst\r\n  C_PERSEC = '/sec',\r\n  CNT_SEPARATOR = '|',\r\n  CNT_SRC_SEPARATOR = '&',\r\n  MIB_CNT_SRC_ID = 'MIB',\r\n  XML_CNT_SRC_ID = 'XML',\r\n\r\n  // Overall counter instances\r\n  OVERALL_TOTAL = '_Total',\r\n  OVERALL_MAXIMUM = '_Maximum',\r\n  OVERALL_MINIMUM = '_Minimum',\r\n  OVERALL_AVERAGE = '_Average',\r\n  OVERALL_COUNT = '_Count',\r\n\r\n  knownMSCounters = ['load time', 'check time', 'round trip time'],\r\n\r\n  NETCRUNCH_COUNTER_CONST = {\r\n    CNT_TYPE: {\r\n      cstXML: 1,\r\n      cstMIB: 2,\r\n      cstSimple: 3\r\n    },\r\n\r\n    SNMP_INSTANCE_TYPE: {\r\n      sitValue: 1,\r\n      sitNone: 2,\r\n      sitByIndex: 3,\r\n      sitByLookup: 4,\r\n      sitComputable: 5\r\n    },\r\n\r\n    SNMP_FUNC: {\r\n      scfUnknown: 1,\r\n      scfSum: 2,\r\n      scfMin: 3,\r\n      scfMax: 4,\r\n      scfAvg: 5,\r\n      scfCount: 6\r\n    }\r\n  },\r\n\r\n  NETCRUNCH_COUNTER_TYPES = {\r\n    percentage: '%',\r\n    milliseconds: 'ms',\r\n    bytesBitsPS: 'bps',\r\n    bytesBps: 'Bps',\r\n    bytes: 'bytes'\r\n  };\r\n\r\nfunction NetCrunchCounters(adremClient, netCrunchConnection) {\r\n\r\n  let snmpMibData = null;\r\n  const\r\n    shortOidPathsCache = Object.create(null),\r\n    fullOidPathsCache = Object.create(null),\r\n    cnSCT = 'Check Time',\r\n    cnRTT = 'Round Trip Time',\r\n    resources = Object.create(null),\r\n    counterTypes = NETCRUNCH_COUNTER_TYPES,\r\n    counterConsts = NETCRUNCH_COUNTER_CONST;\r\n\r\n  function isOid(stringData) {\r\n    if (stringData.indexOf(C_PERSEC) >= 0) {\r\n      stringData = stringData.replace(C_PERSEC, '');\r\n    }\r\n    return (stringData.match(/^((([0-9]+)\\.)+[0-9]+)$/) != null);\r\n  }\r\n\r\n  function isMIBCnt(obj, cnt) {\r\n    return (((isOid(obj) === true) && ((cnt === '') || (isOid(cnt) === true))) ||\r\n            ((obj === '') && (isOid(cnt) === true)));\r\n  }\r\n\r\n  function counterPathObject(counter, counterType) {\r\n    if (counterType !== counterConsts.CNT_TYPE.cstSimple) {\r\n      if (counterType === counterConsts.CNT_TYPE.cstXML) {\r\n        return XML_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\r\n      }\r\n      if (counterType === counterConsts.CNT_TYPE.cstMIB) {\r\n        return MIB_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\r\n      }\r\n    }\r\n    return counter;\r\n  }\r\n\r\n  function stringToCntType(type) {\r\n    if (type === MIB_CNT_SRC_ID) {\r\n      return counterConsts.CNT_TYPE.cstMIB;\r\n    }\r\n    return counterConsts.CNT_TYPE.cstXML;\r\n  }\r\n\r\n  function getCounterPathType(counterPath) {\r\n    let pathType;\r\n\r\n    pathType = counterConsts.CNT_TYPE.cstSimple;\r\n\r\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\r\n      pathType = stringToCntType(counterPath.split(CNT_SRC_SEPARATOR)[0]);\r\n    }\r\n    return pathType;\r\n  }\r\n\r\n  function removeCounterPathType(counterPath) {\r\n    let resultPath = counterPath;\r\n\r\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\r\n      resultPath = counterPath.split(CNT_SRC_SEPARATOR)[1];\r\n    }\r\n\r\n    return resultPath;\r\n  }\r\n\r\n  function removePerSecond(stringData) {\r\n    return stringData.replace(C_PERSEC, '');\r\n  }\r\n\r\n  function parseSNMPPath(snmpPath) {\r\n    let\r\n      objectType,\r\n      objectValue,\r\n      snmpPathParts;\r\n\r\n    if (snmpPath.indexOf(CNT_SRC_SEPARATOR) < 0) {\r\n      objectType = counterConsts.CNT_TYPE.cstXML;\r\n      objectValue = snmpPath;\r\n    } else {\r\n      snmpPathParts = snmpPath.split(CNT_SRC_SEPARATOR);\r\n      objectType = stringToCntType(snmpPathParts[0]);\r\n      objectValue = snmpPathParts[1];\r\n    }\r\n\r\n    return {\r\n      type: objectType,\r\n      value: objectValue\r\n    };\r\n  }\r\n\r\n  function displayStringToSnmpFunc(stringData) {\r\n    const functionMap = {};\r\n    let result = counterConsts.SNMP_FUNC.scfUnknown;\r\n\r\n    functionMap[OVERALL_TOTAL] = counterConsts.SNMP_FUNC.scfSum;\r\n    functionMap[OVERALL_AVERAGE] = counterConsts.SNMP_FUNC.scfAvg;\r\n    functionMap[OVERALL_MAXIMUM] = counterConsts.SNMP_FUNC.scfMax;\r\n    functionMap[OVERALL_MINIMUM] = counterConsts.SNMP_FUNC.scfMin;\r\n    functionMap[OVERALL_COUNT] = counterConsts.SNMP_FUNC.scfCount;\r\n\r\n    if (functionMap[stringData] != null) {\r\n      result = functionMap[stringData];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function parseShortPath(counterPath) {\r\n    // eslint-disable-next-line\r\n    return decodePath(counterPath);\r\n  }\r\n\r\n  function parseOIDPath(oidPath) {\r\n    const\r\n      decodedPath = parseShortPath(oidPath),\r\n      instOID = decodedPath.obj;\r\n    let\r\n      objOID = decodedPath.cnt,\r\n      inst = decodedPath.inst,\r\n      instType,\r\n      isPerSec = (objOID.indexOf(C_PERSEC) >= 0),     //eslint-disable-line\r\n      decodedObjOID;\r\n\r\n    if (isPerSec === true) {\r\n      objOID = objOID.replace(C_PERSEC, '');\r\n    }\r\n\r\n    if ((inst === '') || (inst === '-')) {\r\n      decodedObjOID = objOID.match(/(.*)\\.([0-9]+)$/);\r\n      if (decodedObjOID.length > 1) {\r\n        objOID = decodedObjOID[1];\r\n        inst = decodedObjOID[2];\r\n      }\r\n\r\n      if (inst === '0') {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\r\n      } else {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n      }\r\n    } else if (inst.charAt(0) === '#') {\r\n      inst = inst.substr(1);\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n    } else if ((inst.charAt(0) === '_') && (displayStringToSnmpFunc(inst) !== counterConsts.SNMP_FUNC.scfUnknown)) {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\r\n    } else {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n    }\r\n\r\n    return {\r\n      objOID,\r\n      instOID,\r\n      inst,\r\n      isPerSec,\r\n      type: instType\r\n    };\r\n  }\r\n\r\n  function parseXMLPath(xmlPath, hasInstance) {\r\n    const decodedPath = parseShortPath(xmlPath);\r\n    let\r\n      inst = decodedPath.inst,\r\n      instType;\r\n\r\n    if (hasInstance === true) {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n\r\n      if (inst !== '') {\r\n        if (inst.charAt(0) === '#') {\r\n          inst = inst.substr(1);\r\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n        } else if (inst.charAt(0) === '_') {\r\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\r\n        }\r\n      } else if ((inst === '') || (inst === '-')) {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\r\n      } else {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n      }\r\n\r\n      decodedPath.inst = inst;\r\n      decodedPath.type = instType;\r\n    }\r\n\r\n    return decodedPath;\r\n  }\r\n\r\n  function parseCounterPath(counterPath) {\r\n    const counterPathType = getCounterPathType(counterPath);\r\n    let parsedCounterPath;\r\n\r\n    if (counterPathType === counterConsts.CNT_TYPE.cstXML) {\r\n      parsedCounterPath = parseXMLPath(counterPath, true);\r\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstMIB) {\r\n      parsedCounterPath = parseOIDPath(removeCounterPathType(counterPath));\r\n      parsedCounterPath.obj = parsedCounterPath.objOID;\r\n      parsedCounterPath.cnt = '';\r\n      if (parsedCounterPath.inst === '') {\r\n        parsedCounterPath.inst = parsedCounterPath.instOID;\r\n      }\r\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstSimple) {\r\n      parsedCounterPath = parseShortPath(counterPath);\r\n    }\r\n\r\n    return parsedCounterPath;\r\n  }\r\n\r\n  function getOidPath(oid, oidCache, getOidFunc) {\r\n    let updateOidPath = false;\r\n\r\n    return new Promise((resolve) => {\r\n      if (oidCache[oid] == null) {\r\n        oidCache[oid] = oid;\r\n        updateOidPath = true;\r\n      } else if (oidCache[oid] === oid) {\r\n        updateOidPath = true;\r\n      }\r\n\r\n      if (updateOidPath === true) {\r\n        getOidFunc({ oid }, (oidPath) => {\r\n          oidCache[oid] = oidPath;\r\n          resolve(oidPath);\r\n        });\r\n      } else {\r\n        resolve(oidCache[oid]);\r\n      }\r\n    });\r\n  }\r\n\r\n  function initSnmpMibData() {\r\n    if (snmpMibData == null) {\r\n      snmpMibData = new adremClient.NetCrunch.SnmpMibData('ncSrv', () => {}, netCrunchConnection);\r\n    }\r\n  }\r\n\r\n  function getShortOidPath(oid) {\r\n    initSnmpMibData();\r\n    return getOidPath(oid, shortOidPathsCache, snmpMibData.getShortOidPath);\r\n  }\r\n\r\n  function getFullOidPath(oid) {\r\n    initSnmpMibData();\r\n    return getOidPath(oid, fullOidPathsCache, snmpMibData.getFullOidPath);\r\n  }\r\n\r\n  function decodePath(path) {\r\n    const\r\n      parts = path.split(CNT_SEPARATOR),\r\n      result = {};\r\n\r\n    result.obj = parts[0];\r\n    result.cnt = parts.length > 1 ? parts[1] : '';\r\n    if (parts.length === 3) {\r\n      result.inst = parts[2];\r\n    } else if (parts.length > 3) {\r\n      result.inst = parts.slice(2).join(CNT_SEPARATOR);\r\n    } else {\r\n      result.inst = '';\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function encodePath(parts) {\r\n    const p = [parts.obj, parts.cnt];\r\n    if (parts.inst !== '') {\r\n      p.push(parts.inst);\r\n    }\r\n    return p.join(CNT_SEPARATOR);\r\n  }\r\n\r\n  function decodeDisplayPath(displayPath) {\r\n    const\r\n      result = { obj: '', cnt: '', inst: '' },\r\n      ix = displayPath.indexOf(C_PERSEC),\r\n      perSec = (ix >= 0);\r\n    let objParts;\r\n\r\n    if (perSec) {\r\n      displayPath = displayPath.substr(0, ix);\r\n    }\r\n\r\n    if (![\r\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)\\\\\\\\(.+)'), parts: ['obj', 'inst', 'cnt'] }, // obj(inst)\\cnt\r\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)'), parts: ['obj', 'inst'] }, // obj(inst)\r\n          { fmt: new RegExp('(.+)\\\\\\\\(.+)'), parts: ['obj', 'cnt'] } // obj\\cnt\r\n        ].some((s) => {                             //eslint-disable-line\r\n          const parts = displayPath.match(s.fmt);\r\n          if (parts != null) {\r\n            s.parts.forEach((p, i) => {\r\n              result[p] = parts[i + 1];\r\n            });\r\n            return true;\r\n          }\r\n          return false;\r\n        })) {\r\n      // formats do not match\r\n      result.obj = displayPath;\r\n    }\r\n    // Fix SNMP column path\r\n    if (result.cnt === '' && result.obj !== '') {\r\n      if (result.obj.match('^[0-9\\\\.]+(\\\\.[0-9]+)$')) {\r\n        result.cnt = '';\r\n        if (result.inst !== '') {\r\n          result.obj = `${result.obj}.${result.inst}`;\r\n          result.inst = '';\r\n        }\r\n      } else if (result.obj.indexOf('.') >= 0) {\r\n        objParts = result.obj.split('.');\r\n        result.cnt = objParts[1];\r\n        result.obj = objParts[0];\r\n      } else {\r\n        result.cnt = result.obj;\r\n        result.obj = '';\r\n      }\r\n    }\r\n    result.perSec = perSec;\r\n    if (perSec) {\r\n      result.cnt += C_PERSEC;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function removePerSec(displayName) {\r\n    const ix = displayName.indexOf(C_PERSEC);\r\n    // todo: check if ix == displayName.length - C_PERSEC.length\r\n    return displayName.substr(0, ix);\r\n  }\r\n\r\n  function encodeDisplayPath(parts, withPerSec) {\r\n    let\r\n      result = parts.obj,\r\n      ix;\r\n    withPerSec = (withPerSec == null) ? true : withPerSec;\r\n\r\n    if (parts.inst !== '' && parts.inst != null) {\r\n      result = `${parts.obj}(${parts.inst})`;\r\n    }\r\n\r\n    if (parts.cnt !== '' && parts.cnt != null) {\r\n      if (!withPerSec && parts.perSec) { // remove /sec from counter name\r\n        ix = parts.cnt.indexOf(C_PERSEC);\r\n        result = `${result}\\\\${parts.cnt.substr(0, ix)}`;\r\n      } else {\r\n        result = `${result}\\\\${parts.cnt}`;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function counterToString(counterPath) {\r\n    const decodedCounter = decodePath(counterPath);\r\n    return encodeDisplayPath(decodedCounter, true);\r\n  }\r\n\r\n  function makeShortPath(object, counter, instance) {\r\n    if (instance === '') {\r\n      return object + CNT_SEPARATOR + counter;\r\n    }\r\n    return object + CNT_SEPARATOR + counter + CNT_SEPARATOR + instance;\r\n  }\r\n\r\n  function getSNMPDisplayPath(counterPath, shortPath, showPerSecondValue) {\r\n    const snmpPath = parseSNMPPath(counterPath);\r\n    let\r\n      oidPath,\r\n      displayPath = Promise.resolve(null);\r\n\r\n    if (snmpPath.type === counterConsts.CNT_TYPE.cstXML) {\r\n      displayPath = Promise.resolve(counterToString(snmpPath.value));\r\n    } else if (snmpPath.type === counterConsts.CNT_TYPE.cstMIB) {\r\n      oidPath = parseOIDPath(counterPath);\r\n      if (shortPath === true) {\r\n        displayPath = getShortOidPath(oidPath.objOID);\r\n      } else {\r\n        displayPath = getFullOidPath(oidPath.objOID);\r\n      }\r\n\r\n      return displayPath\r\n        .then((resolvedPath) => {\r\n          if ((resolvedPath == null) || (resolvedPath === '')) {\r\n            resolvedPath = oidPath.objOID;\r\n          }\r\n          if (oidPath.inst === '0') {\r\n            oidPath.inst = '';\r\n          }\r\n\r\n          resolvedPath = counterToString(makeShortPath(resolvedPath, '', oidPath.inst));\r\n\r\n          if ((showPerSecondValue === true) && (oidPath.isPerSec === true)) {\r\n            resolvedPath += C_PERSEC;\r\n          }\r\n          return resolvedPath;\r\n        });\r\n    }\r\n\r\n    return displayPath;\r\n  }\r\n\r\n  function counterPathToDisplayStr(counterPath, shortPath, showPerSecValue) {\r\n    const pathType = getCounterPathType(counterPath);\r\n\r\n    if ((pathType === counterConsts.CNT_TYPE.cstXML) || (pathType === counterConsts.CNT_TYPE.cstMIB)) {\r\n      return getSNMPDisplayPath(counterPath, shortPath, showPerSecValue);\r\n    }\r\n    return Promise.resolve(counterToString(counterPath));\r\n  }\r\n\r\n  function isKnownMillisecondCounter(cnt) {\r\n    return knownMSCounters.indexOf(cnt.toLowerCase()) >= 0;\r\n  }\r\n\r\n  /**\r\n   * isMillisecondsCounter(\r\n   * @param counter\r\n   * @returns {boolean}\r\n   */\r\n  function isMillisecondsCounter(counter) {\r\n    const c = decodePath(counter);\r\n    return ((c.cnt === cnRTT) || (c.cnt === cnSCT) ||\r\n            (c.cnt.toUpperCase().indexOf('MILLISECOND') >= 0) || isKnownMillisecondCounter(c.cnt));\r\n  }\r\n\r\n  function contains(cnt, substr) {\r\n    return cnt.indexOf(substr) >= 0;\r\n  }\r\n\r\n  /**\r\n   * isBytesCounter\r\n   * @param displayName\r\n   * @returns {null|''|'M'|'K'}\r\n   */\r\n  function isBytesCounter(displayName) {\r\n    const cnt = displayName.toLowerCase();\r\n    let result = '';\r\n\r\n    if (contains(cnt, resources.metrics.bytes) || contains(cnt, resources.metrics.memory) || contains(cnt, 'octet')) {\r\n      if (contains(cnt, resources.metrics.mbytes) || contains(cnt, 'mega')) {\r\n        result = 'M';\r\n      } else if (contains(cnt, resources.metrics.kbytes) || contains(cnt, 'kilo')) {\r\n        result = 'K';\r\n      }\r\n      return result;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  function getValueFormatting(value, base1, base, units = ['K', 'M', 'G']) {\r\n    let range = '';\r\n    if (value >= 1 * base1 && value < base1 * base) {\r\n      value /= base1;\r\n      range = units[0];\r\n    } else if (value >= base1 * base && value < base1 * base * base) {\r\n      value = value / base1 / base;\r\n      range = units[1];\r\n    } else if (value >= base1 * base * base) {\r\n      value = value / base1 / base / base;\r\n      range = units[2];\r\n    }\r\n    return {\r\n      value,\r\n      units: range\r\n    };\r\n  }\r\n\r\n  function getValueRange(value, kilo) {\r\n    return getValueFormatting(value, kilo, kilo);\r\n  }\r\n\r\n  function getTimeRange(value) {\r\n    return getValueFormatting(value, 1000, 60, ['sec', 'min', 'hrs']);\r\n  }\r\n\r\n  return {\r\n    unitsToMetric: (units, counterName, counterDisplayName) => {\r\n      if (units === 'bytestobps') {\r\n        return 'bps';\r\n      } else if (units === 'percentage') {\r\n        return '%';\r\n      } else if (units === 'bytesps') {\r\n        return 'Bps';\r\n      } else if (units === 'bytes') {\r\n        return 'bytes';\r\n      }\r\n      return this.getMetric(counterName, counterDisplayName);\r\n    },\r\n\r\n    /**\r\n     * Get Metric for Counter\r\n     * @param counterPath\r\n     * @param displayName\r\n     * @returns {*}\r\n     */\r\n    getMetric: (counterPath, displayName) => {\r\n      let multiplier;\r\n      if (contains(displayName, '%')) {\r\n        return counterTypes.percentage;\r\n      } else if (!isMillisecondsCounter(counterPath)) {\r\n        multiplier = isBytesCounter(displayName);\r\n        if (multiplier !== null) {\r\n          if (multiplier !== '') {\r\n            multiplier = `'#${multiplier}`;\r\n          }\r\n          if (contains(displayName, C_PERSEC) || contains(displayName, 'per sec.')) { // ESX counters are \"per sec.\"\r\n            return counterTypes.bytesBitsPS + multiplier;\r\n          }\r\n          return counterTypes.bytes + multiplier;\r\n        }\r\n        return '';\r\n      }\r\n      return counterTypes.milliseconds;\r\n    },\r\n\r\n    getDisplayValue: (value, metric) => {\r\n      const\r\n        mparts = metric.split('#'),\r\n        m = mparts[0],\r\n        multiplier = mparts.length > 1 ? mparts[1] : '',\r\n        isBPS = (m === counterTypes.bytesBitsPS),\r\n        isBytes = (m === counterTypes.bytes) || isBPS || (m === counterTypes.bytesBps),\r\n        isMS = (m === counterTypes.milliseconds),\r\n        isNoUnits = (m === '');\r\n      let v;\r\n\r\n      if (value == null || isNaN(value)) {\r\n        return { value, units: '' };\r\n      } else {                                            //eslint-disable-line\r\n        if (isBPS) {\r\n          value *= 8;\r\n        }\r\n        if (multiplier !== '') {\r\n          return {\r\n            value: Math.round(value * 100) / 100,\r\n            units: multiplier + (isBytes ? 'B' : '')\r\n          };\r\n        }\r\n        if (isBytes) {\r\n          v = getValueRange(value, 1024);\r\n          if (m === counterTypes.bytes) {\r\n            v.units += 'B';\r\n          } else {\r\n            v.units += m;\r\n          }\r\n        } else if (isNoUnits) {\r\n          v = getValueRange(value, 1000);\r\n        } else if (isMS) {\r\n          v = getTimeRange(value);\r\n          if (v.units === '') {\r\n            v.units = counterTypes.milliseconds;\r\n          }\r\n        } else {\r\n          v = {\r\n            value,\r\n            units: m\r\n          };\r\n        }\r\n        return {\r\n          value: v.value,\r\n          units: v.units\r\n        };\r\n      }\r\n    },\r\n\r\n    isOid,\r\n    isMIBCnt,\r\n    counterPathObject,\r\n    stringToCntType,\r\n    getCounterPathType,\r\n    removeCounterPathType,\r\n    removePerSecond,\r\n    parseSNMPPath,\r\n    parseOIDPath,\r\n    parseXMLPath,\r\n    parseCounterPath,\r\n    getShortOidPath,\r\n    getFullOidPath,\r\n    decodePath,\r\n    encodePath,\r\n    addInstance: (path, inst) => {\r\n      if (inst !== '') {\r\n        return path + CNT_SEPARATOR + inst;\r\n      }\r\n      return path;\r\n    },\r\n    decodeDisplayPath,\r\n    encodeDisplayPath,\r\n    removePerSec,\r\n    getSNMPDisplayPath,\r\n    counterPathToDisplayStr\r\n  };\r\n}\r\n\r\nexport {\r\n  NETCRUNCH_COUNTER_CONST,\r\n  NETCRUNCH_COUNTER_TYPES,\r\n  NetCrunchCounters\r\n};\r\n"]}