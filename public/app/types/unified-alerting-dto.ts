// Prometheus API DTOs, possibly to be autogenerated from openapi spec in the near future

import { DataQuery, RelativeTimeRange } from '@grafana/data';
import { ExpressionQuery } from 'app/features/expressions/types';

import { AlertGroupTotals, AlertInstanceTotals } from './unified-alerting';

export type Labels = Record<string, string>;
export type Annotations = Record<string, string>;

export enum PromAlertingRuleState {
  Firing = 'firing',
  Inactive = 'inactive',
  Pending = 'pending',
  Recovering = 'recovering',
  Unknown = 'unknown',
}

export enum GrafanaAlertState {
  Normal = 'Normal',
  Alerting = 'Alerting',
  Pending = 'Pending',
  Recovering = 'Recovering',
  NoData = 'NoData',
  Error = 'Error',
}

type GrafanaAlertStateReason = ` (${string})` | '';

export type GrafanaAlertStateWithReason = `${GrafanaAlertState}${GrafanaAlertStateReason}`;

export function isPromAlertingRuleState(state: string): state is PromAlertingRuleState {
  return Object.values<string>(PromAlertingRuleState).includes(state);
}

export function isGrafanaAlertState(state: string): state is GrafanaAlertState {
  return Object.values(GrafanaAlertState).some((promState) => promState === state);
}

/** We need this to disambiguate the union PromAlertingRuleState | GrafanaAlertStateWithReason
 */
export function isAlertStateWithReason(
  state: PromAlertingRuleState | GrafanaAlertStateWithReason
): state is GrafanaAlertStateWithReason {
  const propAlertingRuleStateValues: string[] = Object.values(PromAlertingRuleState);
  return state !== null && state !== undefined && !propAlertingRuleStateValues.includes(state);
}

export function mapStateWithReasonToReason(state: GrafanaAlertStateWithReason): string {
  const match = state.match(/\((.*?)\)/);
  return match ? match[1] : '';
}

type StateWithReasonToBaseStateReturnType<T> = T extends GrafanaAlertStateWithReason
  ? GrafanaAlertState
  : T extends PromAlertingRuleState
    ? PromAlertingRuleState
    : never;

export function mapStateWithReasonToBaseState(
  state: GrafanaAlertStateWithReason | PromAlertingRuleState
): StateWithReasonToBaseStateReturnType<GrafanaAlertStateWithReason | PromAlertingRuleState> {
  if (isAlertStateWithReason(state)) {
    const fields = state.split(' ');
    return fields[0] as GrafanaAlertState;
  } else {
    return state;
  }
}

export enum PromRuleType {
  Alerting = 'alerting',
  Recording = 'recording',
}

export enum PromApplication {
  Cortex = 'Cortex',
  Mimir = 'Mimir',
  Prometheus = 'Prometheus',
  Thanos = 'Thanos',
}

export type RulesSourceApplication = PromApplication | 'Loki' | 'grafana';

export interface PromBuildInfoResponse {
  data: {
    application?: string;
    version: string;
    revision: string;
    features?: {
      ruler_config_api?: 'true' | 'false';
      alertmanager_config_api?: 'true' | 'false';
      query_sharding?: 'true' | 'false';
      federated_rules?: 'true' | 'false';
    };
    [key: string]: unknown;
  };
  status: 'success';
}

export interface PromApiFeatures {
  application: RulesSourceApplication;
  features: {
    rulerApiEnabled: boolean;
  };
}

export interface AlertmanagerApiFeatures {
  /**
   * Some Alertmanager implementations (Mimir) are multi-tenant systems.
   *
   * To save on compute costs, tenants are not active until they have a configuration set.
   * If there is no fallback_config_file set, Alertmanager endpoints will respond with HTTP 404
   *
   * Despite that, it is possible to create a configuration for such datasource
   * by posting a new config to the `/api/v1/alerts` endpoint
   */
  lazyConfigInit: boolean;
}

// ============================================
// Compact interfaces (without query field)
// These are the base types that all rule types extend
// ============================================

// Base compact - common fields for ALL prometheus-style rules
interface PromRuleCompactBase {
  health: string;
  name: string;
  evaluationTime?: number;
  lastEvaluation?: string;
  lastError?: string;
}

// Alerting rule compact - base for all alerting rules
export interface PromAlertingRuleCompact extends PromRuleCompactBase {
  type: PromRuleType.Alerting;
  state: PromAlertingRuleState;
  labels?: Labels;
  annotations?: Annotations;
  alerts?: Array<{
    labels: Labels;
    annotations: Annotations;
    state: Exclude<PromAlertingRuleState | GrafanaAlertStateWithReason, PromAlertingRuleState.Inactive>;
    activeAt: string;
    value: string;
  }>;
  duration?: number;
  notificationSettings?: GrafanaNotificationSettings;
}

// Recording rule compact - base for all recording rules
export interface PromRecordingRuleCompact extends PromRuleCompactBase {
  type: PromRuleType.Recording;
  labels?: Labels;
}

// Union of alerting and recording compact rules
export type PromRuleCompact = PromAlertingRuleCompact | PromRecordingRuleCompact;

// ============================================
// Full DTO interfaces (with query field)
// These extend the compact types and add the query field
// ============================================

// Prometheus alerting rule DTO - adds query to compact
export interface PromAlertingRuleDTO extends PromAlertingRuleCompact {
  query: string; // expr
}

// Prometheus recording rule DTO - adds query to compact
export interface PromRecordingRuleDTO extends PromRecordingRuleCompact {
  query: string; // expr
}

export type PromRuleDTO = PromAlertingRuleDTO | PromRecordingRuleDTO;

// ============================================
// Grafana-managed rule interfaces
// ============================================

// Grafana alerting rule compact - extends PromAlertingRuleCompact
export interface GrafanaPromAlertingRuleCompact extends PromAlertingRuleCompact {
  uid: string;
  folderUid: string;
  isPaused: boolean;
  queriedDatasourceUIDs?: string[];
  provenance?: string;
  totals: AlertInstanceTotals;
  totalsFiltered: AlertInstanceTotals;
}

// Grafana recording rule compact - extends PromRecordingRuleCompact
export interface GrafanaPromRecordingRuleCompact extends PromRecordingRuleCompact {
  uid: string;
  folderUid: string;
  isPaused: boolean;
  queriedDatasourceUIDs?: string[];
  provenance?: string;
}

// Union of Grafana compact rules
export type GrafanaPromRuleCompact = GrafanaPromAlertingRuleCompact | GrafanaPromRecordingRuleCompact;

// Grafana alerting rule DTO - adds optional query to compact
export interface GrafanaPromAlertingRuleDTO extends GrafanaPromAlertingRuleCompact {
  query?: string; // Optional - omitted when compact=true
}

// Grafana recording rule DTO - adds optional query to compact
export interface GrafanaPromRecordingRuleDTO extends GrafanaPromRecordingRuleCompact {
  query?: string; // Optional - omitted when compact=true
}

export type GrafanaPromRuleDTO = GrafanaPromAlertingRuleDTO | GrafanaPromRecordingRuleDTO;

// ============================================
// Rule group interfaces
// ============================================

export interface PromRuleGroupDTO<TRule = PromRuleDTO> {
  name: string;
  file: string;
  rules: TRule[];
  interval: number;

  evaluationTime?: number; // these 2 are not in older prometheus payloads
  lastEvaluation?: string;
}

export interface GrafanaPromRuleGroupDTO extends PromRuleGroupDTO<GrafanaPromRuleDTO> {
  folderUid: string;
}

export interface PromResponse<T> {
  status: 'success' | 'error' | ''; // mocks return empty string
  data: T;
  errorType?: string;
  error?: string;
  warnings?: string[];
}

export interface PromRulesResponse extends PromResponse<{ groups: PromRuleGroupDTO[]; groupNextToken?: string }> {}

export interface GrafanaPromRulesResponse
  extends PromResponse<{
    groups: GrafanaPromRuleGroupDTO[];
    groupNextToken?: string;
    totals?: AlertGroupTotals;
  }> {}

// Ruler rule DTOs
interface RulerRuleBaseDTO {
  expr: string;
  labels?: Labels;
}

export interface RulerRecordingRuleDTO extends RulerRuleBaseDTO {
  record: string;
}

export interface RulerAlertingRuleDTO extends RulerRuleBaseDTO {
  alert: string;
  for?: string;
  keep_firing_for?: string;
  annotations?: Annotations;
}

export enum GrafanaAlertStateDecision {
  Alerting = 'Alerting',
  NoData = 'NoData',
  KeepLast = 'KeepLast',
  OK = 'OK',
  Error = 'Error',
}

export interface AlertDataQuery extends DataQuery {
  maxDataPoints?: number;
  intervalMs?: number;
  expression?: string;
  instant?: boolean;
  range?: boolean;
}

export interface AlertQuery<T = AlertDataQuery | ExpressionQuery> {
  refId: string;
  queryType: string;
  relativeTimeRange?: RelativeTimeRange;
  datasourceUid: string;
  model: T;
}

export interface GrafanaNotificationSettings {
  receiver: string;
  group_by?: string[];
  group_wait?: string;
  group_interval?: string;
  repeat_interval?: string;
  mute_time_intervals?: string[];
  active_time_intervals?: string[];
}

export interface GrafanaEditorSettings {
  simplified_query_and_expressions_section: boolean;
  simplified_notifications_section: boolean;
}

export interface UpdatedBy {
  uid: string;
  name: string;
}
export interface PostableGrafanaRuleDefinition {
  uid?: string;
  title: string;
  condition: string;
  no_data_state?: GrafanaAlertStateDecision;
  exec_err_state?: GrafanaAlertStateDecision;
  data: AlertQuery[];
  is_paused?: boolean;
  notification_settings?: GrafanaNotificationSettings;
  metadata?: {
    editor_settings?: GrafanaEditorSettings;
  };
  record?: {
    metric: string;
    from: string;
    target_datasource_uid?: string;
  };
  intervalSeconds?: number;
  missing_series_evals_to_resolve?: number;
}
export interface GrafanaRuleDefinition extends PostableGrafanaRuleDefinition {
  id?: string;
  uid: string;
  guid?: string;
  namespace_uid: string;
  rule_group: string;
  provenance?: string;
  // TODO: For updated_by, updated, and version, fix types so these aren't optional, and
  // are not conflated with test fixtures
  updated?: string;
  updated_by?: UpdatedBy | null;
  version?: number;
  message?: string;
}

// types for Grafana-managed recording and alerting rules
export type GrafanaAlertingRuleDefinition = Omit<GrafanaRuleDefinition, 'record'>;
export type GrafanaRecordingRuleDefinition = GrafanaRuleDefinition & {
  record: GrafanaRuleDefinition['record'];
};

export interface RulerGrafanaRuleDTO<T = GrafanaRuleDefinition> {
  grafana_alert: T;
  for?: string;
  keep_firing_for?: string;
  annotations?: Annotations;
  labels?: Labels;
}

export type TopLevelGrafanaRuleDTOField = keyof Omit<RulerGrafanaRuleDTO, 'grafana_alert'>;
export type GrafanaAlertRuleDTOField = keyof GrafanaRuleDefinition;

export type PostableRuleGrafanaRuleDTO = RulerGrafanaRuleDTO<PostableGrafanaRuleDefinition>;

export type RulerCloudRuleDTO = RulerAlertingRuleDTO | RulerRecordingRuleDTO;

export type RulerRuleDTO =
  | RulerCloudRuleDTO
  | RulerGrafanaRuleDTO<GrafanaAlertingRuleDefinition>
  | RulerGrafanaRuleDTO<GrafanaRecordingRuleDefinition>;
export type PostableRuleDTO = RulerCloudRuleDTO | PostableRuleGrafanaRuleDTO;

export type RulerRuleGroupDTO<R = RulerRuleDTO> = {
  name: string;
  interval?: string;
  source_tenants?: string[];
  rules: R[];
};

export type PostableRulerRuleGroupDTO = RulerRuleGroupDTO<PostableRuleDTO>;

export type RulerGrafanaRuleGroupDTO = RulerRuleGroupDTO<RulerGrafanaRuleDTO>;

export type RulerRulesConfigDTO = { [namespace: string]: RulerRuleGroupDTO[] };

export type RulerGrafanaRulesConfigDTO = { [namespace: string]: RulerGrafanaRuleGroupDTO[] };
