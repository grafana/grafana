import { AnnotationEvent, DataFrame, toDataFrame } from '@grafana/data';
import { config, getBackendSrv } from '@grafana/runtime';
import { StateHistoryItem } from 'app/types/unified-alerting';

import { getAPINamespace } from '../../api/utils';
import { ScopedResourceClient } from '../apiserver/client';
import type { Resource, ResourceForCreate, ListOptions } from '../apiserver/types';

import { AnnotationTagsResponse } from './types';

export interface AnnotationServer {
  query(params: Record<string, unknown>, requestId: string): Promise<DataFrame>;
  forAlert(alertUID: string): Promise<StateHistoryItem[]>;
  save(annotation: AnnotationEvent): Promise<AnnotationEvent>;
  update(annotation: AnnotationEvent): Promise<unknown>;
  delete(annotation: AnnotationEvent): Promise<unknown>;
  tags(): Promise<Array<{ term: string; count: number }>>;
}

class LegacyAnnotationServer implements AnnotationServer {
  query(params: unknown, requestId: string): Promise<DataFrame> {
    return getBackendSrv()
      .get('/api/annotations', params, requestId)
      .then((v) => toDataFrame(v));
  }

  forAlert(alertUID: string) {
    return getBackendSrv().get('/api/annotations', {
      alertUID,
    });
  }

  save(annotation: AnnotationEvent) {
    return getBackendSrv().post('/api/annotations', annotation);
  }

  update(annotation: AnnotationEvent) {
    return getBackendSrv().put(`/api/annotations/${annotation.id}`, annotation);
  }

  delete(annotation: AnnotationEvent) {
    return getBackendSrv().delete(`/api/annotations/${annotation.id}`);
  }

  async tags() {
    const response = await getBackendSrv().get<AnnotationTagsResponse>('/api/annotations/tags?limit=1000');
    return response.result.tags.map(({ tag, count }) => ({
      term: tag,
      count,
    }));
  }
}

// K8s-style annotation spec based on the CUE definition
interface K8sAnnotationSpec {
  text: string;
  time: number;
  timeEnd?: number;
  dashboardUID?: string;
  panelID?: number;
  tags?: string[];
}

interface K8sAnnotationTagsResponse {
  tags: Array<{ tag: string; count: number }>;
}

const K8S_ANNOTATION_API_CONFIG = {
  group: 'annotation.grafana.app',
  version: 'v0alpha1',
  resource: 'annotations',
};

class K8sAnnotationServer implements AnnotationServer {
  private client: ScopedResourceClient<K8sAnnotationSpec>;

  constructor() {
    this.client = new ScopedResourceClient<K8sAnnotationSpec>(K8S_ANNOTATION_API_CONFIG);
  }

  async query(params: Record<string, unknown>, requestId: string): Promise<DataFrame> {
    const listOpts: ListOptions = {};

    if (params.limit) {
      listOpts.limit = Number(params.limit);
    }

    const fieldSelectors: string[] = [];

    if (params.dashboardUID) {
      fieldSelectors.push(`spec.dashboardUID=${params.dashboardUID}`);
    }

    if (params.panelId) {
      fieldSelectors.push(`spec.panelID=${params.panelId}`);
    }

    if (params.from) {
      fieldSelectors.push(`spec.time=${params.from}`);
    }

    if (params.to) {
      fieldSelectors.push(`spec.timeEnd=${params.to}`);
    }

    if (fieldSelectors.length > 0) {
      listOpts.fieldSelector = fieldSelectors.join(',');
    }

    const result = await this.client.list(listOpts);

    let annotations = result.items.map((item: Resource<K8sAnnotationSpec>) => ({
      id: item.metadata.name,
      ...item.spec,
      panelId: item.spec.panelID,
    }));

    // Client-side tag filtering (tags are not in SelectableFields since they're in an array)
    if (params.tags && Array.isArray(params.tags) && params.tags.length > 0) {
      const tags = params.tags;
      annotations = annotations.filter((anno) => {
        if (!anno.tags || anno.tags.length === 0) {
          return false;
        }
        return tags.every((tag) => anno.tags!.includes(tag));
      });
    }
    return toDataFrame(annotations);
  }

  async forAlert(alertUID: string): Promise<StateHistoryItem[]> {
    // For now, we filter client-side since label selector support for alertUID may not be implemented
    const result = await this.client.list({
      limit: 1000,
    });

    // Filter by tags that contain the alertUID
    // Alert annotations typically have the alert UID in their tags
    return result.items
      .filter((item: Resource<K8sAnnotationSpec>) => {
        // Check if any tag contains the alertUID
        return item.spec.tags?.some((tag) => tag.includes(alertUID));
      })
      .map((item: Resource<K8sAnnotationSpec>) => ({
        id: item.metadata.name,
        ...item.spec,
        panelId: item.spec.panelID,
      })) as any;
  }

  async save(annotation: AnnotationEvent): Promise<AnnotationEvent> {
    const resource: ResourceForCreate<K8sAnnotationSpec> = {
      metadata: {
        name: '', // Will be auto-generated by the server
      },
      spec: {
        text: annotation.text || '',
        time: annotation.time || Date.now(),
        timeEnd: annotation.timeEnd,
        dashboardUID: annotation.dashboardUID ?? undefined,
        panelID: annotation.panelId,
        tags: annotation.tags,
      },
    };

    const result = await this.client.create(resource);

    return {
      ...annotation,
      id: result.metadata.name,
      ...result.spec,
      panelId: result.spec.panelID,
    };
  }

  async update(annotation: AnnotationEvent): Promise<unknown> {
    if (!annotation.id) {
      throw new Error('Annotation ID is required for update');
    }

    // Get the existing resource to preserve metadata (especially resourceVersion)
    const existing = await this.client.get(String(annotation.id));

    // Update only the spec fields, preserve all metadata
    const updated: Resource<K8sAnnotationSpec> = {
      apiVersion: existing.apiVersion,
      kind: existing.kind,
      metadata: {
        ...existing.metadata,
        // Preserve critical metadata fields for update
      },
      spec: {
        text: annotation.text !== undefined ? annotation.text : existing.spec.text,
        time: annotation.time !== undefined ? annotation.time : existing.spec.time,
        timeEnd: annotation.timeEnd !== undefined ? annotation.timeEnd : existing.spec.timeEnd,
        dashboardUID:
          annotation.dashboardUID !== undefined && annotation.dashboardUID !== null
            ? annotation.dashboardUID
            : existing.spec.dashboardUID,
        panelID: annotation.panelId !== undefined ? annotation.panelId : existing.spec.panelID,
        tags: annotation.tags !== undefined ? annotation.tags : existing.spec.tags,
      },
    };

    return this.client.update(updated);
  }

  async delete(annotation: AnnotationEvent): Promise<unknown> {
    if (!annotation.id) {
      throw new Error('Annotation ID is required for delete');
    }
    return this.client.delete(String(annotation.id), false);
  }

  async tags(): Promise<Array<{ term: string; count: number }>> {
    // Use the custom /tags route defined in the CUE manifest
    const namespace = getAPINamespace();
    const url = `/apis/${K8S_ANNOTATION_API_CONFIG.group}/${K8S_ANNOTATION_API_CONFIG.version}/namespaces/${namespace}/tags`;

    const response = await getBackendSrv().get<K8sAnnotationTagsResponse>(url, { limit: 1000 });

    return response.tags.map(({ tag, count }) => ({
      term: tag,
      count,
    }));
  }
}

let instance: AnnotationServer | null = null;

export function annotationServer(): AnnotationServer {
  if (!instance) {
    if (config.featureToggles.kubernetesAnnotations) {
      instance = new K8sAnnotationServer();
    } else {
      instance = new LegacyAnnotationServer();
    }
  }
  return instance;
}
