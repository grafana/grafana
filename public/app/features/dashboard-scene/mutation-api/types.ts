/**
 * Dashboard Mutation API - Core Types
 *
 * This module defines the types for the MCP-based dashboard mutation API.
 * It provides a standardized interface for programmatic dashboard modifications.
 */

/**
 * Import v2 schema types - these are the source of truth.
 *
 * The mutation API uses these types directly to ensure compatibility with the dashboard schema.
 * No custom payload types are created - we use schema types with Omit for auto-generated fields.
 */
import type {
  // Panel types
  PanelSpec,
  DataLink,
  // Variable types
  VariableKind,
  // Layout types
  GridLayoutItemSpec,
  RowsLayoutRowSpec,
  TabsLayoutTabSpec,
  AutoGridLayoutSpec,
  RepeatOptions,
  ConditionalRenderingGroupSpec,
  // Annotation types
  AnnotationQuerySpec,
  // Dashboard types
  DashboardLink,
  TimeSettingsSpec,
  // Field config types
  DynamicConfigValue,
  MatcherConfig,
  ValueMapping,
  DataTransformerConfig,
} from '@grafana/schema/src/schema/dashboard/v2beta1/types.spec.gen';

// ============================================================================
// Mutation Types
// ============================================================================

export type MutationType =
  // Panel operations
  | 'ADD_PANEL'
  | 'REMOVE_PANEL'
  | 'UPDATE_PANEL'
  | 'MOVE_PANEL'
  | 'DUPLICATE_PANEL'
  // Variable operations
  | 'ADD_VARIABLE'
  | 'REMOVE_VARIABLE'
  | 'UPDATE_VARIABLE'
  // Row operations
  | 'ADD_ROW'
  | 'REMOVE_ROW'
  | 'COLLAPSE_ROW'
  // Tab operations
  | 'ADD_TAB'
  | 'REMOVE_TAB'
  // Library panel operations
  | 'ADD_LIBRARY_PANEL'
  | 'UNLINK_LIBRARY_PANEL'
  | 'SAVE_AS_LIBRARY_PANEL'
  // Repeat configuration
  | 'CONFIGURE_PANEL_REPEAT'
  | 'CONFIGURE_ROW_REPEAT'
  // Conditional rendering
  | 'SET_CONDITIONAL_RENDERING'
  // Layout
  | 'CHANGE_LAYOUT_TYPE'
  // Annotation operations
  | 'ADD_ANNOTATION'
  | 'UPDATE_ANNOTATION'
  | 'REMOVE_ANNOTATION'
  // Link operations
  | 'ADD_DASHBOARD_LINK'
  | 'REMOVE_DASHBOARD_LINK'
  | 'ADD_PANEL_LINK'
  | 'ADD_DATA_LINK'
  // Field configuration
  | 'ADD_FIELD_OVERRIDE'
  | 'ADD_VALUE_MAPPING'
  | 'ADD_TRANSFORMATION'
  // Dashboard settings
  | 'UPDATE_TIME_SETTINGS'
  | 'UPDATE_DASHBOARD_META'
  // Dashboard management (backend)
  | 'MOVE_TO_FOLDER'
  | 'TOGGLE_FAVORITE'
  // Version management (backend)
  | 'LIST_VERSIONS'
  | 'COMPARE_VERSIONS'
  | 'RESTORE_VERSION'
  // Read-only operations
  | 'GET_DASHBOARD_INFO';

// ============================================================================
// Mutation Payloads
// ============================================================================

/**
 * Payload for adding a panel.
 *
 * Uses Partial<PanelSpec> so callers can provide just the fields they care about.
 * Missing fields are filled with sensible defaults (title defaults to "New Panel", etc.)
 * The `id` field is always auto-generated by the system.
 *
 * Minimal example: { title: "My Panel" }
 * Full example: { title: "My Panel", description: "...", vizConfig: {...}, data: {...} }
 */
export interface AddPanelPayload {
  /** Panel title (required for meaningful panels) */
  title?: string;
  /** Visualization type shorthand (e.g., "timeseries", "stat", "table") */
  vizType?: string;
  /** Panel description */
  description?: string;
  /** Full panel spec - for advanced use cases. Fields here override top-level fields. */
  spec?: Partial<Omit<PanelSpec, 'id'>>;
  /** Position in the layout */
  position?: LayoutPosition;
}

export interface RemovePanelPayload {
  /** Element name in the elements map */
  elementName?: string;
  /** Alternative: Panel ID */
  panelId?: number;
}

export interface UpdatePanelPayload {
  /** Element name or panel ID to update */
  elementName?: string;
  panelId?: number;
  /** Updates to apply - partial PanelSpec (id cannot be changed) */
  updates: Partial<Omit<PanelSpec, 'id'>>;
}

export interface MovePanelPayload {
  /** Element name to move */
  elementName: string;
  /** Target position */
  targetPosition: LayoutPosition;
}

export interface DuplicatePanelPayload {
  /** Element name to duplicate */
  elementName: string;
  /** New title (optional, defaults to "Copy of {original}") */
  newTitle?: string;
}

/**
 * Payload for adding a variable.
 * Uses VariableKind from schema directly - the union of all variable types.
 */
export interface AddVariablePayload {
  /** The complete variable definition from v2 schema */
  variable: VariableKind;
  /** Position in the variables array (optional, appends if not specified) */
  position?: number;
}

export interface RemoveVariablePayload {
  /** Variable name to remove */
  name: string;
}

export interface UpdateVariablePayload {
  /** Variable name to update */
  name: string;
  /** The updated variable definition - replaces the existing one */
  variable: VariableKind;
}

/**
 * Payload for adding a row.
 * Uses RowsLayoutRowSpec from schema, but layout is optional (created empty).
 */
export interface AddRowPayload {
  /** Row spec - uses schema type. Layout is created empty if not provided. */
  spec: Omit<RowsLayoutRowSpec, 'layout'> & {
    layout?: RowsLayoutRowSpec['layout'];
  };
  /** Position index (0 = first) */
  position?: number;
}

export interface RemoveRowPayload {
  /** Row title or index to identify the row */
  rowTitle?: string;
  rowIndex?: number;
  /** What to do with panels in the row */
  panelHandling?: 'delete' | 'moveToRoot';
}

export interface CollapseRowPayload {
  /** Row title or index to identify the row */
  rowTitle?: string;
  rowIndex?: number;
  /** Whether to collapse or expand */
  collapsed: boolean;
}

/**
 * Payload for updating time settings.
 * Uses TimeSettingsSpec from schema.
 */
export type UpdateTimeSettingsPayload = Partial<TimeSettingsSpec>;

/**
 * Payload for updating dashboard metadata.
 * These are top-level DashboardV2Spec fields.
 */
export interface UpdateDashboardMetaPayload {
  title?: string;
  description?: string;
  tags?: string[];
  editable?: boolean;
  preload?: boolean;
  liveNow?: boolean;
}

// ============================================================================
// Supporting Types - derived from schema types
// ============================================================================

/**
 * Layout position for placing elements.
 * Combines GridLayoutItemSpec position fields with container targeting.
 */
export type LayoutPosition = Pick<GridLayoutItemSpec, 'x' | 'y' | 'width' | 'height' | 'repeat'> & {
  /** Target row title (for RowsLayout) */
  targetRow?: string;
  /** Target tab title (for TabsLayout) */
  targetTab?: string;
};

// ============================================================================
// Mutation Definition
// ============================================================================

export interface Mutation<T extends MutationType = MutationType> {
  type: T;
  payload: MutationPayloadMap[T];
}

export interface MutationPayloadMap {
  // Panel operations
  ADD_PANEL: AddPanelPayload;
  REMOVE_PANEL: RemovePanelPayload;
  UPDATE_PANEL: UpdatePanelPayload;
  MOVE_PANEL: MovePanelPayload;
  DUPLICATE_PANEL: DuplicatePanelPayload;

  // Variable operations
  ADD_VARIABLE: AddVariablePayload;
  REMOVE_VARIABLE: RemoveVariablePayload;
  UPDATE_VARIABLE: UpdateVariablePayload;

  // Row operations
  ADD_ROW: AddRowPayload;
  REMOVE_ROW: RemoveRowPayload;
  COLLAPSE_ROW: CollapseRowPayload;

  // Tab operations - uses TabsLayoutTabSpec from schema
  ADD_TAB: {
    spec: Omit<TabsLayoutTabSpec, 'layout'> & { layout?: TabsLayoutTabSpec['layout'] };
    position?: number;
  };
  REMOVE_TAB: { tabTitle?: string; tabIndex?: number; panelHandling?: 'delete' | 'moveToRoot' };

  // Library panel operations
  ADD_LIBRARY_PANEL: { libraryPanelUid?: string; libraryPanelName?: string; position?: LayoutPosition };
  UNLINK_LIBRARY_PANEL: { elementName: string };
  SAVE_AS_LIBRARY_PANEL: { elementName: string; libraryPanelName: string; folderUid?: string };

  // Repeat configuration - uses RepeatOptions from schema
  CONFIGURE_PANEL_REPEAT: { elementName: string; repeat: RepeatOptions | null };
  CONFIGURE_ROW_REPEAT: { rowTitle?: string; rowIndex?: number; repeat: RowsLayoutRowSpec['repeat'] | null };

  // Conditional rendering - uses ConditionalRenderingGroupSpec from schema
  SET_CONDITIONAL_RENDERING: {
    elementName: string;
    conditionalRendering: ConditionalRenderingGroupSpec | null;
  };

  // Layout - uses AutoGridLayoutSpec for options
  CHANGE_LAYOUT_TYPE: {
    layoutType: 'GridLayout' | 'RowsLayout' | 'AutoGridLayout' | 'TabsLayout';
    options?: Partial<AutoGridLayoutSpec>;
  };

  // Annotation operations - uses AnnotationQuerySpec from schema
  ADD_ANNOTATION: Omit<AnnotationQuerySpec, 'query'> & { query?: AnnotationQuerySpec['query'] };
  UPDATE_ANNOTATION: { name: string; updates: Partial<AnnotationQuerySpec> };
  REMOVE_ANNOTATION: { name: string };

  // Link operations - uses DashboardLink from schema
  ADD_DASHBOARD_LINK: DashboardLink;
  REMOVE_DASHBOARD_LINK: { title?: string; index?: number };

  // Panel link operations - uses DataLink from schema
  ADD_PANEL_LINK: { elementName: string; link: DataLink };
  ADD_DATA_LINK: { elementName: string; link: DataLink };

  // Field configuration - uses schema types
  ADD_FIELD_OVERRIDE: {
    elementName: string;
    matcher: MatcherConfig;
    properties: DynamicConfigValue[];
  };
  ADD_VALUE_MAPPING: { elementName: string; mapping: ValueMapping };
  ADD_TRANSFORMATION: { elementName: string; transformation: Omit<DataTransformerConfig, 'id'> & { id: string } };

  // Dashboard settings
  UPDATE_TIME_SETTINGS: UpdateTimeSettingsPayload;
  UPDATE_DASHBOARD_META: UpdateDashboardMetaPayload;

  // Dashboard management (backend)
  MOVE_TO_FOLDER: { folderUid?: string; folderTitle?: string };
  TOGGLE_FAVORITE: { favorite: boolean };

  // Version management (backend)
  LIST_VERSIONS: { limit?: number };
  COMPARE_VERSIONS: { baseVersion: number; newVersion: number };
  RESTORE_VERSION: { version: number };

  // Read-only operations (no payload required)
  GET_DASHBOARD_INFO: Record<string, never>;
}

// ============================================================================
// Mutation Result
// ============================================================================

export interface MutationResult {
  success: boolean;
  /** Mutation to apply to undo this change */
  inverseMutation?: Mutation;
  /** Changes that were applied */
  changes: MutationChange[];
  /** Error message if failed */
  error?: string;
  /** Warnings (non-fatal issues) */
  warnings?: string[];
  /** Data returned by read-only operations (e.g., GET_DASHBOARD_INFO) */
  data?: unknown;
}

export interface MutationChange {
  path: string;
  previousValue: unknown;
  newValue: unknown;
}

// ============================================================================
// Transaction
// ============================================================================

export interface MutationTransaction {
  id: string;
  mutations: Mutation[];
  status: 'pending' | 'committed' | 'rolled_back';
  startedAt: number;
  completedAt?: number;
}

// ============================================================================
// Event Types
// ============================================================================

export interface MutationEvent {
  type: 'mutation_applied' | 'mutation_failed' | 'mutation_rolled_back';
  mutation: Mutation;
  result: MutationResult;
  transaction?: MutationTransaction;
  timestamp: number;
  source: 'assistant' | 'ui' | 'api';
}

// ============================================================================
// MCP Tool Types
// ============================================================================

export interface MCPToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, unknown>;
    required?: string[];
  };
  annotations?: {
    title?: string;
    readOnlyHint?: boolean;
    destructiveHint?: boolean;
    idempotentHint?: boolean;
    confirmationHint?: boolean;
  };
}

export interface MCPResourceDefinition {
  uri: string;
  uriTemplate?: boolean;
  name: string;
  description: string;
  mimeType: string;
}

export interface MCPPromptDefinition {
  name: string;
  description: string;
  arguments: Array<{
    name: string;
    description: string;
    required: boolean;
  }>;
}
