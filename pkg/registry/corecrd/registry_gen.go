// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by:
//     kinds/gen.go
// Using jennies:
//     CRDKindRegistryJenny
//
// Run 'make gen-cue' from repository root to regenerate.

package corecrd

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/grafana/grafana/pkg/registry/corekind"
	"github.com/grafana/grafana/pkg/services/k8s/client"
	"github.com/grafana/grafana/pkg/services/k8s/crd"
	"github.com/grafana/grafana/pkg/services/k8s/informer"
	"github.com/grafana/grafana/pkg/services/k8s/resources/dashboard"
	"github.com/grafana/grafana/pkg/services/k8s/resources/librarypanel"
	"github.com/grafana/grafana/pkg/services/k8s/resources/playlist"
	"github.com/grafana/grafana/pkg/services/k8s/resources/preferences"
	"github.com/grafana/grafana/pkg/services/k8s/resources/publicdashboard"
	"github.com/grafana/grafana/pkg/services/k8s/resources/serviceaccount"
	"github.com/grafana/grafana/pkg/services/k8s/resources/team"
	"github.com/grafana/thema"
	"gopkg.in/yaml.v3"
)

// New constructs a new [Registry].
//
// All calling code within grafana/grafana is expected to use Grafana's
// singleton [thema.Runtime], returned from [cuectx.GrafanaThemaRuntime]. If nil
// is passed, the singleton will be used.
func New(
	rt *thema.Runtime,
	clientSet *client.Clientset,
	informerFactory *informer.Factory,
	dashboardWatcher dashboard.Watcher,
	librarypanelWatcher librarypanel.Watcher,
	playlistWatcher playlist.Watcher,
	preferencesWatcher preferences.Watcher,
	publicdashboardWatcher publicdashboard.Watcher,
	serviceaccountWatcher serviceaccount.Watcher,
	teamWatcher team.Watcher,
) *Registry {
	breg := corekind.NewBase(rt)
	return doNewRegistry(
		breg,
		clientSet,
		informerFactory,
		dashboardWatcher,
		librarypanelWatcher,
		playlistWatcher,
		preferencesWatcher,
		publicdashboardWatcher,
		serviceaccountWatcher,
		teamWatcher,
	)
}

// All returns a slice of all core Grafana CRDs in the registry.
//
// The returned slice is guaranteed to be alphabetically sorted by kind name.
func (r *Registry) All() []crd.Kind {
	all := make([]crd.Kind, len(r.all))
	copy(all, r.all[:])
	return all
}

// Registry is a list of all of Grafana's core structured kinds, wrapped in a
// standard [crd.CRD] interface that makes them usable for interactions
// with certain Kubernetes controller and apimachinery libraries.
//
// There are two access methods: individually via literal named methods, or as
// a slice returned from All() method.
//
// Prefer the individual named methods for use cases where the particular kind(s)
// that are needed are known to the caller. Prefer All() when performing operations
// generically across all kinds.
type Registry struct {
	all [7]crd.Kind
}

// Dashboard returns the [crd.Kind] instance for the Dashboard kind.
func (r *Registry) Dashboard() crd.Kind {
	return r.all[0]
}

// LibraryPanel returns the [crd.Kind] instance for the LibraryPanel kind.
func (r *Registry) LibraryPanel() crd.Kind {
	return r.all[1]
}

// Playlist returns the [crd.Kind] instance for the Playlist kind.
func (r *Registry) Playlist() crd.Kind {
	return r.all[2]
}

// Preferences returns the [crd.Kind] instance for the Preferences kind.
func (r *Registry) Preferences() crd.Kind {
	return r.all[3]
}

// PublicDashboard returns the [crd.Kind] instance for the PublicDashboard kind.
func (r *Registry) PublicDashboard() crd.Kind {
	return r.all[4]
}

// ServiceAccount returns the [crd.Kind] instance for the ServiceAccount kind.
func (r *Registry) ServiceAccount() crd.Kind {
	return r.all[5]
}

// Team returns the [crd.Kind] instance for the Team kind.
func (r *Registry) Team() crd.Kind {
	return r.all[6]
}

func doNewRegistry(
	breg *corekind.Base,
	clientset *client.Clientset,
	informerFactory *informer.Factory,
	dashboardWatcher dashboard.Watcher,
	librarypanelWatcher librarypanel.Watcher,
	playlistWatcher playlist.Watcher,
	preferencesWatcher preferences.Watcher,
	publicdashboardWatcher publicdashboard.Watcher,
	serviceaccountWatcher serviceaccount.Watcher,
	teamWatcher team.Watcher,
) *Registry {
	var (
		err error
		b   []byte
		reg = &Registry{}
		ctx = context.Background()
	)

	/************************ Dashboard ************************/
	err = clientset.RegisterKind(ctx, dashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Dashboard failed to register: %s", err))
	}

	resourceClient0, err := clientset.GetResourceClient(dashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Dashboard failed to get resource client: %s", err))
	}

	watcherWrapper0 := dashboard.NewWatcherWrapper(dashboardWatcher)
	watcher0, err := informer.NewWatcherWithClient(resourceClient0, dashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Dashboard failed to create watcher: %s", err))
	}
	watcher0.Wrap(watcherWrapper0, true)
	informerFactory.AddWatcher(dashboard.CRD, watcher0)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map0 := make(map[string]any)
	err = yaml.Unmarshal(dashboard.CRDYaml, map0)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Dashboard failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map0)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Dashboard: %s", err))
	}
	err = json.Unmarshal(b, &dashboard.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Dashboard: %s", err))
	}
	reg.all[0] = dashboard.CRD

	/************************ LibraryPanel ************************/
	err = clientset.RegisterKind(ctx, librarypanel.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for LibraryPanel failed to register: %s", err))
	}

	resourceClient1, err := clientset.GetResourceClient(librarypanel.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for LibraryPanel failed to get resource client: %s", err))
	}

	watcherWrapper1 := librarypanel.NewWatcherWrapper(librarypanelWatcher)
	watcher1, err := informer.NewWatcherWithClient(resourceClient1, librarypanel.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for LibraryPanel failed to create watcher: %s", err))
	}
	watcher1.Wrap(watcherWrapper1, true)
	informerFactory.AddWatcher(librarypanel.CRD, watcher1)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map1 := make(map[string]any)
	err = yaml.Unmarshal(librarypanel.CRDYaml, map1)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for LibraryPanel failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map1)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for LibraryPanel: %s", err))
	}
	err = json.Unmarshal(b, &librarypanel.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for LibraryPanel: %s", err))
	}
	reg.all[1] = librarypanel.CRD

	/************************ Playlist ************************/
	err = clientset.RegisterKind(ctx, playlist.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Playlist failed to register: %s", err))
	}

	resourceClient2, err := clientset.GetResourceClient(playlist.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Playlist failed to get resource client: %s", err))
	}

	watcherWrapper2 := playlist.NewWatcherWrapper(playlistWatcher)
	watcher2, err := informer.NewWatcherWithClient(resourceClient2, playlist.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Playlist failed to create watcher: %s", err))
	}
	watcher2.Wrap(watcherWrapper2, true)
	informerFactory.AddWatcher(playlist.CRD, watcher2)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map2 := make(map[string]any)
	err = yaml.Unmarshal(playlist.CRDYaml, map2)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Playlist failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map2)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Playlist: %s", err))
	}
	err = json.Unmarshal(b, &playlist.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Playlist: %s", err))
	}
	reg.all[2] = playlist.CRD

	/************************ Preferences ************************/
	err = clientset.RegisterKind(ctx, preferences.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Preferences failed to register: %s", err))
	}

	resourceClient3, err := clientset.GetResourceClient(preferences.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Preferences failed to get resource client: %s", err))
	}

	watcherWrapper3 := preferences.NewWatcherWrapper(preferencesWatcher)
	watcher3, err := informer.NewWatcherWithClient(resourceClient3, preferences.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Preferences failed to create watcher: %s", err))
	}
	watcher3.Wrap(watcherWrapper3, true)
	informerFactory.AddWatcher(preferences.CRD, watcher3)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map3 := make(map[string]any)
	err = yaml.Unmarshal(preferences.CRDYaml, map3)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Preferences failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map3)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Preferences: %s", err))
	}
	err = json.Unmarshal(b, &preferences.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Preferences: %s", err))
	}
	reg.all[3] = preferences.CRD

	/************************ PublicDashboard ************************/
	err = clientset.RegisterKind(ctx, publicdashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for PublicDashboard failed to register: %s", err))
	}

	resourceClient4, err := clientset.GetResourceClient(publicdashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for PublicDashboard failed to get resource client: %s", err))
	}

	watcherWrapper4 := publicdashboard.NewWatcherWrapper(publicdashboardWatcher)
	watcher4, err := informer.NewWatcherWithClient(resourceClient4, publicdashboard.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for PublicDashboard failed to create watcher: %s", err))
	}
	watcher4.Wrap(watcherWrapper4, true)
	informerFactory.AddWatcher(publicdashboard.CRD, watcher4)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map4 := make(map[string]any)
	err = yaml.Unmarshal(publicdashboard.CRDYaml, map4)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for PublicDashboard failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map4)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for PublicDashboard: %s", err))
	}
	err = json.Unmarshal(b, &publicdashboard.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for PublicDashboard: %s", err))
	}
	reg.all[4] = publicdashboard.CRD

	/************************ ServiceAccount ************************/
	err = clientset.RegisterKind(ctx, serviceaccount.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for ServiceAccount failed to register: %s", err))
	}

	resourceClient5, err := clientset.GetResourceClient(serviceaccount.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for ServiceAccount failed to get resource client: %s", err))
	}

	watcherWrapper5 := serviceaccount.NewWatcherWrapper(serviceaccountWatcher)
	watcher5, err := informer.NewWatcherWithClient(resourceClient5, serviceaccount.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for ServiceAccount failed to create watcher: %s", err))
	}
	watcher5.Wrap(watcherWrapper5, true)
	informerFactory.AddWatcher(serviceaccount.CRD, watcher5)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map5 := make(map[string]any)
	err = yaml.Unmarshal(serviceaccount.CRDYaml, map5)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for ServiceAccount failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map5)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for ServiceAccount: %s", err))
	}
	err = json.Unmarshal(b, &serviceaccount.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for ServiceAccount: %s", err))
	}
	reg.all[5] = serviceaccount.CRD

	/************************ Team ************************/
	err = clientset.RegisterKind(ctx, team.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Team failed to register: %s", err))
	}

	resourceClient6, err := clientset.GetResourceClient(team.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Team failed to get resource client: %s", err))
	}

	watcherWrapper6 := team.NewWatcherWrapper(teamWatcher)
	watcher6, err := informer.NewWatcherWithClient(resourceClient6, team.CRD)
	if err != nil {
		panic(fmt.Sprintf("generated CRD for Team failed to create watcher: %s", err))
	}
	watcher6.Wrap(watcherWrapper6, true)
	informerFactory.AddWatcher(team.CRD, watcher6)

	// TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
	map6 := make(map[string]any)
	err = yaml.Unmarshal(team.CRDYaml, map6)
	if err != nil {
		panic(fmt.Sprintf("generated CRD YAML for Team failed to unmarshal: %s", err))
	}
	b, err = json.Marshal(map6)
	if err != nil {
		panic(fmt.Sprintf("could not re-marshal CRD JSON for Team: %s", err))
	}
	err = json.Unmarshal(b, &team.CRD.Schema)
	if err != nil {
		panic(fmt.Sprintf("could not unmarshal CRD JSON for Team: %s", err))
	}
	reg.all[6] = team.CRD

	return reg
}
