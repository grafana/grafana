package imguploader

import (
	"context"
	"os"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/feature/s3/manager"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	s3types "github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/grafana/grafana/pkg/infra/log"
	"github.com/grafana/grafana/pkg/util"
)

type S3Uploader struct {
	endpoint        string
	region          string
	bucket          string
	path            string
	acl             string
	secretKey       string
	accessKey       string
	pathStyleAccess bool
	log             log.Logger
}

func NewS3Uploader(endpoint, region, bucket, path, acl, accessKey, secretKey string, pathStyleAccess bool) *S3Uploader {
	return &S3Uploader{
		endpoint:        endpoint,
		region:          region,
		bucket:          bucket,
		path:            path,
		acl:             acl,
		accessKey:       accessKey,
		secretKey:       secretKey,
		pathStyleAccess: pathStyleAccess,
		log:             log.New("s3uploader"),
	}
}

func (u *S3Uploader) Upload(ctx context.Context, imageDiskPath string) (string, error) {
	// Build config with custom options
	var optFns []func(*config.LoadOptions) error

	// Set region
	if u.region != "" {
		optFns = append(optFns, config.WithRegion(u.region))
	}

	// Set credentials if provided
	if u.accessKey != "" && u.secretKey != "" {
		optFns = append(optFns, config.WithCredentialsProvider(
			credentials.NewStaticCredentialsProvider(u.accessKey, u.secretKey, ""),
		))
	}

	cfg, err := config.LoadDefaultConfig(ctx, optFns...)
	if err != nil {
		return "", err
	}

	// Create S3 client with custom options
	var s3Opts []func(*s3.Options)

	if u.endpoint != "" {
		s3Opts = append(s3Opts, func(o *s3.Options) {
			o.BaseEndpoint = aws.String(u.endpoint)
			o.UsePathStyle = u.pathStyleAccess
		})
	} else if u.pathStyleAccess {
		s3Opts = append(s3Opts, func(o *s3.Options) {
			o.UsePathStyle = true
		})
	}

	client := s3.NewFromConfig(cfg, s3Opts...)

	rand, err := util.GetRandomString(20)
	if err != nil {
		return "", err
	}
	key := u.path + rand + pngExt
	u.log.Debug("Uploading image to s3.", "bucket", u.bucket, "path", key)

	// We can ignore the gosec G304 warning on this one because `imageDiskPath` comes
	// from alert notifiers and is only used to upload images generated by alerting.
	// nolint:gosec
	file, err := os.Open(imageDiskPath)
	if err != nil {
		return "", err
	}
	defer func() {
		if err := file.Close(); err != nil {
			u.log.Warn("Failed to close file", "path", imageDiskPath, "err", err)
		}
	}()

	uploader := manager.NewUploader(client)
	result, err := uploader.Upload(ctx, &s3.PutObjectInput{
		Bucket:      aws.String(u.bucket),
		Key:         aws.String(key),
		ACL:         s3types.ObjectCannedACL(u.acl),
		Body:        file,
		ContentType: aws.String("image/png"),
	})
	if err != nil {
		return "", err
	}
	return result.Location, nil
}
