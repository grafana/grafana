{
 "basePath": "/api",
 "consumes": [
  "application/json"
 ],
 "definitions": {
  "Ack": {
   "type": "object"
  },
  "Alert": {
   "properties": {
    "activeAt": {
     "format": "date-time",
     "type": "string"
    },
    "annotations": {
     "$ref": "#/definitions/Labels"
    },
    "labels": {
     "$ref": "#/definitions/Labels"
    },
    "state": {
     "type": "string"
    },
    "value": {
     "type": "string"
    }
   },
   "required": [
    "labels",
    "annotations",
    "state",
    "value"
   ],
   "title": "Alert has info for an alert.",
   "type": "object"
  },
  "AlertDiscovery": {
   "properties": {
    "alerts": {
     "items": {
      "$ref": "#/definitions/Alert"
     },
     "type": "array"
    }
   },
   "required": [
    "alerts"
   ],
   "title": "AlertDiscovery has info for all active alerts.",
   "type": "object"
  },
  "AlertInstancesResponse": {
   "properties": {
    "instances": {
     "description": "Instances is an array of arrow encoded dataframes\neach frame has a single row, and a column for each instance (alert identified by unique labels) with a boolean value (firing/not firing)",
     "items": {
      "items": {
       "format": "uint8",
       "type": "integer"
      },
      "type": "array"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "AlertManager": {
   "properties": {
    "url": {
     "type": "string"
    }
   },
   "title": "AlertManager models a configured Alert Manager.",
   "type": "object"
  },
  "AlertManagerNotReady": {
   "type": "object"
  },
  "AlertManagersResult": {
   "properties": {
    "activeAlertManagers": {
     "items": {
      "$ref": "#/definitions/AlertManager"
     },
     "type": "array"
    },
    "droppedAlertManagers": {
     "items": {
      "$ref": "#/definitions/AlertManager"
     },
     "type": "array"
    }
   },
   "title": "AlertManagersResult contains the result from querying the alertmanagers endpoint.",
   "type": "object"
  },
  "AlertQuery": {
   "properties": {
    "datasourceUid": {
     "description": "Grafana data source unique identifier; it should be '__expr__' for a Server Side Expression operation.",
     "type": "string"
    },
    "model": {
     "description": "JSON is the raw JSON query and includes the above properties as well as custom properties.",
     "type": "object"
    },
    "queryType": {
     "description": "QueryType is an optional identifier for the type of query.\nIt can be used to distinguish different types of queries.",
     "type": "string"
    },
    "refId": {
     "description": "RefID is the unique identifier of the query, set by the frontend call.",
     "type": "string"
    },
    "relativeTimeRange": {
     "$ref": "#/definitions/RelativeTimeRange"
    }
   },
   "title": "AlertQuery represents a single query associated with an alert definition.",
   "type": "object"
  },
  "AlertQueryExport": {
   "properties": {
    "datasourceUid": {
     "type": "string"
    },
    "model": {
     "additionalProperties": {},
     "type": "object"
    },
    "queryType": {
     "type": "string"
    },
    "refId": {
     "type": "string"
    },
    "relativeTimeRange": {
     "$ref": "#/definitions/RelativeTimeRangeExport"
    }
   },
   "title": "AlertQueryExport is the provisioned export of models.AlertQuery.",
   "type": "object"
  },
  "AlertResponse": {
   "properties": {
    "data": {
     "$ref": "#/definitions/AlertDiscovery"
    },
    "error": {
     "type": "string"
    },
    "errorType": {
     "$ref": "#/definitions/ErrorType"
    },
    "status": {
     "type": "string"
    }
   },
   "required": [
    "status"
   ],
   "type": "object"
  },
  "AlertRuleEditorSettings": {
   "properties": {
    "simplified_notifications_section": {
     "type": "boolean"
    },
    "simplified_query_and_expressions_section": {
     "type": "boolean"
    }
   },
   "type": "object"
  },
  "AlertRuleExport": {
   "properties": {
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "condition": {
     "type": "string"
    },
    "dashboardUid": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQueryExport"
     },
     "type": "array"
    },
    "execErrState": {
     "enum": [
      "OK",
      "Alerting",
      "Error"
     ],
     "type": "string"
    },
    "for": {
     "$ref": "#/definitions/Duration"
    },
    "isPaused": {
     "type": "boolean"
    },
    "keepFiringFor": {
     "$ref": "#/definitions/Duration"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "missing_series_evals_to_resolve": {
     "format": "int64",
     "type": "integer"
    },
    "noDataState": {
     "enum": [
      "Alerting",
      "NoData",
      "OK"
     ],
     "type": "string"
    },
    "notification_settings": {
     "$ref": "#/definitions/AlertRuleNotificationSettingsExport"
    },
    "panelId": {
     "format": "int64",
     "type": "integer"
    },
    "record": {
     "$ref": "#/definitions/AlertRuleRecordExport"
    },
    "title": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "title": "AlertRuleExport is the provisioned file export of models.AlertRule.",
   "type": "object"
  },
  "AlertRuleGroup": {
   "properties": {
    "folderUid": {
     "type": "string"
    },
    "interval": {
     "format": "int64",
     "type": "integer"
    },
    "rules": {
     "items": {
      "$ref": "#/definitions/ProvisionedAlertRule"
     },
     "type": "array"
    },
    "title": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "AlertRuleGroupExport": {
   "properties": {
    "folder": {
     "type": "string"
    },
    "interval": {
     "$ref": "#/definitions/Duration"
    },
    "name": {
     "type": "string"
    },
    "orgId": {
     "format": "int64",
     "type": "integer"
    },
    "rules": {
     "items": {
      "$ref": "#/definitions/AlertRuleExport"
     },
     "type": "array"
    }
   },
   "title": "AlertRuleGroupExport is the provisioned file export of AlertRuleGroupV1.",
   "type": "object"
  },
  "AlertRuleGroupMetadata": {
   "properties": {
    "interval": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "AlertRuleMetadata": {
   "properties": {
    "editor_settings": {
     "$ref": "#/definitions/AlertRuleEditorSettings"
    }
   },
   "type": "object"
  },
  "AlertRuleNotificationSettings": {
   "properties": {
    "group_by": {
     "default": [
      "alertname",
      "grafana_folder"
     ],
     "description": "Override the labels by which incoming alerts are grouped together. For example, multiple alerts coming in for\ncluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels\nuse the special value '...' as the sole label name.\nThis effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what\nyou want, unless you have a very low alert volume or your upstream notification system performs its own grouping.\nMust include 'alertname' and 'grafana_folder' if not using '...'.",
     "example": [
      "alertname",
      "grafana_folder",
      "cluster"
     ],
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "group_interval": {
     "description": "Override how long to wait before sending a notification about new alerts that are added to a group of alerts for\nwhich an initial notification has already been sent. (Usually ~5m or more.)",
     "example": "5m",
     "type": "string"
    },
    "group_wait": {
     "description": "Override how long to initially wait to send a notification for a group of alerts. Allows to wait for an\ninhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)",
     "example": "30s",
     "type": "string"
    },
    "mute_time_intervals": {
     "description": "Override the times when notifications should be muted. These must match the name of a mute time interval defined\nin the alertmanager configuration mute_time_intervals section. When muted it will not send any notifications, but\notherwise acts normally.",
     "example": [
      "maintenance"
     ],
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "receiver": {
     "description": "Name of the receiver to send notifications to.",
     "example": "grafana-default-email",
     "type": "string"
    },
    "repeat_interval": {
     "description": "Override how long to wait before sending a notification again if it has already been sent successfully for an\nalert. (Usually ~3h or more).\nNote that this parameter is implicitly bound by Alertmanager's `--data.retention` configuration flag.\nNotifications will be resent after either repeat_interval or the data retention period have passed, whichever\noccurs first. `repeat_interval` should not be less than `group_interval`.",
     "example": "4h",
     "type": "string"
    }
   },
   "required": [
    "receiver"
   ],
   "type": "object"
  },
  "AlertRuleNotificationSettingsExport": {
   "properties": {
    "group_by": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "group_interval": {
     "type": "string"
    },
    "group_wait": {
     "type": "string"
    },
    "mute_time_intervals": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "receiver": {
     "type": "string"
    },
    "repeat_interval": {
     "type": "string"
    }
   },
   "title": "AlertRuleNotificationSettingsExport is the provisioned export of models.NotificationSettings.",
   "type": "object"
  },
  "AlertRuleRecordExport": {
   "properties": {
    "from": {
     "type": "string"
    },
    "metric": {
     "type": "string"
    },
    "targetDatasourceUid": {
     "type": "string"
    }
   },
   "title": "Record is the provisioned export of models.Record.",
   "type": "object"
  },
  "AlertingFileExport": {
   "properties": {
    "apiVersion": {
     "format": "int64",
     "type": "integer"
    },
    "contactPoints": {
     "items": {
      "$ref": "#/definitions/ContactPointExport"
     },
     "type": "array"
    },
    "groups": {
     "items": {
      "$ref": "#/definitions/AlertRuleGroupExport"
     },
     "type": "array"
    },
    "muteTimes": {
     "items": {
      "$ref": "#/definitions/MuteTimeIntervalExport"
     },
     "type": "array"
    },
    "policies": {
     "items": {
      "$ref": "#/definitions/NotificationPolicyExport"
     },
     "type": "array"
    }
   },
   "title": "AlertingFileExport is the full provisioned file export.",
   "type": "object"
  },
  "AlertingRule": {
   "description": "adapted from cortex",
   "properties": {
    "activeAt": {
     "format": "date-time",
     "type": "string"
    },
    "alerts": {
     "items": {
      "$ref": "#/definitions/Alert"
     },
     "type": "array"
    },
    "annotations": {
     "$ref": "#/definitions/Labels"
    },
    "duration": {
     "format": "double",
     "type": "number"
    },
    "evaluationTime": {
     "format": "double",
     "type": "number"
    },
    "folderUid": {
     "type": "string"
    },
    "health": {
     "type": "string"
    },
    "keepFiringFor": {
     "format": "double",
     "type": "number"
    },
    "labels": {
     "$ref": "#/definitions/Labels"
    },
    "lastError": {
     "type": "string"
    },
    "lastEvaluation": {
     "format": "date-time",
     "type": "string"
    },
    "name": {
     "type": "string"
    },
    "query": {
     "type": "string"
    },
    "state": {
     "description": "State can be \"pending\", \"firing\", \"inactive\".",
     "type": "string"
    },
    "totals": {
     "additionalProperties": {
      "format": "int64",
      "type": "integer"
     },
     "type": "object"
    },
    "totalsFiltered": {
     "additionalProperties": {
      "format": "int64",
      "type": "integer"
     },
     "type": "object"
    },
    "type": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "required": [
    "uid",
    "name",
    "folderUid",
    "query",
    "health",
    "type",
    "state",
    "annotations",
    "activeAt"
   ],
   "type": "object"
  },
  "AlertingStatus": {
   "properties": {
    "alertmanagersChoice": {
     "enum": [
      "all",
      "internal",
      "external"
     ],
     "type": "string"
    },
    "numExternalAlertmanagers": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "ApiRuleNode": {
   "properties": {
    "alert": {
     "type": "string"
    },
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "expr": {
     "type": "string"
    },
    "for": {
     "type": "string"
    },
    "keep_firing_for": {
     "type": "string"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "record": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "Authorization": {
   "properties": {
    "credentials": {
     "$ref": "#/definitions/Secret"
    },
    "credentials_file": {
     "type": "string"
    },
    "credentials_ref": {
     "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
     "type": "string"
    },
    "type": {
     "type": "string"
    }
   },
   "title": "Authorization contains HTTP authorization credentials.",
   "type": "object"
  },
  "BacktestConfig": {
   "properties": {
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "condition": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "for": {
     "$ref": "#/definitions/Duration"
    },
    "from": {
     "format": "date-time",
     "type": "string"
    },
    "interval": {
     "$ref": "#/definitions/Duration"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "no_data_state": {
     "enum": [
      "Alerting",
      "NoData",
      "OK"
     ],
     "type": "string"
    },
    "title": {
     "type": "string"
    },
    "to": {
     "format": "date-time",
     "type": "string"
    }
   },
   "type": "object"
  },
  "BacktestResult": {
   "$ref": "#/definitions/Frame"
  },
  "BasicAuth": {
   "properties": {
    "password": {
     "$ref": "#/definitions/Secret"
    },
    "password_file": {
     "type": "string"
    },
    "password_ref": {
     "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
     "type": "string"
    },
    "username": {
     "type": "string"
    },
    "username_file": {
     "type": "string"
    },
    "username_ref": {
     "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
     "type": "string"
    }
   },
   "title": "BasicAuth contains basic HTTP authentication credentials.",
   "type": "object"
  },
  "ConfFloat64": {
   "description": "ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf\nto null.",
   "format": "double",
   "type": "number"
  },
  "Config": {
   "properties": {
    "global": {
     "$ref": "#/definitions/GlobalConfig"
    },
    "inhibit_rules": {
     "items": {
      "$ref": "#/definitions/InhibitRule"
     },
     "type": "array"
    },
    "mute_time_intervals": {
     "description": "MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.",
     "items": {
      "$ref": "#/definitions/MuteTimeInterval"
     },
     "type": "array"
    },
    "route": {
     "$ref": "#/definitions/Route"
    },
    "templates": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "title": "Config is the top-level configuration for Alertmanager's config files.",
   "type": "object"
  },
  "ContactPointExport": {
   "properties": {
    "name": {
     "type": "string"
    },
    "orgId": {
     "format": "int64",
     "type": "integer"
    },
    "receivers": {
     "items": {
      "$ref": "#/definitions/ReceiverExport"
     },
     "type": "array"
    }
   },
   "title": "ContactPointExport is the provisioned file export of alerting.ContactPointV1.",
   "type": "object"
  },
  "ContactPoints": {
   "items": {
    "$ref": "#/definitions/EmbeddedContactPoint"
   },
   "type": "array"
  },
  "ConvertPrometheusResponse": {
   "properties": {
    "error": {
     "type": "string"
    },
    "errorType": {
     "type": "string"
    },
    "status": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "CounterResetHint": {
   "description": "or alternatively that we are dealing with a gauge histogram, where counter resets do not apply.",
   "format": "uint8",
   "title": "CounterResetHint contains the known information about a counter reset,",
   "type": "integer"
  },
  "DataLink": {
   "description": "DataLink define what",
   "properties": {
    "internal": {
     "$ref": "#/definitions/InternalDataLink"
    },
    "targetBlank": {
     "type": "boolean"
    },
    "title": {
     "type": "string"
    },
    "url": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "DataResponse": {
   "description": "A map of RefIDs (unique query identifiers) to this type makes up the Responses property of a QueryDataResponse.\nThe Error property is used to allow for partial success responses from the containing QueryDataResponse.",
   "properties": {
    "Error": {
     "description": "Error is a property to be set if the corresponding DataQuery has an error.",
     "type": "string"
    },
    "ErrorSource": {
     "$ref": "#/definitions/Source"
    },
    "Frames": {
     "$ref": "#/definitions/Frames"
    },
    "Status": {
     "$ref": "#/definitions/Status"
    }
   },
   "title": "DataResponse contains the results from a DataQuery.",
   "type": "object"
  },
  "DataTopic": {
   "description": "nolint:revive",
   "title": "DataTopic is used to identify which topic the frame should be assigned to.",
   "type": "string"
  },
  "DiscordConfig": {
   "properties": {
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "title": {
     "type": "string"
    },
    "webhook_url": {
     "$ref": "#/definitions/SecretURL"
    },
    "webhook_url_file": {
     "type": "string"
    }
   },
   "title": "DiscordConfig configures notifications via Discord.",
   "type": "object"
  },
  "DiscoveryBase": {
   "properties": {
    "error": {
     "type": "string"
    },
    "errorType": {
     "$ref": "#/definitions/ErrorType"
    },
    "status": {
     "type": "string"
    }
   },
   "required": [
    "status"
   ],
   "type": "object"
  },
  "Duration": {
   "format": "int64",
   "title": "Duration is a type used for marshalling durations.",
   "type": "integer"
  },
  "EmailConfig": {
   "properties": {
    "auth_identity": {
     "type": "string"
    },
    "auth_password": {
     "$ref": "#/definitions/Secret"
    },
    "auth_password_file": {
     "type": "string"
    },
    "auth_secret": {
     "$ref": "#/definitions/Secret"
    },
    "auth_username": {
     "type": "string"
    },
    "from": {
     "type": "string"
    },
    "headers": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "hello": {
     "type": "string"
    },
    "html": {
     "type": "string"
    },
    "require_tls": {
     "type": "boolean"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "smarthost": {
     "$ref": "#/definitions/HostPort"
    },
    "text": {
     "type": "string"
    },
    "tls_config": {
     "$ref": "#/definitions/TLSConfig"
    },
    "to": {
     "description": "Email address to notify.",
     "type": "string"
    }
   },
   "title": "EmailConfig configures notifications via mail.",
   "type": "object"
  },
  "EmbeddedContactPoint": {
   "description": "EmbeddedContactPoint is the contact point type that is used\nby grafanas embedded alertmanager implementation.",
   "properties": {
    "disableResolveMessage": {
     "example": false,
     "type": "boolean"
    },
    "name": {
     "description": "Name is used as grouping key in the UI. Contact points with the\nsame name will be grouped in the UI.",
     "example": "webhook_1",
     "type": "string"
    },
    "provenance": {
     "readOnly": true,
     "type": "string"
    },
    "settings": {
     "$ref": "#/definitions/Json"
    },
    "type": {
     "enum": [
      "alertmanager",
      "dingding",
      "discord",
      "email",
      "googlechat",
      "kafka",
      "line",
      "opsgenie",
      "pagerduty",
      "pushover",
      "sensugo",
      "slack",
      "teams",
      "telegram",
      "threema",
      "victorops",
      "webhook",
      "wecom"
     ],
     "example": "webhook",
     "type": "string"
    },
    "uid": {
     "description": "UID is the unique identifier of the contact point. The UID can be\nset by the user.",
     "example": "my_external_reference",
     "maxLength": 40,
     "minLength": 1,
     "pattern": "^[a-zA-Z0-9\\-\\_]+$",
     "type": "string"
    }
   },
   "required": [
    "type",
    "settings"
   ],
   "type": "object"
  },
  "EnumFieldConfig": {
   "description": "Enum field config\nVector values are used as lookup keys into the enum fields",
   "properties": {
    "color": {
     "description": "Color is the color value for a given index (empty is undefined)",
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "description": {
     "description": "Description of the enum state",
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "icon": {
     "description": "Icon supports setting an icon for a given index value",
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "text": {
     "description": "Value is the string display value for a given index",
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "ErrorType": {
   "title": "ErrorType models the different API error types.",
   "type": "string"
  },
  "EvalAlertConditionCommand": {
   "description": "EvalAlertConditionCommand is the command for evaluating a condition",
   "properties": {
    "condition": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "now": {
     "format": "date-time",
     "type": "string"
    }
   },
   "type": "object"
  },
  "EvalQueriesPayload": {
   "properties": {
    "condition": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "now": {
     "format": "date-time",
     "type": "string"
    }
   },
   "type": "object"
  },
  "EvalQueriesResponse": {
   "type": "object"
  },
  "ExplorePanelsState": {
   "description": "This is an object constructed with the keys as the values of the enum VisType and the value being a bag of properties"
  },
  "ExtendedReceiver": {
   "properties": {
    "email_configs": {
     "$ref": "#/definitions/EmailConfig"
    },
    "grafana_managed_receiver": {
     "$ref": "#/definitions/PostableGrafanaReceiver"
    },
    "opsgenie_configs": {
     "$ref": "#/definitions/OpsGenieConfig"
    },
    "pagerduty_configs": {
     "$ref": "#/definitions/PagerdutyConfig"
    },
    "pushover_configs": {
     "$ref": "#/definitions/PushoverConfig"
    },
    "slack_configs": {
     "$ref": "#/definitions/SlackConfig"
    },
    "victorops_configs": {
     "$ref": "#/definitions/VictorOpsConfig"
    },
    "webhook_configs": {
     "$ref": "#/definitions/WebhookConfig"
    },
    "wechat_configs": {
     "$ref": "#/definitions/WechatConfig"
    }
   },
   "type": "object"
  },
  "Failure": {
   "$ref": "#/definitions/ResponseDetails"
  },
  "Field": {
   "description": "A Field is essentially a slice of various types with extra properties and methods.\nSee NewField() for supported types.\n\nThe slice data in the Field is a not exported, so methods on the Field are used to to manipulate its data.",
   "properties": {
    "config": {
     "$ref": "#/definitions/FieldConfig"
    },
    "labels": {
     "$ref": "#/definitions/FrameLabels"
    },
    "name": {
     "description": "Name is default identifier of the field. The name does not have to be unique, but the combination\nof name and Labels should be unique for proper behavior in all situations.",
     "type": "string"
    }
   },
   "title": "Field represents a typed column of data within a Frame.",
   "type": "object"
  },
  "FieldConfig": {
   "properties": {
    "color": {
     "additionalProperties": {},
     "description": "Map values to a display color\nNOTE: this interface is under development in the frontend... so simple map for now",
     "type": "object"
    },
    "custom": {
     "additionalProperties": {},
     "description": "Panel Specific Values",
     "type": "object"
    },
    "decimals": {
     "format": "uint16",
     "type": "integer"
    },
    "description": {
     "description": "Description is human readable field metadata",
     "type": "string"
    },
    "displayName": {
     "description": "DisplayName overrides Grafana default naming, should not be used from a data source",
     "type": "string"
    },
    "displayNameFromDS": {
     "description": "DisplayNameFromDS overrides Grafana default naming strategy.",
     "type": "string"
    },
    "filterable": {
     "description": "Filterable indicates if the Field's data can be filtered by additional calls.",
     "type": "boolean"
    },
    "interval": {
     "description": "Interval indicates the expected regular step between values in the series.\nWhen an interval exists, consumers can identify \"missing\" values when the expected value is not present.\nThe grafana timeseries visualization will render disconnected values when missing values are found it the time field.\nThe interval uses the same units as the values.  For time.Time, this is defined in milliseconds.",
     "format": "double",
     "type": "number"
    },
    "links": {
     "description": "The behavior when clicking on a result",
     "items": {
      "$ref": "#/definitions/DataLink"
     },
     "type": "array"
    },
    "mappings": {
     "$ref": "#/definitions/ValueMappings"
    },
    "max": {
     "$ref": "#/definitions/ConfFloat64"
    },
    "min": {
     "$ref": "#/definitions/ConfFloat64"
    },
    "noValue": {
     "description": "Alternative to empty string",
     "type": "string"
    },
    "path": {
     "description": "Path is an explicit path to the field in the datasource. When the frame meta includes a path,\nthis will default to `${frame.meta.path}/${field.name}\n\nWhen defined, this value can be used as an identifier within the datasource scope, and\nmay be used as an identifier to update values in a subsequent request",
     "type": "string"
    },
    "thresholds": {
     "$ref": "#/definitions/ThresholdsConfig"
    },
    "type": {
     "$ref": "#/definitions/FieldTypeConfig"
    },
    "unit": {
     "description": "Numeric Options",
     "type": "string"
    },
    "writeable": {
     "description": "Writeable indicates that the datasource knows how to update this value",
     "type": "boolean"
    }
   },
   "title": "FieldConfig represents the display properties for a Field.",
   "type": "object"
  },
  "FieldTypeConfig": {
   "description": "FieldTypeConfig has type specific configs, only one should be active at a time",
   "properties": {
    "enum": {
     "$ref": "#/definitions/EnumFieldConfig"
    }
   },
   "type": "object"
  },
  "FloatHistogram": {
   "description": "A FloatHistogram is needed by PromQL to handle operations that might result\nin fractional counts. Since the counts in a histogram are unlikely to be too\nlarge to be represented precisely by a float64, a FloatHistogram can also be\nused to represent a histogram with integer counts and thus serves as a more\ngeneralized representation.",
   "properties": {
    "Count": {
     "description": "Total number of observations. Must be zero or positive.",
     "format": "double",
     "type": "number"
    },
    "CounterResetHint": {
     "$ref": "#/definitions/CounterResetHint"
    },
    "CustomValues": {
     "description": "Holds the custom (usually upper) bounds for bucket definitions, otherwise nil.\nThis slice is interned, to be treated as immutable and copied by reference.\nThese numbers should be strictly increasing. This field is only used when the\nschema is for custom buckets, and the ZeroThreshold, ZeroCount, NegativeSpans\nand NegativeBuckets fields are not used in that case.",
     "items": {
      "format": "double",
      "type": "number"
     },
     "type": "array"
    },
    "PositiveBuckets": {
     "description": "Observation counts in buckets. Each represents an absolute count and\nmust be zero or positive.",
     "items": {
      "format": "double",
      "type": "number"
     },
     "type": "array"
    },
    "PositiveSpans": {
     "description": "Spans for positive and negative buckets (see Span below).",
     "items": {
      "$ref": "#/definitions/Span"
     },
     "type": "array"
    },
    "Schema": {
     "description": "Currently valid schema numbers are -4 \u003c= n \u003c= 8 for exponential buckets.\nThey are all for base-2 bucket schemas, where 1 is a bucket boundary in\neach case, and then each power of two is divided into 2^n logarithmic buckets.\nOr in other words, each bucket boundary is the previous boundary times\n2^(2^-n). Another valid schema number is -53 for custom buckets, defined by\nthe CustomValues field.",
     "format": "int32",
     "type": "integer"
    },
    "Sum": {
     "description": "Sum of observations. This is also used as the stale marker.",
     "format": "double",
     "type": "number"
    },
    "ZeroCount": {
     "description": "Observations falling into the zero bucket. Must be zero or positive.",
     "format": "double",
     "type": "number"
    },
    "ZeroThreshold": {
     "description": "Width of the zero bucket.",
     "format": "double",
     "type": "number"
    }
   },
   "title": "FloatHistogram is similar to Histogram but uses float64 for all\ncounts. Additionally, bucket counts are absolute and not deltas.",
   "type": "object"
  },
  "ForbiddenError": {
   "properties": {
    "body": {
     "$ref": "#/definitions/PublicError"
    }
   },
   "type": "object"
  },
  "Frame": {
   "description": "Each Field is well typed by its FieldType and supports optional Labels.\n\nA Frame is a general data container for Grafana. A Frame can be table data\nor time series data depending on its content and field types.",
   "properties": {
    "Fields": {
     "description": "Fields are the columns of a frame.\nAll Fields must be of the same the length when marshalling the Frame for transmission.\nThere should be no `nil` entries in the Fields slice (making them pointers was a mistake).",
     "items": {
      "$ref": "#/definitions/Field"
     },
     "type": "array"
    },
    "Meta": {
     "$ref": "#/definitions/FrameMeta"
    },
    "Name": {
     "description": "Name is used in some Grafana visualizations.",
     "type": "string"
    },
    "RefID": {
     "description": "RefID is a property that can be set to match a Frame to its originating query.",
     "type": "string"
    }
   },
   "title": "Frame is a columnar data structure where each column is a Field.",
   "type": "object"
  },
  "FrameLabels": {
   "additionalProperties": {
    "type": "string"
   },
   "description": "Labels are used to add metadata to an object.  The JSON will always be sorted keys",
   "type": "object"
  },
  "FrameMeta": {
   "description": "https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L11\nNOTE -- in javascript this can accept any `[key: string]: any;` however\nthis interface only exposes the values we want to be exposed",
   "properties": {
    "channel": {
     "description": "Channel is the path to a stream in grafana live that has real-time updates for this data.",
     "type": "string"
    },
    "custom": {
     "description": "Custom datasource specific values."
    },
    "dataTopic": {
     "$ref": "#/definitions/DataTopic"
    },
    "executedQueryString": {
     "description": "ExecutedQueryString is the raw query sent to the underlying system. All macros and templating\nhave been applied.  When metadata contains this value, it will be shown in the query inspector.",
     "type": "string"
    },
    "notices": {
     "description": "Notices provide additional information about the data in the Frame that\nGrafana can display to the user in the user interface.",
     "items": {
      "$ref": "#/definitions/Notice"
     },
     "type": "array"
    },
    "path": {
     "description": "Path is a browsable path on the datasource.",
     "type": "string"
    },
    "pathSeparator": {
     "description": "PathSeparator defines the separator pattern to decode a hierarchy. The default separator is '/'.",
     "type": "string"
    },
    "preferredVisualisationPluginId": {
     "description": "PreferredVisualizationPluginId sets the panel plugin id to use to render the data when using Explore. If\nthe plugin cannot be found will fall back to PreferredVisualization.",
     "type": "string"
    },
    "preferredVisualisationType": {
     "$ref": "#/definitions/VisType"
    },
    "stats": {
     "description": "Stats is an array of query result statistics.",
     "items": {
      "$ref": "#/definitions/QueryStat"
     },
     "type": "array"
    },
    "type": {
     "$ref": "#/definitions/FrameType"
    },
    "typeVersion": {
     "$ref": "#/definitions/FrameTypeVersion"
    },
    "uniqueRowIdFields": {
     "description": "Array of field indices which values create a unique id for each row. Ideally this should be globally unique ID\nbut that isn't guarantied. Should help with keeping track and deduplicating rows in visualizations, especially\nwith streaming data with frequent updates.",
     "example": "TraceID in Tempo, table name + primary key in SQL",
     "items": {
      "format": "int64",
      "type": "integer"
     },
     "type": "array"
    }
   },
   "title": "FrameMeta matches:",
   "type": "object"
  },
  "FrameType": {
   "description": "A FrameType string, when present in a frame's metadata, asserts that the\nframe's structure conforms to the FrameType's specification.\nThis property is currently optional, so FrameType may be FrameTypeUnknown even if the properties of\nthe Frame correspond to a defined FrameType.\n+enum",
   "type": "string"
  },
  "FrameTypeVersion": {
   "items": {
    "format": "uint64",
    "type": "integer"
   },
   "title": "FrameType is a 2 number version (Major / Minor).",
   "type": "array"
  },
  "Frames": {
   "description": "It is the main data container within a backend.DataResponse.\nThere should be no `nil` entries in the Frames slice (making them pointers was a mistake).",
   "items": {
    "$ref": "#/definitions/Frame"
   },
   "title": "Frames is a slice of Frame pointers.",
   "type": "array"
  },
  "GettableAlertmanagers": {
   "properties": {
    "data": {
     "$ref": "#/definitions/AlertManagersResult"
    },
    "status": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "GettableApiAlertingConfig": {
   "properties": {
    "global": {
     "$ref": "#/definitions/GlobalConfig"
    },
    "inhibit_rules": {
     "items": {
      "$ref": "#/definitions/InhibitRule"
     },
     "type": "array"
    },
    "muteTimeProvenances": {
     "additionalProperties": {
      "$ref": "#/definitions/Provenance"
     },
     "type": "object"
    },
    "mute_time_intervals": {
     "description": "MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.",
     "items": {
      "$ref": "#/definitions/MuteTimeInterval"
     },
     "type": "array"
    },
    "receivers": {
     "description": "Override with our superset receiver type",
     "items": {
      "$ref": "#/definitions/GettableApiReceiver"
     },
     "type": "array"
    },
    "route": {
     "$ref": "#/definitions/Route"
    },
    "templates": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "GettableApiReceiver": {
   "properties": {
    "discord_configs": {
     "items": {
      "$ref": "#/definitions/DiscordConfig"
     },
     "type": "array"
    },
    "email_configs": {
     "items": {
      "$ref": "#/definitions/EmailConfig"
     },
     "type": "array"
    },
    "grafana_managed_receiver_configs": {
     "items": {
      "$ref": "#/definitions/GettableGrafanaReceiver"
     },
     "type": "array"
    },
    "jira_configs": {
     "items": {
      "$ref": "#/definitions/JiraConfig"
     },
     "type": "array"
    },
    "msteams_configs": {
     "items": {
      "$ref": "#/definitions/MSTeamsConfig"
     },
     "type": "array"
    },
    "name": {
     "description": "A unique identifier for this receiver.",
     "type": "string"
    },
    "opsgenie_configs": {
     "items": {
      "$ref": "#/definitions/OpsGenieConfig"
     },
     "type": "array"
    },
    "pagerduty_configs": {
     "items": {
      "$ref": "#/definitions/PagerdutyConfig"
     },
     "type": "array"
    },
    "pushover_configs": {
     "items": {
      "$ref": "#/definitions/PushoverConfig"
     },
     "type": "array"
    },
    "slack_configs": {
     "items": {
      "$ref": "#/definitions/SlackConfig"
     },
     "type": "array"
    },
    "sns_configs": {
     "items": {
      "$ref": "#/definitions/SNSConfig"
     },
     "type": "array"
    },
    "telegram_configs": {
     "items": {
      "$ref": "#/definitions/TelegramConfig"
     },
     "type": "array"
    },
    "victorops_configs": {
     "items": {
      "$ref": "#/definitions/VictorOpsConfig"
     },
     "type": "array"
    },
    "webex_configs": {
     "items": {
      "$ref": "#/definitions/WebexConfig"
     },
     "type": "array"
    },
    "webhook_configs": {
     "items": {
      "$ref": "#/definitions/WebhookConfig"
     },
     "type": "array"
    },
    "wechat_configs": {
     "items": {
      "$ref": "#/definitions/WechatConfig"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "GettableExtendedRuleNode": {
   "properties": {
    "alert": {
     "type": "string"
    },
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "expr": {
     "type": "string"
    },
    "for": {
     "type": "string"
    },
    "grafana_alert": {
     "$ref": "#/definitions/GettableGrafanaRule"
    },
    "keep_firing_for": {
     "type": "string"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "record": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "GettableGrafanaReceiver": {
   "properties": {
    "disableResolveMessage": {
     "type": "boolean"
    },
    "name": {
     "type": "string"
    },
    "provenance": {
     "$ref": "#/definitions/Provenance"
    },
    "secureFields": {
     "additionalProperties": {
      "type": "boolean"
     },
     "type": "object"
    },
    "settings": {
     "$ref": "#/definitions/RawMessage"
    },
    "type": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "GettableGrafanaReceivers": {
   "properties": {
    "grafana_managed_receiver_configs": {
     "items": {
      "$ref": "#/definitions/GettableGrafanaReceiver"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "GettableGrafanaRule": {
   "properties": {
    "condition": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "exec_err_state": {
     "enum": [
      "OK",
      "Alerting",
      "Error"
     ],
     "type": "string"
    },
    "guid": {
     "type": "string"
    },
    "intervalSeconds": {
     "format": "int64",
     "type": "integer"
    },
    "is_paused": {
     "type": "boolean"
    },
    "metadata": {
     "$ref": "#/definitions/AlertRuleMetadata"
    },
    "missing_series_evals_to_resolve": {
     "format": "int64",
     "type": "integer"
    },
    "namespace_uid": {
     "type": "string"
    },
    "no_data_state": {
     "enum": [
      "Alerting",
      "NoData",
      "OK"
     ],
     "type": "string"
    },
    "notification_settings": {
     "$ref": "#/definitions/AlertRuleNotificationSettings"
    },
    "provenance": {
     "$ref": "#/definitions/Provenance"
    },
    "record": {
     "$ref": "#/definitions/Record"
    },
    "rule_group": {
     "type": "string"
    },
    "title": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    },
    "updated": {
     "format": "date-time",
     "type": "string"
    },
    "updated_by": {
     "$ref": "#/definitions/UserInfo"
    },
    "version": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "GettableHistoricUserConfig": {
   "properties": {
    "alertmanager_config": {
     "$ref": "#/definitions/GettableApiAlertingConfig"
    },
    "id": {
     "format": "int64",
     "type": "integer"
    },
    "last_applied": {
     "format": "date-time",
     "type": "string"
    },
    "template_file_provenances": {
     "additionalProperties": {
      "$ref": "#/definitions/Provenance"
     },
     "type": "object"
    },
    "template_files": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    }
   },
   "type": "object"
  },
  "GettableNGalertConfig": {
   "properties": {
    "alertmanagersChoice": {
     "enum": [
      "all",
      "internal",
      "external"
     ],
     "type": "string"
    }
   },
   "type": "object"
  },
  "GettableRuleGroupConfig": {
   "properties": {
    "align_evaluation_time_on_interval": {
     "type": "boolean"
    },
    "evaluation_delay": {
     "type": "string"
    },
    "interval": {
     "$ref": "#/definitions/Duration"
    },
    "limit": {
     "format": "int64",
     "type": "integer"
    },
    "name": {
     "type": "string"
    },
    "query_offset": {
     "type": "string"
    },
    "rules": {
     "items": {
      "$ref": "#/definitions/GettableExtendedRuleNode"
     },
     "type": "array"
    },
    "source_tenants": {
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "GettableRuleVersions": {
   "items": {
    "$ref": "#/definitions/GettableExtendedRuleNode"
   },
   "type": "array"
  },
  "GettableStatus": {
   "properties": {
    "cluster": {
     "$ref": "#/definitions/clusterStatus"
    },
    "config": {
     "$ref": "#/definitions/PostableApiAlertingConfig"
    },
    "uptime": {
     "description": "uptime",
     "format": "date-time",
     "type": "string"
    },
    "versionInfo": {
     "$ref": "#/definitions/versionInfo"
    }
   },
   "required": [
    "cluster",
    "config",
    "uptime",
    "versionInfo"
   ],
   "type": "object"
  },
  "GettableUserConfig": {
   "properties": {
    "alertmanager_config": {
     "$ref": "#/definitions/GettableApiAlertingConfig"
    },
    "template_file_provenances": {
     "additionalProperties": {
      "$ref": "#/definitions/Provenance"
     },
     "type": "object"
    },
    "template_files": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    }
   },
   "type": "object"
  },
  "GlobalConfig": {
   "description": "GlobalConfig defines configuration parameters that are valid globally\nunless overwritten.",
   "properties": {
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "jira_api_url": {
     "$ref": "#/definitions/URL"
    },
    "opsgenie_api_key": {
     "$ref": "#/definitions/Secret"
    },
    "opsgenie_api_key_file": {
     "type": "string"
    },
    "opsgenie_api_url": {
     "$ref": "#/definitions/URL"
    },
    "pagerduty_url": {
     "$ref": "#/definitions/URL"
    },
    "resolve_timeout": {
     "$ref": "#/definitions/Duration"
    },
    "slack_api_url": {
     "$ref": "#/definitions/SecretURL"
    },
    "slack_api_url_file": {
     "type": "string"
    },
    "smtp_auth_identity": {
     "type": "string"
    },
    "smtp_auth_password": {
     "$ref": "#/definitions/Secret"
    },
    "smtp_auth_password_file": {
     "type": "string"
    },
    "smtp_auth_secret": {
     "$ref": "#/definitions/Secret"
    },
    "smtp_auth_username": {
     "type": "string"
    },
    "smtp_from": {
     "type": "string"
    },
    "smtp_hello": {
     "type": "string"
    },
    "smtp_require_tls": {
     "type": "boolean"
    },
    "smtp_smarthost": {
     "$ref": "#/definitions/HostPort"
    },
    "smtp_tls_config": {
     "$ref": "#/definitions/TLSConfig"
    },
    "telegram_api_url": {
     "$ref": "#/definitions/URL"
    },
    "victorops_api_key": {
     "$ref": "#/definitions/Secret"
    },
    "victorops_api_key_file": {
     "type": "string"
    },
    "victorops_api_url": {
     "$ref": "#/definitions/URL"
    },
    "webex_api_url": {
     "$ref": "#/definitions/URL"
    },
    "wechat_api_corp_id": {
     "type": "string"
    },
    "wechat_api_secret": {
     "$ref": "#/definitions/Secret"
    },
    "wechat_api_url": {
     "$ref": "#/definitions/URL"
    }
   },
   "type": "object"
  },
  "HTTPClientConfig": {
   "properties": {
    "authorization": {
     "$ref": "#/definitions/Authorization"
    },
    "basic_auth": {
     "$ref": "#/definitions/BasicAuth"
    },
    "bearer_token": {
     "$ref": "#/definitions/Secret"
    },
    "bearer_token_file": {
     "description": "The bearer token file for the targets. Deprecated in favour of\nAuthorization.CredentialsFile.",
     "type": "string"
    },
    "enable_http2": {
     "description": "EnableHTTP2 specifies whether the client should configure HTTP2.\nThe omitempty flag is not set, because it would be hidden from the\nmarshalled configuration when set to false.",
     "type": "boolean"
    },
    "follow_redirects": {
     "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects.\nThe omitempty flag is not set, because it would be hidden from the\nmarshalled configuration when set to false.",
     "type": "boolean"
    },
    "http_headers": {
     "$ref": "#/definitions/Headers"
    },
    "no_proxy": {
     "description": "NoProxy contains addresses that should not use a proxy.",
     "type": "string"
    },
    "oauth2": {
     "$ref": "#/definitions/OAuth2"
    },
    "proxy_connect_header": {
     "$ref": "#/definitions/ProxyHeader"
    },
    "proxy_from_environment": {
     "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function\nto determine proxies.",
     "type": "boolean"
    },
    "proxy_url": {
     "$ref": "#/definitions/URL"
    },
    "tls_config": {
     "$ref": "#/definitions/TLSConfig"
    }
   },
   "title": "HTTPClientConfig configures an HTTP client.",
   "type": "object"
  },
  "Header": {
   "properties": {
    "files": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "secrets": {
     "items": {
      "$ref": "#/definitions/Secret"
     },
     "type": "array"
    },
    "values": {
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "title": "Header represents the configuration for a single HTTP header.",
   "type": "object"
  },
  "Headers": {
   "properties": {
    "Headers": {
     "additionalProperties": {
      "$ref": "#/definitions/Header"
     },
     "type": "object"
    }
   },
   "title": "Headers represents the configuration for HTTP headers.",
   "type": "object"
  },
  "HostPort": {
   "properties": {
    "Host": {
     "type": "string"
    },
    "Port": {
     "type": "string"
    }
   },
   "title": "HostPort represents a \"host:port\" network address.",
   "type": "object"
  },
  "InhibitRule": {
   "description": "InhibitRule defines an inhibition rule that mutes alerts that match the\ntarget labels if an alert matching the source labels exists.\nBoth alerts have to have a set of labels being equal.",
   "properties": {
    "equal": {
     "$ref": "#/definitions/LabelNames"
    },
    "source_match": {
     "additionalProperties": {
      "type": "string"
     },
     "description": "SourceMatch defines a set of labels that have to equal the given\nvalue for source alerts. Deprecated. Remove before v1.0 release.",
     "type": "object"
    },
    "source_match_re": {
     "$ref": "#/definitions/MatchRegexps"
    },
    "source_matchers": {
     "$ref": "#/definitions/Matchers"
    },
    "target_match": {
     "additionalProperties": {
      "type": "string"
     },
     "description": "TargetMatch defines a set of labels that have to equal the given\nvalue for target alerts. Deprecated. Remove before v1.0 release.",
     "type": "object"
    },
    "target_match_re": {
     "$ref": "#/definitions/MatchRegexps"
    },
    "target_matchers": {
     "$ref": "#/definitions/Matchers"
    }
   },
   "type": "object"
  },
  "InspectType": {
   "format": "int64",
   "title": "InspectType is a type for the Inspect property of a Notice.",
   "type": "integer"
  },
  "InternalDataLink": {
   "description": "InternalDataLink definition to allow Explore links to be constructed in the backend",
   "properties": {
    "datasourceName": {
     "type": "string"
    },
    "datasourceUid": {
     "type": "string"
    },
    "panelsState": {
     "$ref": "#/definitions/ExplorePanelsState"
    },
    "query": {},
    "timeRange": {
     "$ref": "#/definitions/TimeRange"
    },
    "transformations": {
     "items": {
      "$ref": "#/definitions/LinkTransformationConfig"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "JiraConfig": {
   "properties": {
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "custom_fields": {
     "additionalProperties": {},
     "type": "object"
    },
    "description": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "issue_type": {
     "type": "string"
    },
    "labels": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "priority": {
     "type": "string"
    },
    "project": {
     "type": "string"
    },
    "reopen_duration": {
     "$ref": "#/definitions/Duration"
    },
    "reopen_transition": {
     "type": "string"
    },
    "resolve_transition": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "summary": {
     "type": "string"
    },
    "wont_fix_resolution": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "Json": {
   "type": "object"
  },
  "Label": {
   "properties": {
    "Name": {
     "type": "string"
    }
   },
   "title": "Label is a key/value pair of strings.",
   "type": "object"
  },
  "LabelName": {
   "description": "A LabelName is a key for a LabelSet or Metric.  It has a value associated\ntherewith.",
   "type": "string"
  },
  "LabelNames": {
   "items": {
    "$ref": "#/definitions/LabelName"
   },
   "title": "LabelNames is a sortable LabelName slice. In implements sort.Interface.",
   "type": "array"
  },
  "LabelSet": {
   "additionalProperties": {
    "$ref": "#/definitions/LabelValue"
   },
   "description": "A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet\nmay be fully-qualified down to the point where it may resolve to a single\nMetric in the data store or not.  All operations that occur within the realm\nof a LabelSet can emit a vector of Metric entities to which the LabelSet may\nmatch.",
   "type": "object"
  },
  "LabelValue": {
   "title": "A LabelValue is an associated value for a LabelName.",
   "type": "string"
  },
  "Labels": {
   "description": "Labels is a sorted set of labels. Order has to be guaranteed upon\ninstantiation.",
   "items": {
    "$ref": "#/definitions/Label"
   },
   "type": "array"
  },
  "LinkTransformationConfig": {
   "properties": {
    "expression": {
     "type": "string"
    },
    "field": {
     "type": "string"
    },
    "mapValue": {
     "type": "string"
    },
    "type": {
     "$ref": "#/definitions/SupportedTransformationTypes"
    }
   },
   "type": "object"
  },
  "MSTeamsConfig": {
   "properties": {
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "summary": {
     "type": "string"
    },
    "text": {
     "type": "string"
    },
    "title": {
     "type": "string"
    },
    "webhook_url": {
     "$ref": "#/definitions/SecretURL"
    },
    "webhook_url_file": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "MatchRegexps": {
   "additionalProperties": {
    "type": "string"
   },
   "title": "MatchRegexps represents a map of Regexp.",
   "type": "object"
  },
  "MatchType": {
   "format": "int64",
   "title": "MatchType is an enum for label matching types.",
   "type": "integer"
  },
  "Matcher": {
   "properties": {
    "Name": {
     "type": "string"
    },
    "Type": {
     "$ref": "#/definitions/MatchType"
    },
    "Value": {
     "type": "string"
    }
   },
   "title": "Matcher models the matching of a label.",
   "type": "object"
  },
  "Matchers": {
   "description": "Matchers is a slice of Matchers that is sortable, implements Stringer, and\nprovides a Matches method to match a LabelSet against all Matchers in the\nslice. Note that some users of Matchers might require it to be sorted.",
   "items": {
    "$ref": "#/definitions/Matcher"
   },
   "type": "array"
  },
  "MultiStatus": {
   "type": "object"
  },
  "MuteTimeInterval": {
   "properties": {
    "name": {
     "type": "string"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "title": "MuteTimeInterval represents a named set of time intervals for which a route should be muted.",
   "type": "object"
  },
  "MuteTimeIntervalExport": {
   "properties": {
    "name": {
     "type": "string"
    },
    "orgId": {
     "format": "int64",
     "type": "integer"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "MuteTimings": {
   "items": {
    "$ref": "#/definitions/MuteTimeInterval"
   },
   "type": "array"
  },
  "NamespaceConfigResponse": {
   "additionalProperties": {
    "items": {
     "$ref": "#/definitions/GettableRuleGroupConfig"
    },
    "type": "array"
   },
   "type": "object"
  },
  "NotFound": {
   "type": "object"
  },
  "Notice": {
   "properties": {
    "inspect": {
     "$ref": "#/definitions/InspectType"
    },
    "link": {
     "description": "Link is an optional link for display in the user interface and can be an\nabsolute URL or a path relative to Grafana's root url.",
     "type": "string"
    },
    "severity": {
     "$ref": "#/definitions/NoticeSeverity"
    },
    "text": {
     "description": "Text is freeform descriptive text for the notice.",
     "type": "string"
    }
   },
   "title": "Notice provides a structure for presenting notifications in Grafana's user interface.",
   "type": "object"
  },
  "NoticeSeverity": {
   "format": "int64",
   "title": "NoticeSeverity is a type for the Severity property of a Notice.",
   "type": "integer"
  },
  "NotificationPolicyExport": {
   "properties": {
    "continue": {
     "type": "boolean"
    },
    "group_by": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "group_interval": {
     "type": "string"
    },
    "group_wait": {
     "type": "string"
    },
    "match": {
     "additionalProperties": {
      "type": "string"
     },
     "description": "Deprecated. Remove before v1.0 release.",
     "type": "object"
    },
    "match_re": {
     "$ref": "#/definitions/MatchRegexps"
    },
    "matchers": {
     "$ref": "#/definitions/Matchers"
    },
    "mute_time_intervals": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "object_matchers": {
     "$ref": "#/definitions/ObjectMatchers"
    },
    "orgId": {
     "format": "int64",
     "type": "integer"
    },
    "receiver": {
     "type": "string"
    },
    "repeat_interval": {
     "type": "string"
    },
    "routes": {
     "items": {
      "$ref": "#/definitions/RouteExport"
     },
     "type": "array"
    }
   },
   "title": "NotificationPolicyExport is the provisioned file export of alerting.NotificiationPolicyV1.",
   "type": "object"
  },
  "NotificationTemplate": {
   "properties": {
    "name": {
     "type": "string"
    },
    "provenance": {
     "$ref": "#/definitions/Provenance"
    },
    "template": {
     "type": "string"
    },
    "version": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "NotificationTemplateContent": {
   "properties": {
    "template": {
     "type": "string"
    },
    "version": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "NotificationTemplates": {
   "items": {
    "$ref": "#/definitions/NotificationTemplate"
   },
   "type": "array"
  },
  "NotifierConfig": {
   "properties": {
    "send_resolved": {
     "type": "boolean"
    }
   },
   "title": "NotifierConfig contains base options common across all notifier configurations.",
   "type": "object"
  },
  "OAuth2": {
   "properties": {
    "TLSConfig": {
     "$ref": "#/definitions/TLSConfig"
    },
    "client_id": {
     "type": "string"
    },
    "client_secret": {
     "$ref": "#/definitions/Secret"
    },
    "client_secret_file": {
     "type": "string"
    },
    "client_secret_ref": {
     "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client\nsecret.",
     "type": "string"
    },
    "endpoint_params": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "no_proxy": {
     "description": "NoProxy contains addresses that should not use a proxy.",
     "type": "string"
    },
    "proxy_connect_header": {
     "$ref": "#/definitions/ProxyHeader"
    },
    "proxy_from_environment": {
     "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function\nto determine proxies.",
     "type": "boolean"
    },
    "proxy_url": {
     "$ref": "#/definitions/URL"
    },
    "scopes": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "token_url": {
     "type": "string"
    }
   },
   "title": "OAuth2 is the oauth2 client configuration.",
   "type": "object"
  },
  "ObjectMatcher": {
   "items": {
    "type": "string"
   },
   "title": "ObjectMatcher is a matcher that can be used to filter alerts.",
   "type": "array"
  },
  "ObjectMatchers": {
   "items": {
    "$ref": "#/definitions/ObjectMatcher"
   },
   "type": "array"
  },
  "OpsGenieConfig": {
   "properties": {
    "actions": {
     "type": "string"
    },
    "api_key": {
     "$ref": "#/definitions/Secret"
    },
    "api_key_file": {
     "type": "string"
    },
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "description": {
     "type": "string"
    },
    "details": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "entity": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "note": {
     "type": "string"
    },
    "priority": {
     "type": "string"
    },
    "responders": {
     "items": {
      "$ref": "#/definitions/OpsGenieConfigResponder"
     },
     "type": "array"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "source": {
     "type": "string"
    },
    "tags": {
     "type": "string"
    },
    "update_alerts": {
     "type": "boolean"
    }
   },
   "title": "OpsGenieConfig configures notifications via OpsGenie.",
   "type": "object"
  },
  "OpsGenieConfigResponder": {
   "properties": {
    "id": {
     "description": "One of those 3 should be filled.",
     "type": "string"
    },
    "name": {
     "type": "string"
    },
    "type": {
     "description": "team, user, escalation, schedule etc.",
     "type": "string"
    },
    "username": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "PagerdutyConfig": {
   "properties": {
    "class": {
     "type": "string"
    },
    "client": {
     "type": "string"
    },
    "client_url": {
     "type": "string"
    },
    "component": {
     "type": "string"
    },
    "description": {
     "type": "string"
    },
    "details": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "group": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "images": {
     "items": {
      "$ref": "#/definitions/PagerdutyImage"
     },
     "type": "array"
    },
    "links": {
     "items": {
      "$ref": "#/definitions/PagerdutyLink"
     },
     "type": "array"
    },
    "routing_key": {
     "$ref": "#/definitions/Secret"
    },
    "routing_key_file": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "service_key": {
     "$ref": "#/definitions/Secret"
    },
    "service_key_file": {
     "type": "string"
    },
    "severity": {
     "type": "string"
    },
    "source": {
     "type": "string"
    },
    "url": {
     "$ref": "#/definitions/URL"
    }
   },
   "title": "PagerdutyConfig configures notifications via PagerDuty.",
   "type": "object"
  },
  "PagerdutyImage": {
   "properties": {
    "alt": {
     "type": "string"
    },
    "href": {
     "type": "string"
    },
    "src": {
     "type": "string"
    }
   },
   "title": "PagerdutyImage is an image.",
   "type": "object"
  },
  "PagerdutyLink": {
   "properties": {
    "href": {
     "type": "string"
    },
    "text": {
     "type": "string"
    }
   },
   "title": "PagerdutyLink is a link.",
   "type": "object"
  },
  "PermissionDenied": {
   "type": "object"
  },
  "PostableApiAlertingConfig": {
   "description": "nolint:revive",
   "properties": {
    "global": {
     "$ref": "#/definitions/GlobalConfig"
    },
    "inhibit_rules": {
     "items": {
      "$ref": "#/definitions/InhibitRule"
     },
     "type": "array"
    },
    "mute_time_intervals": {
     "description": "MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.",
     "items": {
      "$ref": "#/definitions/MuteTimeInterval"
     },
     "type": "array"
    },
    "receivers": {
     "description": "Override with our superset receiver type",
     "items": {
      "$ref": "#/definitions/PostableApiReceiver"
     },
     "type": "array"
    },
    "route": {
     "$ref": "#/definitions/Route"
    },
    "templates": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "PostableApiReceiver": {
   "description": "nolint:revive",
   "properties": {
    "discord_configs": {
     "items": {
      "$ref": "#/definitions/DiscordConfig"
     },
     "type": "array"
    },
    "email_configs": {
     "items": {
      "$ref": "#/definitions/EmailConfig"
     },
     "type": "array"
    },
    "grafana_managed_receiver_configs": {
     "items": {
      "$ref": "#/definitions/PostableGrafanaReceiver"
     },
     "type": "array"
    },
    "jira_configs": {
     "items": {
      "$ref": "#/definitions/JiraConfig"
     },
     "type": "array"
    },
    "msteams_configs": {
     "items": {
      "$ref": "#/definitions/MSTeamsConfig"
     },
     "type": "array"
    },
    "name": {
     "description": "A unique identifier for this receiver.",
     "type": "string"
    },
    "opsgenie_configs": {
     "items": {
      "$ref": "#/definitions/OpsGenieConfig"
     },
     "type": "array"
    },
    "pagerduty_configs": {
     "items": {
      "$ref": "#/definitions/PagerdutyConfig"
     },
     "type": "array"
    },
    "pushover_configs": {
     "items": {
      "$ref": "#/definitions/PushoverConfig"
     },
     "type": "array"
    },
    "slack_configs": {
     "items": {
      "$ref": "#/definitions/SlackConfig"
     },
     "type": "array"
    },
    "sns_configs": {
     "items": {
      "$ref": "#/definitions/SNSConfig"
     },
     "type": "array"
    },
    "telegram_configs": {
     "items": {
      "$ref": "#/definitions/TelegramConfig"
     },
     "type": "array"
    },
    "victorops_configs": {
     "items": {
      "$ref": "#/definitions/VictorOpsConfig"
     },
     "type": "array"
    },
    "webex_configs": {
     "items": {
      "$ref": "#/definitions/WebexConfig"
     },
     "type": "array"
    },
    "webhook_configs": {
     "items": {
      "$ref": "#/definitions/WebhookConfig"
     },
     "type": "array"
    },
    "wechat_configs": {
     "items": {
      "$ref": "#/definitions/WechatConfig"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "PostableExtendedRuleNode": {
   "properties": {
    "alert": {
     "type": "string"
    },
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "expr": {
     "type": "string"
    },
    "for": {
     "type": "string"
    },
    "grafana_alert": {
     "$ref": "#/definitions/PostableGrafanaRule"
    },
    "keep_firing_for": {
     "type": "string"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "record": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "PostableExtendedRuleNodeExtended": {
   "properties": {
    "folderTitle": {
     "example": "project_x",
     "type": "string"
    },
    "folderUid": {
     "example": "okrd3I0Vz",
     "type": "string"
    },
    "rule": {
     "$ref": "#/definitions/PostableExtendedRuleNode"
    },
    "ruleGroup": {
     "example": "eval_group_1",
     "type": "string"
    }
   },
   "required": [
    "rule"
   ],
   "type": "object"
  },
  "PostableGrafanaReceiver": {
   "properties": {
    "disableResolveMessage": {
     "type": "boolean"
    },
    "name": {
     "type": "string"
    },
    "secureSettings": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "settings": {
     "$ref": "#/definitions/RawMessage"
    },
    "type": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "PostableGrafanaReceivers": {
   "properties": {
    "grafana_managed_receiver_configs": {
     "items": {
      "$ref": "#/definitions/PostableGrafanaReceiver"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "PostableGrafanaRule": {
   "properties": {
    "condition": {
     "type": "string"
    },
    "data": {
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "exec_err_state": {
     "enum": [
      "OK",
      "Alerting",
      "Error"
     ],
     "type": "string"
    },
    "is_paused": {
     "type": "boolean"
    },
    "metadata": {
     "$ref": "#/definitions/AlertRuleMetadata"
    },
    "missing_series_evals_to_resolve": {
     "description": "Number of consecutive evaluation intervals with no data for a dimension must pass\nbefore the alert state is considered stale and automatically resolved.\nIf set to 0, the value is reset to the default.",
     "example": 3,
     "format": "int64",
     "type": "integer"
    },
    "no_data_state": {
     "enum": [
      "Alerting",
      "NoData",
      "OK"
     ],
     "type": "string"
    },
    "notification_settings": {
     "$ref": "#/definitions/AlertRuleNotificationSettings"
    },
    "record": {
     "$ref": "#/definitions/Record"
    },
    "title": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "PostableNGalertConfig": {
   "properties": {
    "alertmanagersChoice": {
     "enum": [
      "all",
      "internal",
      "external"
     ],
     "type": "string"
    }
   },
   "type": "object"
  },
  "PostableRuleGroupConfig": {
   "properties": {
    "align_evaluation_time_on_interval": {
     "type": "boolean"
    },
    "evaluation_delay": {
     "type": "string"
    },
    "interval": {
     "$ref": "#/definitions/Duration"
    },
    "limit": {
     "format": "int64",
     "type": "integer"
    },
    "name": {
     "type": "string"
    },
    "query_offset": {
     "type": "string"
    },
    "rules": {
     "items": {
      "$ref": "#/definitions/PostableExtendedRuleNode"
     },
     "type": "array"
    },
    "source_tenants": {
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "PostableUserConfig": {
   "properties": {
    "alertmanager_config": {
     "$ref": "#/definitions/PostableApiAlertingConfig"
    },
    "template_files": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    }
   },
   "type": "object"
  },
  "PrometheusNamespace": {
   "properties": {
    "Body": {
     "additionalProperties": {
      "items": {
       "$ref": "#/definitions/PrometheusRuleGroup"
      },
      "type": "array"
     },
     "description": "in: body",
     "type": "object"
    }
   },
   "type": "object"
  },
  "PrometheusRule": {
   "properties": {
    "Alert": {
     "type": "string"
    },
    "Annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "Expr": {
     "type": "string"
    },
    "For": {
     "type": "string"
    },
    "KeepFiringFor": {
     "type": "string"
    },
    "Labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "Record": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "PrometheusRuleGroup": {
   "properties": {
    "Interval": {
     "$ref": "#/definitions/Duration"
    },
    "Labels": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "Limit": {
     "format": "int64",
     "type": "integer"
    },
    "Name": {
     "type": "string"
    },
    "QueryOffset": {
     "type": "string"
    },
    "Rules": {
     "items": {
      "$ref": "#/definitions/PrometheusRule"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "Provenance": {
   "type": "string"
  },
  "ProvisionedAlertRule": {
   "properties": {
    "annotations": {
     "additionalProperties": {
      "type": "string"
     },
     "example": {
      "runbook_url": "https://supercoolrunbook.com/page/13"
     },
     "type": "object"
    },
    "condition": {
     "example": "A",
     "type": "string"
    },
    "data": {
     "example": [
      {
       "datasourceUid": "__expr__",
       "model": {
        "conditions": [
         {
          "evaluator": {
           "params": [
            0,
            0
           ],
           "type": "gt"
          },
          "operator": {
           "type": "and"
          },
          "query": {
           "params": []
          },
          "reducer": {
           "params": [],
           "type": "avg"
          },
          "type": "query"
         }
        ],
        "datasource": {
         "type": "__expr__",
         "uid": "__expr__"
        },
        "expression": "1 == 1",
        "hide": false,
        "intervalMs": 1000,
        "maxDataPoints": 43200,
        "refId": "A",
        "type": "math"
       },
       "queryType": "",
       "refId": "A",
       "relativeTimeRange": {
        "from": 0,
        "to": 0
       }
      }
     ],
     "items": {
      "$ref": "#/definitions/AlertQuery"
     },
     "type": "array"
    },
    "execErrState": {
     "enum": [
      "OK",
      "Alerting",
      "Error"
     ],
     "type": "string"
    },
    "folderUID": {
     "example": "project_x",
     "type": "string"
    },
    "for": {
     "format": "duration",
     "type": "string"
    },
    "id": {
     "format": "int64",
     "type": "integer"
    },
    "isPaused": {
     "example": false,
     "type": "boolean"
    },
    "keep_firing_for": {
     "format": "duration",
     "type": "string"
    },
    "labels": {
     "additionalProperties": {
      "type": "string"
     },
     "example": {
      "team": "sre-team-1"
     },
     "type": "object"
    },
    "missingSeriesEvalsToResolve": {
     "example": 2,
     "format": "int64",
     "type": "integer"
    },
    "noDataState": {
     "enum": [
      "Alerting",
      "NoData",
      "OK"
     ],
     "type": "string"
    },
    "notification_settings": {
     "$ref": "#/definitions/AlertRuleNotificationSettings"
    },
    "orgID": {
     "format": "int64",
     "type": "integer"
    },
    "provenance": {
     "$ref": "#/definitions/Provenance"
    },
    "record": {
     "$ref": "#/definitions/Record"
    },
    "ruleGroup": {
     "example": "eval_group_1",
     "maxLength": 190,
     "minLength": 1,
     "type": "string"
    },
    "title": {
     "example": "Always firing",
     "maxLength": 190,
     "minLength": 1,
     "type": "string"
    },
    "uid": {
     "maxLength": 40,
     "minLength": 1,
     "pattern": "^[a-zA-Z0-9-_]+$",
     "type": "string"
    },
    "updated": {
     "format": "date-time",
     "readOnly": true,
     "type": "string"
    }
   },
   "required": [
    "orgID",
    "folderUID",
    "ruleGroup",
    "title",
    "condition",
    "data",
    "noDataState",
    "execErrState",
    "for"
   ],
   "type": "object"
  },
  "ProvisionedAlertRules": {
   "items": {
    "$ref": "#/definitions/ProvisionedAlertRule"
   },
   "type": "array"
  },
  "ProxyConfig": {
   "properties": {
    "no_proxy": {
     "description": "NoProxy contains addresses that should not use a proxy.",
     "type": "string"
    },
    "proxy_connect_header": {
     "$ref": "#/definitions/ProxyHeader"
    },
    "proxy_from_environment": {
     "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function\nto determine proxies.",
     "type": "boolean"
    },
    "proxy_url": {
     "$ref": "#/definitions/URL"
    }
   },
   "type": "object"
  },
  "ProxyHeader": {
   "additionalProperties": {
    "items": {
     "$ref": "#/definitions/Secret"
    },
    "type": "array"
   },
   "type": "object"
  },
  "PublicError": {
   "description": "PublicError is derived from Error and only contains information\navailable to the end user.",
   "properties": {
    "extra": {
     "additionalProperties": {},
     "type": "object"
    },
    "message": {
     "type": "string"
    },
    "messageId": {
     "type": "string"
    },
    "statusCode": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "PushoverConfig": {
   "properties": {
    "device": {
     "type": "string"
    },
    "expire": {
     "type": "string"
    },
    "html": {
     "type": "boolean"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "priority": {
     "type": "string"
    },
    "retry": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "sound": {
     "type": "string"
    },
    "title": {
     "type": "string"
    },
    "token": {
     "$ref": "#/definitions/Secret"
    },
    "token_file": {
     "type": "string"
    },
    "ttl": {
     "type": "string"
    },
    "url": {
     "type": "string"
    },
    "url_title": {
     "type": "string"
    },
    "user_key": {
     "$ref": "#/definitions/Secret"
    },
    "user_key_file": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "QueryStat": {
   "description": "The embedded FieldConfig's display name must be set.\nIt corresponds to the QueryResultMetaStat on the frontend (https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L53).",
   "properties": {
    "color": {
     "additionalProperties": {},
     "description": "Map values to a display color\nNOTE: this interface is under development in the frontend... so simple map for now",
     "type": "object"
    },
    "custom": {
     "additionalProperties": {},
     "description": "Panel Specific Values",
     "type": "object"
    },
    "decimals": {
     "format": "uint16",
     "type": "integer"
    },
    "description": {
     "description": "Description is human readable field metadata",
     "type": "string"
    },
    "displayName": {
     "description": "DisplayName overrides Grafana default naming, should not be used from a data source",
     "type": "string"
    },
    "displayNameFromDS": {
     "description": "DisplayNameFromDS overrides Grafana default naming strategy.",
     "type": "string"
    },
    "filterable": {
     "description": "Filterable indicates if the Field's data can be filtered by additional calls.",
     "type": "boolean"
    },
    "interval": {
     "description": "Interval indicates the expected regular step between values in the series.\nWhen an interval exists, consumers can identify \"missing\" values when the expected value is not present.\nThe grafana timeseries visualization will render disconnected values when missing values are found it the time field.\nThe interval uses the same units as the values.  For time.Time, this is defined in milliseconds.",
     "format": "double",
     "type": "number"
    },
    "links": {
     "description": "The behavior when clicking on a result",
     "items": {
      "$ref": "#/definitions/DataLink"
     },
     "type": "array"
    },
    "mappings": {
     "$ref": "#/definitions/ValueMappings"
    },
    "max": {
     "$ref": "#/definitions/ConfFloat64"
    },
    "min": {
     "$ref": "#/definitions/ConfFloat64"
    },
    "noValue": {
     "description": "Alternative to empty string",
     "type": "string"
    },
    "path": {
     "description": "Path is an explicit path to the field in the datasource. When the frame meta includes a path,\nthis will default to `${frame.meta.path}/${field.name}\n\nWhen defined, this value can be used as an identifier within the datasource scope, and\nmay be used as an identifier to update values in a subsequent request",
     "type": "string"
    },
    "thresholds": {
     "$ref": "#/definitions/ThresholdsConfig"
    },
    "type": {
     "$ref": "#/definitions/FieldTypeConfig"
    },
    "unit": {
     "description": "Numeric Options",
     "type": "string"
    },
    "value": {
     "format": "double",
     "type": "number"
    },
    "writeable": {
     "description": "Writeable indicates that the datasource knows how to update this value",
     "type": "boolean"
    }
   },
   "title": "QueryStat is used for storing arbitrary statistics metadata related to a query and its result, e.g. total request time, data processing time.",
   "type": "object"
  },
  "RawMessage": {
   "type": "object"
  },
  "Receiver": {
   "properties": {
    "discord_configs": {
     "items": {
      "$ref": "#/definitions/DiscordConfig"
     },
     "type": "array"
    },
    "email_configs": {
     "items": {
      "$ref": "#/definitions/EmailConfig"
     },
     "type": "array"
    },
    "jira_configs": {
     "items": {
      "$ref": "#/definitions/JiraConfig"
     },
     "type": "array"
    },
    "msteams_configs": {
     "items": {
      "$ref": "#/definitions/MSTeamsConfig"
     },
     "type": "array"
    },
    "name": {
     "description": "A unique identifier for this receiver.",
     "type": "string"
    },
    "opsgenie_configs": {
     "items": {
      "$ref": "#/definitions/OpsGenieConfig"
     },
     "type": "array"
    },
    "pagerduty_configs": {
     "items": {
      "$ref": "#/definitions/PagerdutyConfig"
     },
     "type": "array"
    },
    "pushover_configs": {
     "items": {
      "$ref": "#/definitions/PushoverConfig"
     },
     "type": "array"
    },
    "slack_configs": {
     "items": {
      "$ref": "#/definitions/SlackConfig"
     },
     "type": "array"
    },
    "sns_configs": {
     "items": {
      "$ref": "#/definitions/SNSConfig"
     },
     "type": "array"
    },
    "telegram_configs": {
     "items": {
      "$ref": "#/definitions/TelegramConfig"
     },
     "type": "array"
    },
    "victorops_configs": {
     "items": {
      "$ref": "#/definitions/VictorOpsConfig"
     },
     "type": "array"
    },
    "webex_configs": {
     "items": {
      "$ref": "#/definitions/WebexConfig"
     },
     "type": "array"
    },
    "webhook_configs": {
     "items": {
      "$ref": "#/definitions/WebhookConfig"
     },
     "type": "array"
    },
    "wechat_configs": {
     "items": {
      "$ref": "#/definitions/WechatConfig"
     },
     "type": "array"
    }
   },
   "title": "Receiver configuration provides configuration on how to contact a receiver.",
   "type": "object"
  },
  "ReceiverExport": {
   "properties": {
    "disableResolveMessage": {
     "type": "boolean"
    },
    "settings": {
     "$ref": "#/definitions/RawMessage"
    },
    "type": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "title": "ReceiverExport is the provisioned file export of alerting.ReceiverV1.",
   "type": "object"
  },
  "Record": {
   "properties": {
    "from": {
     "description": "Which expression node should be used as the input for the recorded metric.",
     "example": "A",
     "type": "string"
    },
    "metric": {
     "description": "Name of the recorded metric.",
     "example": "grafana_alerts_ratio",
     "type": "string"
    },
    "target_datasource_uid": {
     "description": "Which data source should be used to write the output of the recording rule, specified by UID.",
     "example": "my-prom",
     "type": "string"
    }
   },
   "required": [
    "metric",
    "from"
   ],
   "type": "object"
  },
  "RelativeTimeRange": {
   "description": "RelativeTimeRange is the per query start and end time\nfor requests.",
   "properties": {
    "from": {
     "$ref": "#/definitions/Duration"
    },
    "to": {
     "$ref": "#/definitions/Duration"
    }
   },
   "type": "object"
  },
  "RelativeTimeRangeExport": {
   "properties": {
    "from": {
     "format": "int64",
     "type": "integer"
    },
    "to": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "ResponseDetails": {
   "properties": {
    "msg": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "Responses": {
   "additionalProperties": {
    "$ref": "#/definitions/DataResponse"
   },
   "description": "The QueryData method the QueryDataHandler method will set the RefId\nproperty on the DataResponses' frames based on these RefIDs.",
   "title": "Responses is a map of RefIDs (Unique Query ID) to DataResponses.",
   "type": "object"
  },
  "Route": {
   "description": "A Route is a node that contains definitions of how to handle alerts. This is modified\nfrom the upstream alertmanager in that it adds the ObjectMatchers property.",
   "properties": {
    "active_time_intervals": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "continue": {
     "type": "boolean"
    },
    "group_by": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "group_interval": {
     "type": "string"
    },
    "group_wait": {
     "type": "string"
    },
    "match": {
     "additionalProperties": {
      "type": "string"
     },
     "description": "Deprecated. Remove before v1.0 release.",
     "type": "object"
    },
    "match_re": {
     "$ref": "#/definitions/MatchRegexps"
    },
    "matchers": {
     "$ref": "#/definitions/Matchers"
    },
    "mute_time_intervals": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "object_matchers": {
     "$ref": "#/definitions/ObjectMatchers"
    },
    "provenance": {
     "$ref": "#/definitions/Provenance"
    },
    "receiver": {
     "type": "string"
    },
    "repeat_interval": {
     "type": "string"
    },
    "routes": {
     "items": {
      "$ref": "#/definitions/Route"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "RouteExport": {
   "description": "RouteExport is the provisioned file export of definitions.Route. This is needed to hide fields that aren't useable in\nprovisioning file format. An alternative would be to define a custom MarshalJSON and MarshalYAML that excludes them.",
   "properties": {
    "continue": {
     "type": "boolean"
    },
    "group_by": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "group_interval": {
     "type": "string"
    },
    "group_wait": {
     "type": "string"
    },
    "match": {
     "additionalProperties": {
      "type": "string"
     },
     "description": "Deprecated. Remove before v1.0 release.",
     "type": "object"
    },
    "match_re": {
     "$ref": "#/definitions/MatchRegexps"
    },
    "matchers": {
     "$ref": "#/definitions/Matchers"
    },
    "mute_time_intervals": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "object_matchers": {
     "$ref": "#/definitions/ObjectMatchers"
    },
    "receiver": {
     "type": "string"
    },
    "repeat_interval": {
     "type": "string"
    },
    "routes": {
     "items": {
      "$ref": "#/definitions/RouteExport"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "Rule": {
   "description": "adapted from cortex",
   "properties": {
    "evaluationTime": {
     "format": "double",
     "type": "number"
    },
    "folderUid": {
     "type": "string"
    },
    "health": {
     "type": "string"
    },
    "labels": {
     "$ref": "#/definitions/Labels"
    },
    "lastError": {
     "type": "string"
    },
    "lastEvaluation": {
     "format": "date-time",
     "type": "string"
    },
    "name": {
     "type": "string"
    },
    "query": {
     "type": "string"
    },
    "type": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "required": [
    "uid",
    "name",
    "folderUid",
    "query",
    "health",
    "type"
   ],
   "type": "object"
  },
  "RuleDiscovery": {
   "properties": {
    "groupNextToken": {
     "type": "string"
    },
    "groups": {
     "items": {
      "$ref": "#/definitions/RuleGroup"
     },
     "type": "array"
    },
    "totals": {
     "additionalProperties": {
      "format": "int64",
      "type": "integer"
     },
     "type": "object"
    }
   },
   "required": [
    "groups"
   ],
   "type": "object"
  },
  "RuleGroup": {
   "properties": {
    "evaluationTime": {
     "format": "double",
     "type": "number"
    },
    "file": {
     "type": "string"
    },
    "folderUid": {
     "type": "string"
    },
    "interval": {
     "format": "double",
     "type": "number"
    },
    "lastEvaluation": {
     "format": "date-time",
     "type": "string"
    },
    "name": {
     "type": "string"
    },
    "rules": {
     "description": "In order to preserve rule ordering, while exposing type (alerting or recording)\nspecific properties, both alerting and recording rules are exposed in the\nsame array.",
     "items": {
      "$ref": "#/definitions/AlertingRule"
     },
     "type": "array"
    },
    "totals": {
     "additionalProperties": {
      "format": "int64",
      "type": "integer"
     },
     "type": "object"
    }
   },
   "required": [
    "name",
    "file",
    "folderUid",
    "rules",
    "interval"
   ],
   "type": "object"
  },
  "RuleGroupConfigResponse": {
   "properties": {
    "align_evaluation_time_on_interval": {
     "type": "boolean"
    },
    "evaluation_delay": {
     "type": "string"
    },
    "interval": {
     "$ref": "#/definitions/Duration"
    },
    "limit": {
     "format": "int64",
     "type": "integer"
    },
    "name": {
     "type": "string"
    },
    "query_offset": {
     "type": "string"
    },
    "rules": {
     "items": {
      "$ref": "#/definitions/GettableExtendedRuleNode"
     },
     "type": "array"
    },
    "source_tenants": {
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "RuleResponse": {
   "properties": {
    "data": {
     "$ref": "#/definitions/RuleDiscovery"
    },
    "error": {
     "type": "string"
    },
    "errorType": {
     "$ref": "#/definitions/ErrorType"
    },
    "status": {
     "type": "string"
    }
   },
   "required": [
    "status"
   ],
   "type": "object"
  },
  "SNSConfig": {
   "properties": {
    "api_url": {
     "type": "string"
    },
    "attributes": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "phone_number": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "sigv4": {
     "$ref": "#/definitions/SigV4Config"
    },
    "subject": {
     "type": "string"
    },
    "target_arn": {
     "type": "string"
    },
    "topic_arn": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "Sample": {
   "description": "Sample is a single sample belonging to a metric. It represents either a float\nsample or a histogram sample. If H is nil, it is a float sample. Otherwise,\nit is a histogram sample.",
   "properties": {
    "DropName": {
     "description": "DropName is used to indicate whether the __name__ label should be dropped\nas part of the query evaluation.",
     "type": "boolean"
    },
    "F": {
     "format": "double",
     "type": "number"
    },
    "H": {
     "$ref": "#/definitions/FloatHistogram"
    },
    "Metric": {
     "$ref": "#/definitions/Labels"
    },
    "T": {
     "format": "int64",
     "type": "integer"
    }
   },
   "type": "object"
  },
  "Secret": {
   "title": "Secret special type for storing secrets.",
   "type": "string"
  },
  "SecretURL": {
   "$ref": "#/definitions/URL",
   "title": "SecretURL is a URL that must not be revealed on marshaling."
  },
  "SigV4Config": {
   "description": "SigV4Config is the configuration for signing remote write requests with\nAWS's SigV4 verification process. Empty values will be retrieved using the\nAWS default credentials chain.",
   "properties": {
    "AccessKey": {
     "type": "string"
    },
    "Profile": {
     "type": "string"
    },
    "Region": {
     "type": "string"
    },
    "RoleARN": {
     "type": "string"
    },
    "SecretKey": {
     "$ref": "#/definitions/Secret"
    }
   },
   "type": "object"
  },
  "SilenceMetadata": {
   "properties": {
    "folder_uid": {
     "type": "string"
    },
    "rule_title": {
     "type": "string"
    },
    "rule_uid": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "SlackAction": {
   "description": "See https://api.slack.com/docs/message-attachments#action_fields and https://api.slack.com/docs/message-buttons\nfor more information.",
   "properties": {
    "confirm": {
     "$ref": "#/definitions/SlackConfirmationField"
    },
    "name": {
     "type": "string"
    },
    "style": {
     "type": "string"
    },
    "text": {
     "type": "string"
    },
    "type": {
     "type": "string"
    },
    "url": {
     "type": "string"
    },
    "value": {
     "type": "string"
    }
   },
   "title": "SlackAction configures a single Slack action that is sent with each notification.",
   "type": "object"
  },
  "SlackConfig": {
   "properties": {
    "actions": {
     "items": {
      "$ref": "#/definitions/SlackAction"
     },
     "type": "array"
    },
    "api_url": {
     "$ref": "#/definitions/SecretURL"
    },
    "api_url_file": {
     "type": "string"
    },
    "callback_id": {
     "type": "string"
    },
    "channel": {
     "description": "Slack channel override, (like #other-channel or @username).",
     "type": "string"
    },
    "color": {
     "type": "string"
    },
    "fallback": {
     "type": "string"
    },
    "fields": {
     "items": {
      "$ref": "#/definitions/SlackField"
     },
     "type": "array"
    },
    "footer": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "icon_emoji": {
     "type": "string"
    },
    "icon_url": {
     "type": "string"
    },
    "image_url": {
     "type": "string"
    },
    "link_names": {
     "type": "boolean"
    },
    "mrkdwn_in": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "pretext": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "short_fields": {
     "type": "boolean"
    },
    "text": {
     "type": "string"
    },
    "thumb_url": {
     "type": "string"
    },
    "title": {
     "type": "string"
    },
    "title_link": {
     "type": "string"
    },
    "username": {
     "type": "string"
    }
   },
   "title": "SlackConfig configures notifications via Slack.",
   "type": "object"
  },
  "SlackConfirmationField": {
   "description": "SlackConfirmationField protect users from destructive actions or particularly distinguished decisions\nby asking them to confirm their button click one more time.\nSee https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information.",
   "properties": {
    "dismiss_text": {
     "type": "string"
    },
    "ok_text": {
     "type": "string"
    },
    "text": {
     "type": "string"
    },
    "title": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "SlackField": {
   "description": "Each field must contain a title, value, and optionally, a boolean value to indicate if the field\nis short enough to be displayed next to other fields designated as short.\nSee https://api.slack.com/docs/message-attachments#fields for more information.",
   "properties": {
    "short": {
     "type": "boolean"
    },
    "title": {
     "type": "string"
    },
    "value": {
     "type": "string"
    }
   },
   "title": "SlackField configures a single Slack field that is sent with each notification.",
   "type": "object"
  },
  "SmtpNotEnabled": {
   "$ref": "#/definitions/ResponseDetails"
  },
  "Source": {
   "title": "Source type defines the status source.",
   "type": "string"
  },
  "Span": {
   "properties": {
    "Length": {
     "description": "Length of the span.",
     "format": "uint32",
     "type": "integer"
    },
    "Offset": {
     "description": "Gap to previous span (always positive), or starting index for the 1st\nspan (which can be negative).",
     "format": "int32",
     "type": "integer"
    }
   },
   "title": "A Span defines a continuous sequence of buckets.",
   "type": "object"
  },
  "Status": {
   "format": "int64",
   "type": "integer"
  },
  "Success": {
   "$ref": "#/definitions/ResponseDetails"
  },
  "SupportedTransformationTypes": {
   "type": "string"
  },
  "TLSConfig": {
   "properties": {
    "ca": {
     "description": "Text of the CA cert to use for the targets.",
     "type": "string"
    },
    "ca_file": {
     "description": "The CA cert to use for the targets.",
     "type": "string"
    },
    "ca_ref": {
     "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the\ntargets.",
     "type": "string"
    },
    "cert": {
     "description": "Text of the client cert file for the targets.",
     "type": "string"
    },
    "cert_file": {
     "description": "The client cert file for the targets.",
     "type": "string"
    },
    "cert_ref": {
     "description": "CertRef is the name of the secret within the secret manager to use as the client cert for\nthe targets.",
     "type": "string"
    },
    "insecure_skip_verify": {
     "description": "Disable target certificate validation.",
     "type": "boolean"
    },
    "key": {
     "$ref": "#/definitions/Secret"
    },
    "key_file": {
     "description": "The client key file for the targets.",
     "type": "string"
    },
    "key_ref": {
     "description": "KeyRef is the name of the secret within the secret manager to use as the client key for\nthe targets.",
     "type": "string"
    },
    "max_version": {
     "$ref": "#/definitions/TLSVersion"
    },
    "min_version": {
     "$ref": "#/definitions/TLSVersion"
    },
    "server_name": {
     "description": "Used to verify the hostname for the targets.",
     "type": "string"
    }
   },
   "title": "TLSConfig configures the options for TLS connections.",
   "type": "object"
  },
  "TLSVersion": {
   "format": "uint16",
   "type": "integer"
  },
  "TelegramConfig": {
   "properties": {
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "chat": {
     "format": "int64",
     "type": "integer"
    },
    "disable_notifications": {
     "type": "boolean"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "parse_mode": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "token": {
     "$ref": "#/definitions/Secret"
    },
    "token_file": {
     "type": "string"
    }
   },
   "title": "TelegramConfig configures notifications via Telegram.",
   "type": "object"
  },
  "TestReceiverConfigResult": {
   "properties": {
    "error": {
     "type": "string"
    },
    "name": {
     "type": "string"
    },
    "status": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "TestReceiverResult": {
   "properties": {
    "grafana_managed_receiver_configs": {
     "items": {
      "$ref": "#/definitions/TestReceiverConfigResult"
     },
     "type": "array"
    },
    "name": {
     "type": "string"
    }
   },
   "type": "object"
  },
  "TestReceiversConfigAlertParams": {
   "properties": {
    "annotations": {
     "$ref": "#/definitions/LabelSet"
    },
    "labels": {
     "$ref": "#/definitions/LabelSet"
    }
   },
   "type": "object"
  },
  "TestReceiversConfigBodyParams": {
   "properties": {
    "alert": {
     "$ref": "#/definitions/TestReceiversConfigAlertParams"
    },
    "receivers": {
     "items": {
      "$ref": "#/definitions/PostableApiReceiver"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "TestReceiversResult": {
   "properties": {
    "alert": {
     "$ref": "#/definitions/TestReceiversConfigAlertParams"
    },
    "notified_at": {
     "format": "date-time",
     "type": "string"
    },
    "receivers": {
     "items": {
      "$ref": "#/definitions/TestReceiverResult"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "TestRulePayload": {
   "properties": {
    "expr": {
     "example": "(node_filesystem_avail_bytes{fstype!=\"\",job=\"integrations/node_exporter\"} node_filesystem_size_bytes{fstype!=\"\",job=\"integrations/node_exporter\"} * 100 \u003c 5 and node_filesystem_readonly{fstype!=\"\",job=\"integrations/node_exporter\"} == 0)",
     "type": "string"
    },
    "grafana_condition": {
     "$ref": "#/definitions/EvalAlertConditionCommand"
    }
   },
   "type": "object"
  },
  "TestRuleResponse": {
   "properties": {
    "alerts": {
     "$ref": "#/definitions/Vector"
    },
    "grafana_alert_instances": {
     "$ref": "#/definitions/AlertInstancesResponse"
    }
   },
   "type": "object"
  },
  "TestTemplatesConfigBodyParams": {
   "properties": {
    "alerts": {
     "description": "Alerts to use as data when testing the template.",
     "items": {
      "$ref": "#/definitions/postableAlert"
     },
     "type": "array"
    },
    "name": {
     "description": "Name of the template file.",
     "type": "string"
    },
    "template": {
     "description": "Template string to test.",
     "type": "string"
    }
   },
   "type": "object"
  },
  "TestTemplatesErrorResult": {
   "properties": {
    "kind": {
     "description": "Kind of template error that occurred.",
     "enum": [
      "invalid_template",
      "execution_error"
     ],
     "type": "string"
    },
    "message": {
     "description": "Error message.",
     "type": "string"
    },
    "name": {
     "description": "Name of the associated template for this error. Will be empty if the Kind is \"invalid_template\".",
     "type": "string"
    }
   },
   "type": "object"
  },
  "TestTemplatesResult": {
   "properties": {
    "name": {
     "description": "Name of the associated template definition for this result.",
     "type": "string"
    },
    "scope": {
     "description": "Scope that was successfully used to interpolate the template. If the root scope \".\" fails, more specific\nscopes will be tried, such as \".Alerts', or \".Alert\".",
     "enum": [
      ".",
      ".Alerts",
      ".Alert"
     ],
     "type": "string"
    },
    "text": {
     "description": "Interpolated value of the template.",
     "type": "string"
    }
   },
   "type": "object"
  },
  "TestTemplatesResults": {
   "properties": {
    "errors": {
     "items": {
      "$ref": "#/definitions/TestTemplatesErrorResult"
     },
     "type": "array"
    },
    "results": {
     "items": {
      "$ref": "#/definitions/TestTemplatesResult"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "Threshold": {
   "description": "Threshold a single step on the threshold list",
   "properties": {
    "color": {
     "type": "string"
    },
    "state": {
     "type": "string"
    },
    "value": {
     "$ref": "#/definitions/ConfFloat64"
    }
   },
   "type": "object"
  },
  "ThresholdsConfig": {
   "description": "ThresholdsConfig setup thresholds",
   "properties": {
    "mode": {
     "$ref": "#/definitions/ThresholdsMode"
    },
    "steps": {
     "description": "Must be sorted by 'value', first value is always -Infinity",
     "items": {
      "$ref": "#/definitions/Threshold"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "ThresholdsMode": {
   "description": "ThresholdsMode absolute or percentage",
   "type": "string"
  },
  "TimeInterval": {
   "properties": {
    "name": {
     "type": "string"
    },
    "time_intervals": {
     "items": {
      "$ref": "#/definitions/TimeInterval"
     },
     "type": "array"
    }
   },
   "title": "TimeInterval represents a named set of time intervals for which a route should be muted.",
   "type": "object"
  },
  "TimeRange": {
   "description": "Redefining this to avoid an import cycle",
   "properties": {
    "from": {
     "format": "date-time",
     "type": "string"
    },
    "to": {
     "format": "date-time",
     "type": "string"
    }
   },
   "type": "object"
  },
  "URL": {
   "description": "The general form represented is:\n\n[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\nscheme:opaque[?query][#fragment]\n\nThe Host field contains the host and port subcomponents of the URL.\nWhen the port is present, it is separated from the host with a colon.\nWhen the host is an IPv6 address, it must be enclosed in square brackets:\n\"[fe80::1]:80\". The [net.JoinHostPort] function combines a host and port\ninto a string suitable for the Host field, adding square brackets to\nthe host when necessary.\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, the code should use the [URL.EscapedPath] method, which preserves\nthe original encoding of Path.\n\nThe RawPath field is an optional field which is only set when the default\nencoding of Path is different from the escaped path. See the EscapedPath method\nfor more details.\n\nURL's String method uses the EscapedPath method to obtain the path.",
   "properties": {
    "ForceQuery": {
     "type": "boolean"
    },
    "Fragment": {
     "type": "string"
    },
    "Host": {
     "type": "string"
    },
    "OmitHost": {
     "type": "boolean"
    },
    "Opaque": {
     "type": "string"
    },
    "Path": {
     "type": "string"
    },
    "RawFragment": {
     "type": "string"
    },
    "RawPath": {
     "type": "string"
    },
    "RawQuery": {
     "type": "string"
    },
    "Scheme": {
     "type": "string"
    },
    "User": {
     "$ref": "#/definitions/Userinfo"
    }
   },
   "title": "A URL represents a parsed URL (technically, a URI reference).",
   "type": "object"
  },
  "UpdateRuleGroupResponse": {
   "properties": {
    "created": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "deleted": {
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "message": {
     "type": "string"
    },
    "updated": {
     "items": {
      "type": "string"
     },
     "type": "array"
    }
   },
   "type": "object"
  },
  "UserInfo": {
   "properties": {
    "name": {
     "type": "string"
    },
    "uid": {
     "type": "string"
    }
   },
   "title": "UserInfo represents user-related information, including a unique identifier and a name.",
   "type": "object"
  },
  "Userinfo": {
   "description": "The Userinfo type is an immutable encapsulation of username and\npassword details for a [URL]. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.",
   "type": "object"
  },
  "ValidationError": {
   "properties": {
    "message": {
     "example": "error message",
     "type": "string"
    }
   },
   "type": "object"
  },
  "ValueMapping": {
   "description": "ValueMapping allows mapping input values to text and color",
   "type": "object"
  },
  "ValueMappings": {
   "items": {
    "$ref": "#/definitions/ValueMapping"
   },
   "type": "array"
  },
  "Vector": {
   "description": "Vector is basically only an alias for []Sample, but the contract is that\nin a Vector, all Samples have the same timestamp.",
   "items": {
    "$ref": "#/definitions/Sample"
   },
   "type": "array"
  },
  "VictorOpsConfig": {
   "properties": {
    "api_key": {
     "$ref": "#/definitions/Secret"
    },
    "api_key_file": {
     "type": "string"
    },
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "custom_fields": {
     "additionalProperties": {
      "type": "string"
     },
     "type": "object"
    },
    "entity_display_name": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message_type": {
     "type": "string"
    },
    "monitoring_tool": {
     "type": "string"
    },
    "routing_key": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "state_message": {
     "type": "string"
    }
   },
   "title": "VictorOpsConfig configures notifications via VictorOps.",
   "type": "object"
  },
  "VisType": {
   "title": "VisType is used to indicate how the data should be visualized in explore.",
   "type": "string"
  },
  "WebexConfig": {
   "properties": {
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "room_id": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    }
   },
   "title": "WebexConfig configures notifications via Webex.",
   "type": "object"
  },
  "WebhookConfig": {
   "properties": {
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "max_alerts": {
     "description": "MaxAlerts is the maximum number of alerts to be sent per webhook message.\nAlerts exceeding this threshold will be truncated. Setting this to 0\nallows an unlimited number of alerts.",
     "format": "uint64",
     "type": "integer"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "timeout": {
     "$ref": "#/definitions/Duration"
    },
    "url": {
     "$ref": "#/definitions/SecretURL"
    },
    "url_file": {
     "type": "string"
    }
   },
   "title": "WebhookConfig configures notifications via a generic webhook.",
   "type": "object"
  },
  "WechatConfig": {
   "properties": {
    "agent_id": {
     "type": "string"
    },
    "api_secret": {
     "$ref": "#/definitions/Secret"
    },
    "api_url": {
     "$ref": "#/definitions/URL"
    },
    "corp_id": {
     "type": "string"
    },
    "http_config": {
     "$ref": "#/definitions/HTTPClientConfig"
    },
    "message": {
     "type": "string"
    },
    "message_type": {
     "type": "string"
    },
    "send_resolved": {
     "type": "boolean"
    },
    "to_party": {
     "type": "string"
    },
    "to_tag": {
     "type": "string"
    },
    "to_user": {
     "type": "string"
    }
   },
   "title": "WechatConfig configures notifications via Wechat.",
   "type": "object"
  },
  "alert": {
   "description": "Alert alert",
   "properties": {
    "generatorURL": {
     "description": "generator URL\nFormat: uri",
     "format": "uri",
     "type": "string"
    },
    "labels": {
     "$ref": "#/definitions/labelSet"
    }
   },
   "required": [
    "labels"
   ],
   "type": "object"
  },
  "alertGroup": {
   "description": "AlertGroup alert group",
   "properties": {
    "alerts": {
     "description": "alerts",
     "items": {
      "$ref": "#/definitions/gettableAlert"
     },
     "type": "array"
    },
    "labels": {
     "$ref": "#/definitions/labelSet"
    },
    "receiver": {
     "$ref": "#/definitions/receiver"
    }
   },
   "required": [
    "alerts",
    "labels",
    "receiver"
   ],
   "type": "object"
  },
  "alertGroups": {
   "items": {
    "$ref": "#/definitions/alertGroup",
    "type": "object"
   },
   "type": "array"
  },
  "alertStatus": {
   "description": "AlertStatus alert status",
   "properties": {
    "inhibitedBy": {
     "description": "inhibited by",
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "silencedBy": {
     "description": "silenced by",
     "items": {
      "type": "string"
     },
     "type": "array"
    },
    "state": {
     "description": "state",
     "enum": [
      "[unprocessed active suppressed]"
     ],
     "type": "string"
    }
   },
   "required": [
    "inhibitedBy",
    "silencedBy",
    "state"
   ],
   "type": "object"
  },
  "alertmanagerConfig": {
   "description": "AlertmanagerConfig alertmanager config",
   "properties": {
    "original": {
     "description": "original",
     "type": "string"
    }
   },
   "required": [
    "original"
   ],
   "type": "object"
  },
  "alertmanagerStatus": {
   "description": "AlertmanagerStatus alertmanager status",
   "properties": {
    "cluster": {
     "$ref": "#/definitions/clusterStatus"
    },
    "config": {
     "$ref": "#/definitions/alertmanagerConfig"
    },
    "uptime": {
     "description": "uptime",
     "format": "date-time",
     "type": "string"
    },
    "versionInfo": {
     "$ref": "#/definitions/versionInfo"
    }
   },
   "required": [
    "cluster",
    "config",
    "uptime",
    "versionInfo"
   ],
   "type": "object"
  },
  "clusterStatus": {
   "description": "ClusterStatus cluster status",
   "properties": {
    "name": {
     "description": "name",
     "type": "string"
    },
    "peers": {
     "description": "peers",
     "items": {
      "$ref": "#/definitions/peerStatus"
     },
     "type": "array"
    },
    "status": {
     "description": "status",
     "enum": [
      "[ready settling disabled]"
     ],
     "type": "string"
    }
   },
   "required": [
    "status"
   ],
   "type": "object"
  },
  "gettableAlert": {
   "description": "GettableAlert gettable alert",
   "properties": {
    "annotations": {
     "$ref": "#/definitions/labelSet"
    },
    "endsAt": {
     "description": "ends at",
     "format": "date-time",
     "type": "string"
    },
    "fingerprint": {
     "description": "fingerprint",
     "type": "string"
    },
    "generatorURL": {
     "description": "generator URL\nFormat: uri",
     "format": "uri",
     "type": "string"
    },
    "labels": {
     "$ref": "#/definitions/labelSet"
    },
    "receivers": {
     "description": "receivers",
     "items": {
      "$ref": "#/definitions/receiver"
     },
     "type": "array"
    },
    "startsAt": {
     "description": "starts at",
     "format": "date-time",
     "type": "string"
    },
    "status": {
     "$ref": "#/definitions/alertStatus"
    },
    "updatedAt": {
     "description": "updated at",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "labels",
    "annotations",
    "endsAt",
    "fingerprint",
    "receivers",
    "startsAt",
    "status",
    "updatedAt"
   ],
   "type": "object"
  },
  "gettableAlerts": {
   "description": "GettableAlerts gettable alerts",
   "items": {
    "$ref": "#/definitions/gettableAlert",
    "type": "object"
   },
   "type": "array"
  },
  "gettableGrafanaSilence": {
   "properties": {
    "accessControl": {
     "additionalProperties": {
      "type": "boolean"
     },
     "example": {
      "create": false,
      "read": true,
      "write": false
     },
     "type": "object"
    },
    "comment": {
     "description": "comment",
     "type": "string"
    },
    "createdBy": {
     "description": "created by",
     "type": "string"
    },
    "endsAt": {
     "description": "ends at",
     "format": "date-time",
     "type": "string"
    },
    "id": {
     "description": "id",
     "type": "string"
    },
    "matchers": {
     "$ref": "#/definitions/matchers"
    },
    "metadata": {
     "$ref": "#/definitions/SilenceMetadata"
    },
    "startsAt": {
     "description": "starts at",
     "format": "date-time",
     "type": "string"
    },
    "status": {
     "$ref": "#/definitions/silenceStatus"
    },
    "updatedAt": {
     "description": "updated at",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "comment",
    "createdBy",
    "endsAt",
    "matchers",
    "startsAt",
    "id",
    "status",
    "updatedAt"
   ],
   "type": "object"
  },
  "gettableGrafanaSilences": {
   "items": {
    "$ref": "#/definitions/gettableGrafanaSilence"
   },
   "type": "array"
  },
  "gettableSilence": {
   "description": "GettableSilence gettable silence",
   "properties": {
    "comment": {
     "description": "comment",
     "type": "string"
    },
    "createdBy": {
     "description": "created by",
     "type": "string"
    },
    "endsAt": {
     "description": "ends at",
     "format": "date-time",
     "type": "string"
    },
    "id": {
     "description": "id",
     "type": "string"
    },
    "matchers": {
     "$ref": "#/definitions/matchers"
    },
    "startsAt": {
     "description": "starts at",
     "format": "date-time",
     "type": "string"
    },
    "status": {
     "$ref": "#/definitions/silenceStatus"
    },
    "updatedAt": {
     "description": "updated at",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "comment",
    "createdBy",
    "endsAt",
    "matchers",
    "startsAt",
    "id",
    "status",
    "updatedAt"
   ],
   "type": "object"
  },
  "gettableSilences": {
   "description": "GettableSilences gettable silences",
   "items": {
    "$ref": "#/definitions/gettableSilence",
    "type": "object"
   },
   "type": "array"
  },
  "labelSet": {
   "additionalProperties": {
    "type": "string"
   },
   "description": "LabelSet label set",
   "type": "object"
  },
  "matcher": {
   "description": "Matcher matcher",
   "properties": {
    "isEqual": {
     "description": "is equal",
     "type": "boolean"
    },
    "isRegex": {
     "description": "is regex",
     "type": "boolean"
    },
    "name": {
     "description": "name",
     "type": "string"
    },
    "value": {
     "description": "value",
     "type": "string"
    }
   },
   "required": [
    "isRegex",
    "name",
    "value"
   ],
   "type": "object"
  },
  "matchers": {
   "description": "Matchers matchers",
   "items": {
    "$ref": "#/definitions/matcher"
   },
   "type": "array"
  },
  "peerStatus": {
   "description": "PeerStatus peer status",
   "properties": {
    "address": {
     "description": "address",
     "type": "string"
    },
    "name": {
     "description": "name",
     "type": "string"
    }
   },
   "required": [
    "address",
    "name"
   ],
   "type": "object"
  },
  "postSilencesOKBody": {
   "properties": {
    "silenceID": {
     "description": "silence ID",
     "type": "string"
    }
   },
   "type": "object"
  },
  "postableAlert": {
   "description": "PostableAlert postable alert",
   "properties": {
    "annotations": {
     "$ref": "#/definitions/labelSet"
    },
    "endsAt": {
     "description": "ends at\nFormat: date-time",
     "format": "date-time",
     "type": "string"
    },
    "generatorURL": {
     "description": "generator URL\nFormat: uri",
     "format": "uri",
     "type": "string"
    },
    "labels": {
     "$ref": "#/definitions/labelSet"
    },
    "startsAt": {
     "description": "starts at\nFormat: date-time",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "labels"
   ],
   "type": "object"
  },
  "postableAlerts": {
   "description": "PostableAlerts postable alerts",
   "items": {
    "$ref": "#/definitions/postableAlert"
   },
   "type": "array"
  },
  "postableSilence": {
   "description": "PostableSilence postable silence",
   "properties": {
    "comment": {
     "description": "comment",
     "type": "string"
    },
    "createdBy": {
     "description": "created by",
     "type": "string"
    },
    "endsAt": {
     "description": "ends at",
     "format": "date-time",
     "type": "string"
    },
    "id": {
     "description": "id",
     "type": "string"
    },
    "matchers": {
     "$ref": "#/definitions/matchers"
    },
    "startsAt": {
     "description": "starts at",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "comment",
    "createdBy",
    "endsAt",
    "matchers",
    "startsAt"
   ],
   "type": "object"
  },
  "receiver": {
   "description": "Receiver receiver",
   "properties": {
    "name": {
     "description": "name",
     "type": "string"
    }
   },
   "required": [
    "name"
   ],
   "type": "object"
  },
  "silence": {
   "description": "Silence silence",
   "properties": {
    "comment": {
     "description": "comment",
     "type": "string"
    },
    "createdBy": {
     "description": "created by",
     "type": "string"
    },
    "endsAt": {
     "description": "ends at",
     "format": "date-time",
     "type": "string"
    },
    "matchers": {
     "$ref": "#/definitions/matchers"
    },
    "startsAt": {
     "description": "starts at",
     "format": "date-time",
     "type": "string"
    }
   },
   "required": [
    "comment",
    "createdBy",
    "endsAt",
    "matchers",
    "startsAt"
   ],
   "type": "object"
  },
  "silenceStatus": {
   "description": "SilenceStatus silence status",
   "properties": {
    "state": {
     "description": "state",
     "enum": [
      "[expired active pending]"
     ],
     "type": "string"
    }
   },
   "required": [
    "state"
   ],
   "type": "object"
  },
  "versionInfo": {
   "description": "VersionInfo version info",
   "properties": {
    "branch": {
     "description": "branch",
     "type": "string"
    },
    "buildDate": {
     "description": "build date",
     "type": "string"
    },
    "buildUser": {
     "description": "build user",
     "type": "string"
    },
    "goVersion": {
     "description": "go version",
     "type": "string"
    },
    "revision": {
     "description": "revision",
     "type": "string"
    },
    "version": {
     "description": "version",
     "type": "string"
    }
   },
   "required": [
    "branch",
    "buildDate",
    "buildUser",
    "goVersion",
    "revision",
    "version"
   ],
   "type": "object"
  }
 },
 "info": {
  "description": "Package definitions includes the types required for generating or consuming an OpenAPI\nspec for the Grafana Alerting API.",
  "title": "Grafana Alerting API.",
  "version": "1.1.0"
 },
 "paths": {
  "/alertmanager/grafana/api/v2/alerts": {
   "get": {
    "description": "get alertmanager alerts",
    "operationId": "RouteGetGrafanaAMAlerts",
    "parameters": [
     {
      "default": true,
      "description": "Show active alerts",
      "in": "query",
      "name": "active",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show silenced alerts",
      "in": "query",
      "name": "silenced",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show inhibited alerts",
      "in": "query",
      "name": "inhibited",
      "type": "boolean"
     },
     {
      "description": "A list of matchers to filter alerts by",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "A regex matching receivers to filter alerts by",
      "in": "query",
      "name": "receiver",
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableAlerts",
      "schema": {
       "$ref": "#/definitions/gettableAlerts"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/api/v2/alerts/groups": {
   "get": {
    "description": "get alertmanager alerts",
    "operationId": "RouteGetGrafanaAMAlertGroups",
    "parameters": [
     {
      "default": true,
      "description": "Show active alerts",
      "in": "query",
      "name": "active",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show silenced alerts",
      "in": "query",
      "name": "silenced",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show inhibited alerts",
      "in": "query",
      "name": "inhibited",
      "type": "boolean"
     },
     {
      "description": "A list of matchers to filter alerts by",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "A regex matching receivers to filter alerts by",
      "in": "query",
      "name": "receiver",
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "alertGroups",
      "schema": {
       "$ref": "#/definitions/alertGroups"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/api/v2/silence/{SilenceId}": {
   "delete": {
    "description": "delete silence",
    "operationId": "RouteDeleteGrafanaSilence",
    "parameters": [
     {
      "in": "path",
      "name": "SilenceId",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "get": {
    "description": "get silence",
    "operationId": "RouteGetGrafanaSilence",
    "parameters": [
     {
      "in": "path",
      "name": "SilenceId",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableGrafanaSilence",
      "schema": {
       "$ref": "#/definitions/gettableGrafanaSilence"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/api/v2/silences": {
   "get": {
    "description": "get silences",
    "operationId": "RouteGetGrafanaSilences",
    "parameters": [
     {
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "Return rule metadata with silence.",
      "in": "query",
      "name": "ruleMetadata",
      "type": "boolean"
     },
     {
      "description": "Return access control metadata with silence.",
      "in": "query",
      "name": "accesscontrol",
      "type": "boolean"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableGrafanaSilences",
      "schema": {
       "$ref": "#/definitions/gettableGrafanaSilences"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "post": {
    "description": "create silence",
    "operationId": "RouteCreateGrafanaSilence",
    "parameters": [
     {
      "in": "body",
      "name": "Silence",
      "schema": {
       "$ref": "#/definitions/postableSilence"
      }
     }
    ],
    "responses": {
     "202": {
      "description": "postSilencesOKBody",
      "schema": {
       "$ref": "#/definitions/postSilencesOKBody"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/api/v2/status": {
   "get": {
    "description": "get alertmanager status and configuration",
    "operationId": "RouteGetGrafanaAMStatus",
    "responses": {
     "200": {
      "description": "GettableStatus",
      "schema": {
       "$ref": "#/definitions/GettableStatus"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/api/v1/alerts": {
   "delete": {
    "deprecated": true,
    "description": "This API is designated to internal use only and can be removed or changed at any time without prior notice.",
    "operationId": "RouteDeleteGrafanaAlertingConfig",
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "deletes the Alerting config for a tenant",
    "tags": [
     "alertmanager"
    ]
   },
   "get": {
    "deprecated": true,
    "description": "This API is designated to internal use only and can be removed or changed at any time without prior notice.",
    "operationId": "RouteGetGrafanaAlertingConfig",
    "responses": {
     "200": {
      "description": "GettableUserConfig",
      "schema": {
       "$ref": "#/definitions/GettableUserConfig"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "gets an Alerting config",
    "tags": [
     "alertmanager"
    ]
   },
   "post": {
    "deprecated": true,
    "description": "This API is designated to internal use only and can be removed or changed at any time without prior notice.",
    "operationId": "RoutePostGrafanaAlertingConfig",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableUserConfig"
      }
     }
    ],
    "responses": {
     "201": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "sets an Alerting config",
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/api/v1/receivers": {
   "get": {
    "description": "Get a list of all receivers",
    "operationId": "RouteGetGrafanaReceivers",
    "responses": {
     "200": {
      "$ref": "#/responses/receiversResponse"
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/api/v1/receivers/test": {
   "post": {
    "operationId": "RoutePostTestGrafanaReceivers",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/TestReceiversConfigBodyParams"
      }
     }
    ],
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "207": {
      "description": "MultiStatus",
      "schema": {
       "$ref": "#/definitions/MultiStatus"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "403": {
      "description": "PermissionDenied",
      "schema": {
       "$ref": "#/definitions/PermissionDenied"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     },
     "408": {
      "description": "Failure",
      "schema": {
       "$ref": "#/definitions/Failure"
      }
     },
     "409": {
      "description": "AlertManagerNotReady",
      "schema": {
       "$ref": "#/definitions/AlertManagerNotReady"
      }
     }
    },
    "summary": "Test Grafana managed receivers without saving them.",
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/api/v1/templates/test": {
   "post": {
    "operationId": "RoutePostTestGrafanaTemplates",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/TestTemplatesConfigBodyParams"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "TestTemplatesResults",
      "schema": {
       "$ref": "#/definitions/TestTemplatesResults"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "403": {
      "description": "PermissionDenied",
      "schema": {
       "$ref": "#/definitions/PermissionDenied"
      }
     },
     "409": {
      "description": "AlertManagerNotReady",
      "schema": {
       "$ref": "#/definitions/AlertManagerNotReady"
      }
     }
    },
    "summary": "Test Grafana managed templates without saving them.",
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/history": {
   "get": {
    "deprecated": true,
    "description": "This API is designated to internal use only and can be removed or changed at any time without prior notice.",
    "operationId": "RouteGetGrafanaAlertingConfigHistory",
    "parameters": [
     {
      "description": "Limit response to n historic configurations.",
      "format": "int64",
      "in": "query",
      "name": "limit",
      "type": "integer"
     }
    ],
    "responses": {
     "200": {
      "$ref": "#/responses/GettableHistoricUserConfigs"
     }
    },
    "summary": "gets Alerting configurations that were successfully applied in the past",
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/grafana/config/history/{id}/_activate": {
   "post": {
    "deprecated": true,
    "description": "This API is designated to internal use only and can be removed or changed at any time without prior notice.",
    "operationId": "RoutePostGrafanaAlertingConfigHistoryActivate",
    "parameters": [
     {
      "description": "Id should be the id of the GettableHistoricUserConfig",
      "format": "int64",
      "in": "path",
      "name": "id",
      "required": true,
      "type": "integer"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "revert Alerting configuration to the historical configuration specified by the given id",
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/api/v2/alerts": {
   "get": {
    "description": "get alertmanager alerts",
    "operationId": "RouteGetAMAlerts",
    "parameters": [
     {
      "default": true,
      "description": "Show active alerts",
      "in": "query",
      "name": "active",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show silenced alerts",
      "in": "query",
      "name": "silenced",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show inhibited alerts",
      "in": "query",
      "name": "inhibited",
      "type": "boolean"
     },
     {
      "description": "A list of matchers to filter alerts by",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "A regex matching receivers to filter alerts by",
      "in": "query",
      "name": "receiver",
      "type": "string"
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableAlerts",
      "schema": {
       "$ref": "#/definitions/gettableAlerts"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "post": {
    "description": "create alertmanager alerts",
    "operationId": "RoutePostAMAlerts",
    "parameters": [
     {
      "in": "body",
      "name": "PostableAlerts",
      "schema": {
       "items": {
        "$ref": "#/definitions/postableAlert"
       },
       "type": "array"
      }
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/api/v2/alerts/groups": {
   "get": {
    "description": "get alertmanager alerts",
    "operationId": "RouteGetAMAlertGroups",
    "parameters": [
     {
      "default": true,
      "description": "Show active alerts",
      "in": "query",
      "name": "active",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show silenced alerts",
      "in": "query",
      "name": "silenced",
      "type": "boolean"
     },
     {
      "default": true,
      "description": "Show inhibited alerts",
      "in": "query",
      "name": "inhibited",
      "type": "boolean"
     },
     {
      "description": "A list of matchers to filter alerts by",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "A regex matching receivers to filter alerts by",
      "in": "query",
      "name": "receiver",
      "type": "string"
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "alertGroups",
      "schema": {
       "$ref": "#/definitions/alertGroups"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/api/v2/silence/{SilenceId}": {
   "delete": {
    "description": "delete silence",
    "operationId": "RouteDeleteSilence",
    "parameters": [
     {
      "in": "path",
      "name": "SilenceId",
      "required": true,
      "type": "string"
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "get": {
    "description": "get silence",
    "operationId": "RouteGetSilence",
    "parameters": [
     {
      "in": "path",
      "name": "SilenceId",
      "required": true,
      "type": "string"
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableSilence",
      "schema": {
       "$ref": "#/definitions/gettableSilence"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/api/v2/silences": {
   "get": {
    "description": "get silences",
    "operationId": "RouteGetSilences",
    "parameters": [
     {
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "filter",
      "type": "array"
     },
     {
      "description": "Return rule metadata with silence.",
      "in": "query",
      "name": "ruleMetadata",
      "type": "boolean"
     },
     {
      "description": "Return access control metadata with silence.",
      "in": "query",
      "name": "accesscontrol",
      "type": "boolean"
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "gettableSilences",
      "schema": {
       "$ref": "#/definitions/gettableSilences"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "post": {
    "description": "create silence",
    "operationId": "RouteCreateSilence",
    "parameters": [
     {
      "in": "body",
      "name": "Silence",
      "schema": {
       "$ref": "#/definitions/postableSilence"
      }
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "201": {
      "description": "postSilencesOKBody",
      "schema": {
       "$ref": "#/definitions/postSilencesOKBody"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/api/v2/status": {
   "get": {
    "description": "get alertmanager status and configuration",
    "operationId": "RouteGetAMStatus",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "GettableStatus",
      "schema": {
       "$ref": "#/definitions/GettableStatus"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/alertmanager/{DatasourceUID}/config/api/v1/alerts": {
   "delete": {
    "description": "deletes the Alerting config for a tenant",
    "operationId": "RouteDeleteAlertingConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "get": {
    "description": "gets an Alerting config",
    "operationId": "RouteGetAlertingConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "GettableUserConfig",
      "schema": {
       "$ref": "#/definitions/GettableUserConfig"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   },
   "post": {
    "description": "sets an Alerting config",
    "operationId": "RoutePostAlertingConfig",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableUserConfig"
      }
     },
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "201": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "alertmanager"
    ]
   }
  },
  "/convert/api/prom/rules": {
   "get": {
    "operationId": "RouteConvertPrometheusCortexGetRules",
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusNamespace",
      "schema": {
       "$ref": "#/definitions/PrometheusNamespace"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets all Grafana-managed alert rules that were imported from Prometheus-compatible sources, grouped by namespace.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "post": {
    "consumes": [
     "application/json",
     "application/yaml"
    ],
    "operationId": "RouteConvertPrometheusCortexPostRuleGroups",
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Converts the submitted rule groups into Grafana-Managed Rules.",
    "tags": [
     "convert_prometheus"
    ]
   }
  },
  "/convert/api/prom/rules/{NamespaceTitle}": {
   "delete": {
    "operationId": "RouteConvertPrometheusCortexDeleteNamespace",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Deletes all rule groups that were imported from Prometheus-compatible sources within the specified namespace.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "get": {
    "operationId": "RouteConvertPrometheusCortexGetNamespace",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusNamespace",
      "schema": {
       "$ref": "#/definitions/PrometheusNamespace"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets Grafana-managed alert rules that were imported from Prometheus-compatible sources for a specified namespace (folder).",
    "tags": [
     "convert_prometheus"
    ]
   },
   "post": {
    "consumes": [
     "application/yaml"
    ],
    "description": "If the group already exists and was not imported from a Prometheus-compatible source initially,\nit will not be replaced and an error will be returned.",
    "operationId": "RouteConvertPrometheusCortexPostRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-datasource-uid",
      "type": "string"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-recording-rules-paused",
      "type": "boolean"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-alert-rules-paused",
      "type": "boolean"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PrometheusRuleGroup"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Converts a Prometheus rule group into a Grafana rule group and creates or updates it within the specified namespace.",
    "tags": [
     "convert_prometheus"
    ],
    "x-raw-request": "true"
   }
  },
  "/convert/api/prom/rules/{NamespaceTitle}/{Group}": {
   "delete": {
    "operationId": "RouteConvertPrometheusCortexDeleteRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Deletes a specific rule group if it was imported from a Prometheus-compatible source.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "get": {
    "operationId": "RouteConvertPrometheusCortexGetRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusRuleGroup",
      "schema": {
       "$ref": "#/definitions/PrometheusRuleGroup"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets a single rule group in Prometheus-compatible format if it was imported from a Prometheus-compatible source.",
    "tags": [
     "convert_prometheus"
    ]
   }
  },
  "/convert/prometheus/config/v1/rules": {
   "get": {
    "operationId": "RouteConvertPrometheusGetRules",
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusNamespace",
      "schema": {
       "$ref": "#/definitions/PrometheusNamespace"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets all Grafana-managed alert rules that were imported from Prometheus-compatible sources, grouped by namespace.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "post": {
    "consumes": [
     "application/json",
     "application/yaml"
    ],
    "operationId": "RouteConvertPrometheusPostRuleGroups",
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Converts the submitted rule groups into Grafana-Managed Rules.",
    "tags": [
     "convert_prometheus"
    ]
   }
  },
  "/convert/prometheus/config/v1/rules/{NamespaceTitle}": {
   "delete": {
    "operationId": "RouteConvertPrometheusDeleteNamespace",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Deletes all rule groups that were imported from Prometheus-compatible sources within the specified namespace.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "get": {
    "operationId": "RouteConvertPrometheusGetNamespace",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusNamespace",
      "schema": {
       "$ref": "#/definitions/PrometheusNamespace"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets Grafana-managed alert rules that were imported from Prometheus-compatible sources for a specified namespace (folder).",
    "tags": [
     "convert_prometheus"
    ]
   },
   "post": {
    "consumes": [
     "application/yaml"
    ],
    "description": "If the group already exists and was not imported from a Prometheus-compatible source initially,\nit will not be replaced and an error will be returned.",
    "operationId": "RouteConvertPrometheusPostRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-datasource-uid",
      "type": "string"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-recording-rules-paused",
      "type": "boolean"
     },
     {
      "in": "header",
      "name": "x-grafana-alerting-alert-rules-paused",
      "type": "boolean"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PrometheusRuleGroup"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Converts a Prometheus rule group into a Grafana rule group and creates or updates it within the specified namespace.",
    "tags": [
     "convert_prometheus"
    ],
    "x-raw-request": "true"
   }
  },
  "/convert/prometheus/config/v1/rules/{NamespaceTitle}/{Group}": {
   "delete": {
    "operationId": "RouteConvertPrometheusDeleteRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "ConvertPrometheusResponse",
      "schema": {
       "$ref": "#/definitions/ConvertPrometheusResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "summary": "Deletes a specific rule group if it was imported from a Prometheus-compatible source.",
    "tags": [
     "convert_prometheus"
    ]
   },
   "get": {
    "operationId": "RouteConvertPrometheusGetRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "NamespaceTitle",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/yaml"
    ],
    "responses": {
     "200": {
      "description": "PrometheusRuleGroup",
      "schema": {
       "$ref": "#/definitions/PrometheusRuleGroup"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Gets a single rule group in Prometheus-compatible format if it was imported from a Prometheus-compatible source.",
    "tags": [
     "convert_prometheus"
    ]
   }
  },
  "/prometheus/grafana/api/v1/alerts": {
   "get": {
    "description": "gets the current alerts",
    "operationId": "RouteGetGrafanaAlertStatuses",
    "parameters": [
     {
      "default": false,
      "description": "Include Grafana specific labels as part of the response.",
      "in": "query",
      "name": "includeInternalLabels",
      "type": "boolean"
     }
    ],
    "responses": {
     "200": {
      "description": "AlertResponse",
      "schema": {
       "$ref": "#/definitions/AlertResponse"
      }
     }
    },
    "tags": [
     "prometheus"
    ]
   }
  },
  "/prometheus/grafana/api/v1/rules": {
   "get": {
    "description": "gets the evaluation statuses of all rules",
    "operationId": "RouteGetGrafanaRuleStatuses",
    "parameters": [
     {
      "default": false,
      "description": "Include Grafana specific labels as part of the response.",
      "in": "query",
      "name": "includeInternalLabels",
      "type": "boolean"
     },
     {
      "description": "Filter the list of rules to those that belong to the specified dashboard UID.",
      "in": "query",
      "name": "DashboardUID",
      "type": "string"
     },
     {
      "description": "Filter the list of rules to those that belong to the specified panel ID. Dashboard UID must be specified.",
      "format": "int64",
      "in": "query",
      "name": "PanelID",
      "type": "integer"
     }
    ],
    "responses": {
     "200": {
      "description": "RuleResponse",
      "schema": {
       "$ref": "#/definitions/RuleResponse"
      }
     }
    },
    "tags": [
     "prometheus"
    ]
   }
  },
  "/prometheus/{DatasourceUID}/api/v1/alerts": {
   "get": {
    "description": "gets the current alerts",
    "operationId": "RouteGetAlertStatuses",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "AlertResponse",
      "schema": {
       "$ref": "#/definitions/AlertResponse"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "prometheus"
    ]
   }
  },
  "/prometheus/{DatasourceUID}/api/v1/rules": {
   "get": {
    "description": "gets the evaluation statuses of all rules",
    "operationId": "RouteGetRuleStatuses",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "RuleResponse",
      "schema": {
       "$ref": "#/definitions/RuleResponse"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "prometheus"
    ]
   }
  },
  "/ruler/grafana/api/v1/export/rules": {
   "get": {
    "description": "List rules in provisioning format",
    "operationId": "RouteGetRulesForExport",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "description": "UIDs of folders from which to export rules",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "folderUid",
      "type": "array"
     },
     {
      "description": "Name of group of rules to export. Must be specified only together with a single folder UID",
      "in": "query",
      "name": "group",
      "type": "string"
     },
     {
      "description": "UID of alert rule to export. If specified, parameters folderUid and group must be empty.",
      "in": "query",
      "name": "ruleUid",
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rule/{RuleUID}": {
   "get": {
    "description": "Get rule by UID",
    "operationId": "RouteGetRuleByUID",
    "parameters": [
     {
      "in": "path",
      "name": "RuleUID",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "GettableExtendedRuleNode",
      "schema": {
       "$ref": "#/definitions/GettableExtendedRuleNode"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rule/{RuleUID}/versions": {
   "get": {
    "description": "Get rule versions by UID",
    "operationId": "RouteGetRuleVersionsByUID",
    "parameters": [
     {
      "in": "path",
      "name": "RuleUID",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "GettableRuleVersions",
      "schema": {
       "$ref": "#/definitions/GettableRuleVersions"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rules": {
   "get": {
    "description": "List rule groups",
    "operationId": "RouteGetGrafanaRulesConfig",
    "parameters": [
     {
      "in": "query",
      "name": "DashboardUID",
      "type": "string"
     },
     {
      "format": "int64",
      "in": "query",
      "name": "PanelID",
      "type": "integer"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "NamespaceConfigResponse",
      "schema": {
       "$ref": "#/definitions/NamespaceConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rules/{Namespace}": {
   "delete": {
    "description": "Delete namespace",
    "operationId": "RouteDeleteNamespaceGrafanaRulesConfig",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "get": {
    "description": "Get rule groups by namespace",
    "operationId": "RouteGetNamespaceGrafanaRulesConfig",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "NamespaceConfigResponse",
      "schema": {
       "$ref": "#/definitions/NamespaceConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "post": {
    "consumes": [
     "application/json",
     "application/yaml"
    ],
    "description": "Creates or updates a rule group",
    "operationId": "RoutePostNameGrafanaRulesConfig",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableRuleGroupConfig"
      }
     }
    ],
    "responses": {
     "202": {
      "description": "UpdateRuleGroupResponse",
      "schema": {
       "$ref": "#/definitions/UpdateRuleGroupResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rules/{Namespace}/export": {
   "post": {
    "consumes": [
     "application/json"
    ],
    "description": "Converts submitted rule group to provisioning format",
    "operationId": "RoutePostRulesGroupForExport",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableRuleGroupConfig"
      }
     },
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/rules/{Namespace}/{Groupname}": {
   "delete": {
    "description": "Delete rule group",
    "operationId": "RouteDeleteGrafanaRuleGroupConfig",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Groupname",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "get": {
    "description": "Get rule group",
    "operationId": "RouteGetGrafanaRuleGroupConfig",
    "parameters": [
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Groupname",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "RuleGroupConfigResponse",
      "schema": {
       "$ref": "#/definitions/RuleGroupConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/grafana/api/v1/trash/rule/guid/{RuleGUID}": {
   "delete": {
    "description": "Permanently delete a rule from trash by GUID",
    "operationId": "RouteDeleteRuleFromTrashByGUID",
    "parameters": [
     {
      "in": "path",
      "name": "RuleGUID",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/{DatasourceUID}/api/v1/rules": {
   "get": {
    "description": "List rule groups",
    "operationId": "RouteGetRulesConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "query",
      "name": "DashboardUID",
      "type": "string"
     },
     {
      "format": "int64",
      "in": "query",
      "name": "PanelID",
      "type": "integer"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "NamespaceConfigResponse",
      "schema": {
       "$ref": "#/definitions/NamespaceConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/{DatasourceUID}/api/v1/rules/{Namespace}": {
   "delete": {
    "description": "Delete namespace",
    "operationId": "RouteDeleteNamespaceRulesConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "get": {
    "description": "Get rule groups by namespace",
    "operationId": "RouteGetNamespaceRulesConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "NamespaceConfigResponse",
      "schema": {
       "$ref": "#/definitions/NamespaceConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "post": {
    "consumes": [
     "application/json",
     "application/yaml"
    ],
    "description": "Creates or updates a rule group",
    "operationId": "RoutePostNameRulesConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableRuleGroupConfig"
      }
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/ruler/{DatasourceUID}/api/v1/rules/{Namespace}/{Groupname}": {
   "delete": {
    "description": "Delete rule group",
    "operationId": "RouteDeleteRuleGroupConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Groupname",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   },
   "get": {
    "description": "Get rule group",
    "operationId": "RouteGetRulegGroupConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "description": "The UID of the rule folder",
      "in": "path",
      "name": "Namespace",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Groupname",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "202": {
      "description": "RuleGroupConfigResponse",
      "schema": {
       "$ref": "#/definitions/RuleGroupConfigResponse"
      }
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "ruler"
    ]
   }
  },
  "/v1/eval": {
   "post": {
    "consumes": [
     "application/json"
    ],
    "description": "Test rule",
    "operationId": "RouteEvalQueries",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/EvalQueriesPayload"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "EvalQueriesResponse",
      "schema": {
       "$ref": "#/definitions/EvalQueriesResponse"
      }
     }
    },
    "tags": [
     "testing"
    ]
   }
  },
  "/v1/ngalert": {
   "get": {
    "description": "Get the status of the alerting engine",
    "operationId": "RouteGetStatus",
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "AlertingStatus",
      "schema": {
       "$ref": "#/definitions/AlertingStatus"
      }
     }
    },
    "tags": [
     "configuration"
    ]
   }
  },
  "/v1/ngalert/admin_config": {
   "delete": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RouteDeleteNGalertConfig",
    "responses": {
     "200": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "500": {
      "description": "Failure",
      "schema": {
       "$ref": "#/definitions/Failure"
      }
     }
    },
    "summary": "Deletes the NGalert configuration of the user's organization.",
    "tags": [
     "configuration"
    ]
   },
   "get": {
    "operationId": "RouteGetNGalertConfig",
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "GettableNGalertConfig",
      "schema": {
       "$ref": "#/definitions/GettableNGalertConfig"
      }
     },
     "404": {
      "description": "Failure",
      "schema": {
       "$ref": "#/definitions/Failure"
      }
     },
     "500": {
      "description": "Failure",
      "schema": {
       "$ref": "#/definitions/Failure"
      }
     }
    },
    "summary": "Get the NGalert configuration of the user's organization, returns 404 if no configuration is present.",
    "tags": [
     "configuration"
    ]
   },
   "post": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePostNGalertConfig",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableNGalertConfig"
      }
     }
    ],
    "responses": {
     "201": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Creates or updates the NGalert configuration of the user's organization. If no value is sent for alertmanagersChoice, it defaults to \"all\".",
    "tags": [
     "configuration"
    ]
   }
  },
  "/v1/ngalert/alertmanagers": {
   "get": {
    "operationId": "RouteGetAlertmanagers",
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "GettableAlertmanagers",
      "schema": {
       "$ref": "#/definitions/GettableAlertmanagers"
      }
     }
    },
    "summary": "Get the discovered and dropped Alertmanagers of the user's organization based on the specified configuration.",
    "tags": [
     "configuration"
    ]
   }
  },
  "/v1/provisioning/alert-rules": {
   "get": {
    "operationId": "RouteGetAlertRules",
    "responses": {
     "200": {
      "description": "ProvisionedAlertRules",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRules"
      }
     }
    },
    "summary": "Get all the alert rules.",
    "tags": [
     "provisioning"
    ]
   },
   "post": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePostAlertRule",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRule"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "201": {
      "description": "ProvisionedAlertRule",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRule"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Create a new alert rule.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/alert-rules/export": {
   "get": {
    "operationId": "RouteGetAlertRulesExport",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "description": "UIDs of folders from which to export rules",
      "in": "query",
      "items": {
       "type": "string"
      },
      "name": "folderUid",
      "type": "array"
     },
     {
      "description": "Name of group of rules to export. Must be specified only together with a single folder UID",
      "in": "query",
      "name": "group",
      "type": "string"
     },
     {
      "description": "UID of alert rule to export. If specified, parameters folderUid and group must be empty.",
      "in": "query",
      "name": "ruleUid",
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Export all alert rules in provisioning file format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/alert-rules/{UID}": {
   "delete": {
    "operationId": "RouteDeleteAlertRule",
    "parameters": [
     {
      "description": "Alert rule UID",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "204": {
      "description": " The alert rule was deleted successfully."
     }
    },
    "summary": "Delete a specific alert rule by UID.",
    "tags": [
     "provisioning"
    ]
   },
   "get": {
    "operationId": "RouteGetAlertRule",
    "parameters": [
     {
      "description": "Alert rule UID",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "ProvisionedAlertRule",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRule"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Get a specific alert rule by UID.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutAlertRule",
    "parameters": [
     {
      "description": "Alert rule UID",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRule"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "ProvisionedAlertRule",
      "schema": {
       "$ref": "#/definitions/ProvisionedAlertRule"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Update an existing alert rule.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/alert-rules/{UID}/export": {
   "get": {
    "operationId": "RouteGetAlertRuleExport",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "description": "Alert rule UID",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Export an alert rule in provisioning file format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/contact-points": {
   "get": {
    "operationId": "RouteGetContactpoints",
    "parameters": [
     {
      "description": "Filter by name",
      "in": "query",
      "name": "name",
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "ContactPoints",
      "schema": {
       "$ref": "#/definitions/ContactPoints"
      }
     }
    },
    "summary": "Get all the contact points.",
    "tags": [
     "provisioning"
    ]
   },
   "post": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePostContactpoints",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/EmbeddedContactPoint"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "EmbeddedContactPoint",
      "schema": {
       "$ref": "#/definitions/EmbeddedContactPoint"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Create a contact point.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/contact-points/export": {
   "get": {
    "operationId": "RouteGetContactpointsExport",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "default": false,
      "description": "Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings.",
      "in": "query",
      "name": "decrypt",
      "type": "boolean"
     },
     {
      "description": "Filter by name",
      "in": "query",
      "name": "name",
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "403": {
      "description": "PermissionDenied",
      "schema": {
       "$ref": "#/definitions/PermissionDenied"
      }
     }
    },
    "summary": "Export all contact points in provisioning file format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/contact-points/{UID}": {
   "delete": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RouteDeleteContactpoints",
    "parameters": [
     {
      "description": "UID is the contact point unique identifier",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": " The contact point was deleted successfully."
     }
    },
    "summary": "Delete a contact point.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutContactpoint",
    "parameters": [
     {
      "description": "UID is the contact point unique identifier",
      "in": "path",
      "name": "UID",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/EmbeddedContactPoint"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Update an existing contact point.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}": {
   "delete": {
    "description": "Delete rule group",
    "operationId": "RouteDeleteAlertRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "FolderUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "204": {
      "description": " The alert rule group was deleted successfully."
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "provisioning"
    ]
   },
   "get": {
    "operationId": "RouteGetAlertRuleGroup",
    "parameters": [
     {
      "in": "path",
      "name": "FolderUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "AlertRuleGroup",
      "schema": {
       "$ref": "#/definitions/AlertRuleGroup"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Get a rule group.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutAlertRuleGroup",
    "parameters": [
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     },
     {
      "in": "path",
      "name": "FolderUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/AlertRuleGroup"
      }
     }
    ],
    "responses": {
     "200": {
      "description": "AlertRuleGroup",
      "schema": {
       "$ref": "#/definitions/AlertRuleGroup"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Create or update alert rule group.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export": {
   "get": {
    "operationId": "RouteGetAlertRuleGroupExport",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "in": "path",
      "name": "FolderUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "path",
      "name": "Group",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Export an alert rule group in provisioning file format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/mute-timings": {
   "get": {
    "operationId": "RouteGetMuteTimings",
    "responses": {
     "200": {
      "description": "MuteTimings",
      "schema": {
       "$ref": "#/definitions/MuteTimings"
      }
     }
    },
    "summary": "Get all the mute timings.",
    "tags": [
     "provisioning"
    ]
   },
   "post": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePostMuteTiming",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/MuteTimeInterval"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "201": {
      "description": "MuteTimeInterval",
      "schema": {
       "$ref": "#/definitions/MuteTimeInterval"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Create a new mute timing.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/mute-timings/export": {
   "get": {
    "operationId": "RouteExportMuteTimings",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "403": {
      "description": "PermissionDenied",
      "schema": {
       "$ref": "#/definitions/PermissionDenied"
      }
     }
    },
    "summary": "Export all mute timings in provisioning format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/mute-timings/{name}": {
   "delete": {
    "operationId": "RouteDeleteMuteTiming",
    "parameters": [
     {
      "description": "Mute timing name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     },
     {
      "description": "Version of mute timing to use for optimistic concurrency. Leave empty to disable validation",
      "in": "query",
      "name": "version",
      "type": "string"
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "204": {
      "description": " The mute timing was deleted successfully."
     },
     "409": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     }
    },
    "summary": "Delete a mute timing.",
    "tags": [
     "provisioning"
    ]
   },
   "get": {
    "operationId": "RouteGetMuteTiming",
    "parameters": [
     {
      "description": "Mute timing name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "MuteTimeInterval",
      "schema": {
       "$ref": "#/definitions/MuteTimeInterval"
      }
     },
     "404": {
      "description": " Not found."
     }
    },
    "summary": "Get a mute timing.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutMuteTiming",
    "parameters": [
     {
      "description": "Mute timing name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/MuteTimeInterval"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "MuteTimeInterval",
      "schema": {
       "$ref": "#/definitions/MuteTimeInterval"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "409": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     }
    },
    "summary": "Replace an existing mute timing.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/mute-timings/{name}/export": {
   "get": {
    "operationId": "RouteExportMuteTiming",
    "parameters": [
     {
      "default": false,
      "description": "Whether to initiate a download of the file or not.",
      "in": "query",
      "name": "download",
      "type": "boolean"
     },
     {
      "default": "yaml",
      "description": "Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.",
      "enum": [
       "yaml",
       "json",
       "hcl"
      ],
      "in": "query",
      "name": "format",
      "type": "string"
     },
     {
      "description": "Mute timing name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     }
    ],
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "403": {
      "description": "PermissionDenied",
      "schema": {
       "$ref": "#/definitions/PermissionDenied"
      }
     }
    },
    "summary": "Export a mute timing in provisioning format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/policies": {
   "delete": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RouteResetPolicyTree",
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     }
    },
    "summary": "Clears the notification policy tree.",
    "tags": [
     "provisioning"
    ]
   },
   "get": {
    "operationId": "RouteGetPolicyTree",
    "responses": {
     "200": {
      "description": "Route",
      "schema": {
       "$ref": "#/definitions/Route"
      }
     }
    },
    "summary": "Get the notification policy tree.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutPolicyTree",
    "parameters": [
     {
      "description": "The new notification routing tree to use",
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/Route"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "Ack",
      "schema": {
       "$ref": "#/definitions/Ack"
      }
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     }
    },
    "summary": "Sets the notification policy tree.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/policies/export": {
   "get": {
    "operationId": "RouteGetPolicyTreeExport",
    "produces": [
     "application/json",
     "application/yaml",
     "application/terraform+hcl",
     "text/yaml",
     "text/hcl"
    ],
    "responses": {
     "200": {
      "description": "AlertingFileExport",
      "schema": {
       "$ref": "#/definitions/AlertingFileExport"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "summary": "Export the notification policy tree in provisioning file format.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/templates": {
   "get": {
    "operationId": "RouteGetTemplates",
    "responses": {
     "200": {
      "description": "NotificationTemplates",
      "schema": {
       "$ref": "#/definitions/NotificationTemplates"
      }
     }
    },
    "summary": "Get all notification template groups.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/provisioning/templates/{name}": {
   "delete": {
    "operationId": "RouteDeleteTemplate",
    "parameters": [
     {
      "description": "Template group name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     },
     {
      "description": "Version of template to use for optimistic concurrency. Leave empty to disable validation",
      "in": "query",
      "name": "version",
      "type": "string"
     }
    ],
    "responses": {
     "204": {
      "description": " The template was deleted successfully."
     },
     "409": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     }
    },
    "summary": "Delete a notification template group.",
    "tags": [
     "provisioning"
    ]
   },
   "get": {
    "operationId": "RouteGetTemplate",
    "parameters": [
     {
      "description": "Template group name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     }
    ],
    "responses": {
     "200": {
      "description": "NotificationTemplate",
      "schema": {
       "$ref": "#/definitions/NotificationTemplate"
      }
     },
     "404": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     }
    },
    "summary": "Get a notification template group.",
    "tags": [
     "provisioning"
    ]
   },
   "put": {
    "consumes": [
     "application/json"
    ],
    "operationId": "RoutePutTemplate",
    "parameters": [
     {
      "description": "Template group name",
      "in": "path",
      "name": "name",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/NotificationTemplateContent"
      }
     },
     {
      "in": "header",
      "name": "X-Disable-Provenance",
      "type": "string"
     }
    ],
    "responses": {
     "202": {
      "description": "NotificationTemplate",
      "schema": {
       "$ref": "#/definitions/NotificationTemplate"
      }
     },
     "400": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     },
     "409": {
      "description": "PublicError",
      "schema": {
       "$ref": "#/definitions/PublicError"
      }
     }
    },
    "summary": "Updates an existing notification template group.",
    "tags": [
     "provisioning"
    ]
   }
  },
  "/v1/rule/backtest": {
   "post": {
    "consumes": [
     "application/json"
    ],
    "description": "Test rule",
    "operationId": "BacktestConfig",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/BacktestConfig"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "BacktestResult",
      "schema": {
       "$ref": "#/definitions/BacktestResult"
      }
     }
    },
    "tags": [
     "testing"
    ]
   }
  },
  "/v1/rule/test/grafana": {
   "post": {
    "consumes": [
     "application/json"
    ],
    "description": "Test a rule against Grafana ruler",
    "operationId": "RouteTestRuleGrafanaConfig",
    "parameters": [
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/PostableExtendedRuleNodeExtended"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "$ref": "#/responses/TestGrafanaRuleResponse"
     },
     "400": {
      "description": "ValidationError",
      "schema": {
       "$ref": "#/definitions/ValidationError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "testing"
    ]
   }
  },
  "/v1/rule/test/{DatasourceUID}": {
   "post": {
    "consumes": [
     "application/json"
    ],
    "description": "Test a rule against external data source ruler",
    "operationId": "RouteTestRuleConfig",
    "parameters": [
     {
      "description": "DatasoureUID should be the datasource UID identifier",
      "in": "path",
      "name": "DatasourceUID",
      "required": true,
      "type": "string"
     },
     {
      "in": "body",
      "name": "Body",
      "schema": {
       "$ref": "#/definitions/TestRulePayload"
      }
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "description": "TestRuleResponse",
      "schema": {
       "$ref": "#/definitions/TestRuleResponse"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     }
    },
    "tags": [
     "testing"
    ]
   }
  },
  "/v1/rules/history": {
   "get": {
    "description": "Allows to query alerting state history.\nIn addition to defined query parameters it accepts filter by labels. The query parameter name must start with 'labels_'\nExample: /v1/rules/history?labels_myKey1=myValue1\u0026labels_myKey2=myValue2",
    "operationId": "RouteGetStateHistory",
    "parameters": [
     {
      "description": "The timestamp of the start point of the time range the history is obtained.",
      "format": "int64",
      "in": "query",
      "name": "from",
      "type": "integer"
     },
     {
      "description": "The timestamp of the end point of the time range the history is obtained.",
      "format": "int64",
      "in": "query",
      "name": "to",
      "type": "integer"
     },
     {
      "description": "Limits the number of records that needs to be returned.",
      "format": "int64",
      "in": "query",
      "name": "limit",
      "type": "integer"
     },
     {
      "description": "Filter by rule UID. Required the state history is configured to use annotations for storage.",
      "in": "query",
      "name": "ruleUID",
      "type": "string"
     },
     {
      "description": "Filter by rules that are or were assigned to the specific dashboard.",
      "in": "query",
      "name": "DashboardUID",
      "type": "string"
     },
     {
      "description": "Filter by dashboard's panel ID. Requires Dashboard UID to be specified.",
      "format": "int64",
      "in": "query",
      "name": "PanelID",
      "type": "integer"
     }
    ],
    "produces": [
     "application/json"
    ],
    "responses": {
     "200": {
      "$ref": "#/responses/StateHistory"
     },
     "403": {
      "description": "ForbiddenError",
      "schema": {
       "$ref": "#/definitions/ForbiddenError"
      }
     },
     "404": {
      "description": "NotFound",
      "schema": {
       "$ref": "#/definitions/NotFound"
      }
     },
     "500": {
      "description": "Failure",
      "schema": {
       "$ref": "#/definitions/Failure"
      }
     }
    },
    "summary": "Query state history.",
    "tags": [
     "history"
    ]
   }
  }
 },
 "produces": [
  "application/json"
 ],
 "responses": {
  "GettableHistoricUserConfigs": {
   "description": "",
   "schema": {
    "items": {
     "$ref": "#/definitions/GettableHistoricUserConfig"
    },
    "type": "array"
   }
  },
  "StateHistory": {
   "description": "",
   "schema": {
    "$ref": "#/definitions/Frame"
   }
  },
  "TestGrafanaRuleResponse": {
   "description": "",
   "schema": {
    "items": {
     "$ref": "#/definitions/postableAlert"
    },
    "type": "array"
   }
  },
  "receiversResponse": {
   "description": "",
   "schema": {
    "items": {
     "$ref": "#/definitions/Receiver"
    },
    "type": "array"
   }
  }
 },
 "schemes": [
  "http",
  "https"
 ],
 "securityDefinitions": {
  "basic": {
   "type": "basic"
  }
 },
 "swagger": "2.0"
}