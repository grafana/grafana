package notifier

import (
	"context"
	"testing"
	"time"

	"github.com/prometheus/alertmanager/config"
	"github.com/prometheus/alertmanager/pkg/labels"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/stretchr/testify/require"

	"github.com/grafana/grafana/pkg/infra/db"
	"github.com/grafana/grafana/pkg/infra/log"
	"github.com/grafana/grafana/pkg/services/dashboards"
	"github.com/grafana/grafana/pkg/services/featuremgmt"
	"github.com/grafana/grafana/pkg/services/ngalert/api/tooling/definitions"
	"github.com/grafana/grafana/pkg/services/ngalert/metrics"
	"github.com/grafana/grafana/pkg/services/ngalert/store"
	"github.com/grafana/grafana/pkg/services/ngalert/tests/fakes"
	"github.com/grafana/grafana/pkg/services/secrets/database"
	secretsManager "github.com/grafana/grafana/pkg/services/secrets/manager"
	"github.com/grafana/grafana/pkg/setting"
	"github.com/grafana/grafana/pkg/tests/testsuite"
)

func TestMain(m *testing.M) {
	testsuite.Run(m)
}

func setupAMTest(t *testing.T) *alertmanager {
	dir := t.TempDir()
	cfg := &setting.Cfg{
		DataPath: dir,
		AppURL:   "http://localhost:9093",
	}

	l := log.New("alertmanager-test")

	m := metrics.NewAlertmanagerMetrics(prometheus.NewRegistry(), l)
	sqlStore := db.InitTestDB(t)
	s := &store.DBstore{
		Cfg: setting.UnifiedAlertingSettings{
			BaseInterval:                  10 * time.Second,
			DefaultRuleEvaluationInterval: time.Minute,
		},
		SQLStore:         sqlStore,
		Logger:           l,
		DashboardService: dashboards.NewFakeDashboardService(t),
	}

	kvStore := fakes.NewFakeKVStore(t)
	secretsService := secretsManager.SetupTestService(t, database.ProvideSecretsStore(sqlStore))
	decryptFn := secretsService.GetDecryptedValue

	orgID := 1
	stateStore := NewFileStore(int64(orgID), kvStore)
	crypto := NewCrypto(secretsService, s, l)

	am, err := NewAlertmanager(context.Background(), 1, cfg, s, stateStore, &NilPeer{}, decryptFn, nil, m, featuremgmt.WithFeatures(), crypto)
	require.NoError(t, err)
	return am
}

func TestAlertmanager_newAlertmanager(t *testing.T) {
	am := setupAMTest(t)
	require.False(t, am.Ready())
}

func TestAlertmanager_ApplyConfig(t *testing.T) {
	basicConfig := func() definitions.PostableApiAlertingConfig {
		return definitions.PostableApiAlertingConfig{
			Config: definitions.Config{
				Route: &definitions.Route{
					Receiver: "default-receiver",
					ObjectMatchers: definitions.ObjectMatchers{
						&labels.Matcher{
							Type:  labels.MatchEqual,
							Name:  "__grafana_autogenerated__",
							Value: "true",
						},
					},
				},
			},
			Receivers: []*definitions.PostableApiReceiver{
				{
					Receiver: config.Receiver{
						Name: "default-receiver",
					},
				},
			},
		}
	}

	testCases := []struct {
		name          string
		config        *definitions.PostableUserConfig
		expectedError string
		skipInvalid   bool
	}{
		{
			name: "basic config",
			config: &definitions.PostableUserConfig{
				AlertmanagerConfig: basicConfig(),
				TemplateFiles: map[string]string{
					"grafana-template": "{{ define \"grafana.title\" }}Alert{{ end }}",
				},
			},
			skipInvalid: false,
		},
		{
			name: "with mimir config",
			config: &definitions.PostableUserConfig{
				AlertmanagerConfig: basicConfig(),
				TemplateFiles: map[string]string{
					"grafana-template": "{{ define \"grafana.title\" }}Grafana Alert{{ end }}",
				},
				ExtraConfigs: []definitions.ExtraConfiguration{
					{
						Identifier: "mimir-prod",
						MergeMatchers: config.Matchers{
							{
								Type:  labels.MatchEqual,
								Name:  "__mimir__",
								Value: "true",
							},
						},
						TemplateFiles: map[string]string{
							"mimir-template": "{{ define \"mimir.title\" }}Mimir Alert{{ end }}",
						},
						AlertmanagerConfig: `route:
  receiver: mimir-webhook
  group_by:
    - alertname
    - cluster
receivers:
  - name: mimir-webhook
    webhook_configs:
      - url: https://webhook.example.com/alerts
        send_resolved: true
        http_config: {}`,
					},
				},
			},
			skipInvalid: false,
		},
		{
			name: "invalid config fails",
			config: &definitions.PostableUserConfig{
				AlertmanagerConfig: basicConfig(),
				ExtraConfigs: []definitions.ExtraConfiguration{
					{
						Identifier:    "", // invalid: empty identifier
						MergeMatchers: config.Matchers{},
						AlertmanagerConfig: `route:
  receiver: test-receiver
receivers:
  - name: test-receiver`,
					},
				},
			},
			expectedError: "failed to get full alertmanager configuration",
			skipInvalid:   false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			am := setupAMTest(t)
			ctx := context.Background()

			err := am.SaveAndApplyConfig(ctx, tc.config)

			if tc.expectedError != "" {
				require.Error(t, err)
				require.ErrorContains(t, err, tc.expectedError)
			} else {
				require.NoError(t, err)

				templateDefs := tc.config.GetMergedTemplateDefinitions()
				expectedTemplateCount := len(tc.config.TemplateFiles)
				if len(tc.config.ExtraConfigs) > 0 {
					expectedTemplateCount += len(tc.config.ExtraConfigs[0].TemplateFiles)
				}
				require.Len(t, templateDefs, expectedTemplateCount)
			}
		})
	}
}
