package resource

// List of imports with LocalManifest generated by running (on one-line):
//
// 	find apps -name '*.go' |
// 	xargs grep 'func LocalManifest() app.Manifest' |
// 	gawk -F: '{path = $1; sub(/\/[^\/]+\.go$/, "", path); if (match(path, /^apps\/(.+)\/pkg/, arr)) {app = arr[1]; pkg = app; gsub("/", "_", pkg); print pkg " \"github.com/grafana/grafana/" path "\""}}'
import (
	"slices"
	"strings"

	"github.com/grafana/grafana-app-sdk/app"

	advisor "github.com/grafana/grafana/apps/advisor/pkg/apis"
	alerting_historian "github.com/grafana/grafana/apps/alerting/historian/pkg/apis"
	alerting_notifications "github.com/grafana/grafana/apps/alerting/notifications/pkg/apis"
	alerting_rules "github.com/grafana/grafana/apps/alerting/rules/pkg/apis"
	annotation "github.com/grafana/grafana/apps/annotation/pkg/apis"
	collections "github.com/grafana/grafana/apps/collections/pkg/apis/manifestdata"
	correlations "github.com/grafana/grafana/apps/correlations/pkg/apis"
	dashboard "github.com/grafana/grafana/apps/dashboard/pkg/apis"
	dashvalidator "github.com/grafana/grafana/apps/dashvalidator/pkg/apis/manifestdata"
	dashvalidator1 "github.com/grafana/grafana/apps/dashvalidator/pkg/generated/manifestdata"
	example "github.com/grafana/grafana/apps/example/pkg/apis/manifestdata"
	folder "github.com/grafana/grafana/apps/folder/pkg/apis/manifestdata"
	iam "github.com/grafana/grafana/apps/iam/pkg/apis"
	live "github.com/grafana/grafana/apps/live/pkg/apis/manifestdata"
	logsdrilldown "github.com/grafana/grafana/apps/logsdrilldown/pkg/apis"
	playlist "github.com/grafana/grafana/apps/playlist/pkg/apis/manifestdata"
	plugins "github.com/grafana/grafana/apps/plugins/pkg/apis"
	preferences "github.com/grafana/grafana/apps/preferences/pkg/apis/manifestdata"
	provisioning "github.com/grafana/grafana/apps/provisioning/pkg/apis/manifestdata"
	quotas "github.com/grafana/grafana/apps/quotas/pkg/apis"
	secret "github.com/grafana/grafana/apps/secret/pkg/apis"
	shorturl "github.com/grafana/grafana/apps/shorturl/pkg/apis"
)

func AppManifests() []app.Manifest {
	// TODO: don't use hardcoded list of manifests when possible.
	return []app.Manifest{
		advisor.LocalManifest(),
		alerting_historian.LocalManifest(),
		alerting_notifications.LocalManifest(),
		alerting_rules.LocalManifest(),
		annotation.LocalManifest(),
		collections.LocalManifest(),
		correlations.LocalManifest(),
		dashboard.LocalManifest(),
		dashvalidator.LocalManifest(),
		dashvalidator1.LocalManifest(),
		example.LocalManifest(),
		folder.LocalManifest(),
		iam.LocalManifest(),
		live.LocalManifest(),
		logsdrilldown.LocalManifest(),
		playlist.LocalManifest(),
		plugins.LocalManifest(),
		preferences.LocalManifest(),
		provisioning.LocalManifest(),
		quotas.LocalManifest(),
		secret.LocalManifest(),
		shorturl.LocalManifest(),
	}
}

// SelectableFields returns map of <group>/<Kind> to list of selectable fields for known manifests.
func SelectableFields() map[string][]string {
	return SelectableFieldsForManifests(AppManifests())
}

// SelectableFieldsForManifests returns map of <group/kind> to list of selectable fields (across all versions).
// Also <group/plural> is included as a key, pointing to the same fields.
// Keys are lower-case.
func SelectableFieldsForManifests(manifests []app.Manifest) map[string][]string {
	fields := map[string][]string{}
	for _, m := range manifests {
		for k, v := range selectableFieldsForManifest(m) {
			fields[k] = v
		}
	}
	return fields
}

func selectableFieldsForManifest(m app.Manifest) map[string][]string {
	kindFields := map[string]map[string]bool{}
	kinds := map[string]app.ManifestVersionKind{}

	for _, version := range m.ManifestData.Versions {
		for _, kind := range version.Kinds {
			if len(kind.SelectableFields) > 0 {
				kinds[kind.Kind] = kind

				if kindFields[kind.Kind] == nil {
					kindFields[kind.Kind] = map[string]bool{}
				}
				for _, f := range kind.SelectableFields {
					kindFields[kind.Kind][f] = true
				}
			}
		}
	}

	fields := map[string][]string{}
	for k, v := range kinds {
		fs := make([]string, 0, len(kindFields[k]))
		for f := range kindFields[k] {
			fs = append(fs, f)
		}
		slices.Sort(fs)

		fields[strings.ToLower(m.ManifestData.Group+"/"+v.Kind)] = fs
		fields[strings.ToLower(m.ManifestData.Group+"/"+v.Plural)] = fs
	}

	return fields
}
