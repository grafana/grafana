//
// This file is generated by grafana-app-sdk
// DO NOT EDIT
//

package apis

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/grafana/grafana-app-sdk/app"
	"github.com/grafana/grafana-app-sdk/resource"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/kube-openapi/pkg/spec3"
	"k8s.io/kube-openapi/pkg/validation/spec"

	v0alpha1 "github.com/grafana/grafana/apps/alerting/historian/pkg/apis/alertinghistorian/v0alpha1"
)

var (
	rawSchemaDummyv0alpha1     = []byte(`{"Dummy":{"properties":{"spec":{"$ref":"#/components/schemas/spec"},"status":{"$ref":"#/components/schemas/status"}},"required":["spec"]},"OperatorState":{"additionalProperties":false,"properties":{"descriptiveState":{"description":"descriptiveState is an optional more descriptive state field which has no requirements on format","type":"string"},"details":{"additionalProperties":true,"description":"details contains any extra information that is operator-specific","type":"object"},"lastEvaluation":{"description":"lastEvaluation is the ResourceVersion last evaluated","type":"string"},"state":{"description":"state describes the state of the lastEvaluation.\nIt is limited to three possible states for machine evaluation.","enum":["success","in_progress","failed"],"type":"string"}},"required":["lastEvaluation","state"],"type":"object"},"spec":{"additionalProperties":false,"description":"Spec is the schema of our resource. The spec should include all the user-editable information for the kind.","properties":{"dummyField":{"type":"integer"}},"required":["dummyField"],"type":"object"},"status":{"additionalProperties":false,"properties":{"additionalFields":{"additionalProperties":true,"description":"additionalFields is reserved for future use","type":"object"},"operatorStates":{"additionalProperties":{"$ref":"#/components/schemas/OperatorState"},"description":"operatorStates is a map of operator ID to operator state evaluations.\nAny operator which consumes this kind SHOULD add its state evaluation information to this field.","type":"object"}},"type":"object"}}`)
	versionSchemaDummyv0alpha1 app.VersionSchema
	_                          = json.Unmarshal(rawSchemaDummyv0alpha1, &versionSchemaDummyv0alpha1)
)

var appManifestData = app.ManifestData{
	AppName:          "alerting-historian",
	Group:            "historian.alerting.grafana.app",
	PreferredVersion: "v0alpha1",
	Versions: []app.ManifestVersion{
		{
			Name:   "v0alpha1",
			Served: true,
			Kinds: []app.ManifestVersionKind{
				{
					Kind:       "Dummy",
					Plural:     "Dummys",
					Scope:      "Namespaced",
					Conversion: false,
					Schema:     &versionSchemaDummyv0alpha1,
				},
			},
			Routes: app.ManifestVersionRoutes{
				Namespaced: map[string]spec3.PathProps{
					"/alertstate/history": {
						Get: &spec3.Operation{
							OperationProps: spec3.OperationProps{

								OperationId: "getAlertstatehistory",

								Responses: &spec3.Responses{
									ResponsesProps: spec3.ResponsesProps{
										Default: &spec3.Response{
											ResponseProps: spec3.ResponseProps{
												Description: "Default OK response",
												Content: map[string]*spec3.MediaType{
													"application/json": {
														MediaTypeProps: spec3.MediaTypeProps{
															Schema: &spec.Schema{
																SchemaProps: spec.SchemaProps{
																	Type: []string{"object"},
																	Properties: map[string]spec.Schema{
																		"body": {
																			SchemaProps: spec.SchemaProps{
																				Type: []string{"object"},
																				AdditionalProperties: &spec.SchemaOrBool{
																					Allows: true,
																				},
																			},
																		},
																	},
																	Required: []string{
																		"body",
																	},
																}},
														}},
												},
											},
										},
									}},
							},
						},
					},
					"/notification/query": {
						Post: &spec3.Operation{
							OperationProps: spec3.OperationProps{

								OperationId: "createNotificationquery",

								RequestBody: &spec3.RequestBody{
									RequestBodyProps: spec3.RequestBodyProps{

										Content: map[string]*spec3.MediaType{
											"application/json": {
												MediaTypeProps: spec3.MediaTypeProps{
													Schema: &spec.Schema{
														SchemaProps: spec.SchemaProps{
															Type: []string{"object"},
															Properties: map[string]spec.Schema{
																"from": {
																	SchemaProps: spec.SchemaProps{
																		Type:        []string{"string"},
																		Format:      "date-time",
																		Description: "From is the starting timestamp for the query.",
																	},
																},
																"groupLabels": {
																	SchemaProps: spec.SchemaProps{

																		Description: "GroupLabels optionally filters the entries by matching group labels.",
																		Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryMatchers"),
																	},
																},
																"labels": {
																	SchemaProps: spec.SchemaProps{

																		Description: "Labels optionally filters the entries by matching alert labels.",
																		Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryMatchers"),
																	},
																},
																"limit": {
																	SchemaProps: spec.SchemaProps{
																		Type:        []string{"integer"},
																		Description: "Limit is the maximum number of entries to return.",
																	},
																},
																"outcome": {
																	SchemaProps: spec.SchemaProps{

																		Description: "Outcome optionally filters the entries to only either successful or failed attempts.",
																		Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationOutcome"),
																	},
																},
																"receiver": {
																	SchemaProps: spec.SchemaProps{
																		Type:        []string{"string"},
																		Description: "Receiver optionally filters the entries by receiver title (contact point).",
																	},
																},
																"ruleUID": {
																	SchemaProps: spec.SchemaProps{
																		Type:        []string{"string"},
																		Description: "RuleUID optionally filters the entries to a specific alert rule.",
																	},
																},
																"status": {
																	SchemaProps: spec.SchemaProps{

																		Description: "Status optionally filters the entries to only either firing or resolved.",
																		Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationStatus"),
																	},
																},
																"to": {
																	SchemaProps: spec.SchemaProps{
																		Type:        []string{"string"},
																		Format:      "date-time",
																		Description: "To is the starting timestamp for the query.",
																	},
																},
															},
														}},
												}},
										},
									}},
								Responses: &spec3.Responses{
									ResponsesProps: spec3.ResponsesProps{
										Default: &spec3.Response{
											ResponseProps: spec3.ResponseProps{
												Description: "Default OK response",
												Content: map[string]*spec3.MediaType{
													"application/json": {
														MediaTypeProps: spec3.MediaTypeProps{
															Schema: &spec.Schema{
																SchemaProps: spec.SchemaProps{
																	Type: []string{"object"},
																	Properties: map[string]spec.Schema{
																		"entries": {
																			SchemaProps: spec.SchemaProps{
																				Type: []string{"array"},
																				Items: &spec.SchemaOrArray{
																					Schema: &spec.Schema{
																						SchemaProps: spec.SchemaProps{

																							Ref: spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationEntry"),
																						}},
																				},
																			},
																		},
																	},
																	Required: []string{
																		"entries",
																	},
																}},
														}},
												},
											},
										},
									}},
							},
						},
					},
				},
				Cluster: map[string]spec3.PathProps{},
				Schemas: map[string]spec.Schema{
					"createNotificationqueryMatcher": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							Properties: map[string]spec.Schema{
								"label": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"string"},
									},
								},
								"type": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"string"},
										Enum: []interface{}{
											"=",
											"!=",
											"=~",
											"!~",
										},
									},
								},
								"value": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"string"},
									},
								},
							},
							Required: []string{
								"type",
								"label",
								"value",
							},
						},
					},
					"createNotificationqueryMatchers": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{

										Ref: spec.MustCreateRef("#/components/schemas/createNotificationqueryMatcher"),
									}},
							},
						},
					},
					"createNotificationqueryNotificationEntry": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							Properties: map[string]spec.Schema{
								"alerts": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"array"},
										Description: "Alerts are the alerts grouped into the notification.",
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{

													Ref: spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationEntryAlert"),
												}},
										},
									},
								},
								"duration": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"integer"},
										Description: "Duration is the length of time the notification attempt took in nanoseconds.",
									},
								},
								"error": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"string"},
										Description: "Error is the message returned by the contact point if delivery failed.",
									},
								},
								"groupKey": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"string"},
										Description: "GroupKey uniquely idenifies the dispatcher alert group.",
									},
								},
								"groupLabels": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"object"},
										Description: "GroupLabels are the labels uniquely identifying the alert group within a route.",
										AdditionalProperties: &spec.SchemaOrBool{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Type: []string{"string"},
												},
											},
										},
									},
								},
								"outcome": {
									SchemaProps: spec.SchemaProps{

										Description: "Outcome indicaes if the notificaion attempt was successful or if it failed.",
										Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationOutcome"),
									},
								},
								"pipelineTime": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"string"},
										Format:      "date-time",
										Description: "PipelineTime is the time at which the flush began.",
									},
								},
								"receiver": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"string"},
										Description: "Receiver is the receiver (contact point) title.",
									},
								},
								"retry": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"boolean"},
										Description: "Retry indicates if the attempt was a retried attempt.",
									},
								},
								"status": {
									SchemaProps: spec.SchemaProps{

										Description: "Status indicates if the notification contains one or more firing alerts.",
										Ref:         spec.MustCreateRef("#/components/schemas/createNotificationqueryNotificationStatus"),
									},
								},
								"timestamp": {
									SchemaProps: spec.SchemaProps{
										Type:        []string{"string"},
										Format:      "date-time",
										Description: "Timestamp is the time at which the notification attempt completed.",
									},
								},
							},
							Required: []string{
								"timestamp",
								"receiver",
								"status",
								"outcome",
								"groupLabels",
								"alerts",
								"retry",
								"duration",
								"pipelineTime",
								"groupKey",
							},
						},
					},
					"createNotificationqueryNotificationEntryAlert": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							Properties: map[string]spec.Schema{
								"annotations": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"object"},
										AdditionalProperties: &spec.SchemaOrBool{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Type: []string{"string"},
												},
											},
										},
									},
								},
								"endsAt": {
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "date-time",
									},
								},
								"labels": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"object"},
										AdditionalProperties: &spec.SchemaOrBool{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Type: []string{"string"},
												},
											},
										},
									},
								},
								"startsAt": {
									SchemaProps: spec.SchemaProps{
										Type:   []string{"string"},
										Format: "date-time",
									},
								},
								"status": {
									SchemaProps: spec.SchemaProps{
										Type: []string{"string"},
									},
								},
							},
							Required: []string{
								"status",
								"labels",
								"annotations",
								"startsAt",
								"endsAt",
							},
						},
					},
					"createNotificationqueryNotificationOutcome": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"string"},
							Enum: []interface{}{
								"success",
								"error",
							},
						},
					},
					"createNotificationqueryNotificationStatus": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"string"},
							Enum: []interface{}{
								"firing",
								"resolved",
							},
						},
					},
				},
			},
		},
	},
}

func LocalManifest() app.Manifest {
	return app.NewEmbeddedManifest(appManifestData)
}

func RemoteManifest() app.Manifest {
	return app.NewAPIServerManifest("alerting-historian")
}

var kindVersionToGoType = map[string]resource.Kind{
	"Dummy/v0alpha1": v0alpha1.DummyKind(),
}

// ManifestGoTypeAssociator returns the associated resource.Kind instance for a given Kind and Version, if one exists.
// If there is no association for the provided Kind and Version, exists will return false.
func ManifestGoTypeAssociator(kind, version string) (goType resource.Kind, exists bool) {
	goType, exists = kindVersionToGoType[fmt.Sprintf("%s/%s", kind, version)]
	return goType, exists
}

var customRouteToGoResponseType = map[string]any{
	"v0alpha1||<namespace>/alertstate/history|GET":  v0alpha1.GetAlertstatehistoryResponse{},
	"v0alpha1||<namespace>/notification/query|POST": v0alpha1.CreateNotificationqueryResponse{},
}

// ManifestCustomRouteResponsesAssociator returns the associated response go type for a given kind, version, custom route path, and method, if one exists.
// kind may be empty for custom routes which are not kind subroutes. Leading slashes are removed from subroute paths.
// If there is no association for the provided kind, version, custom route path, and method, exists will return false.
// Resource routes (those without a kind) should prefix their route with "<namespace>/" if the route is namespaced (otherwise the route is assumed to be cluster-scope)
func ManifestCustomRouteResponsesAssociator(kind, version, path, verb string) (goType any, exists bool) {
	if len(path) > 0 && path[0] == '/' {
		path = path[1:]
	}
	goType, exists = customRouteToGoResponseType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
	return goType, exists
}

var customRouteToGoParamsType = map[string]runtime.Object{}

func ManifestCustomRouteQueryAssociator(kind, version, path, verb string) (goType runtime.Object, exists bool) {
	if len(path) > 0 && path[0] == '/' {
		path = path[1:]
	}
	goType, exists = customRouteToGoParamsType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
	return goType, exists
}

var customRouteToGoRequestBodyType = map[string]any{
	"v0alpha1||<namespace>/notification/query|POST": v0alpha1.CreateNotificationqueryRequestBody{},
}

func ManifestCustomRouteRequestBodyAssociator(kind, version, path, verb string) (goType any, exists bool) {
	if len(path) > 0 && path[0] == '/' {
		path = path[1:]
	}
	goType, exists = customRouteToGoRequestBodyType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
	return goType, exists
}

type GoTypeAssociator struct{}

func NewGoTypeAssociator() *GoTypeAssociator {
	return &GoTypeAssociator{}
}

func (g *GoTypeAssociator) KindToGoType(kind, version string) (goType resource.Kind, exists bool) {
	return ManifestGoTypeAssociator(kind, version)
}
func (g *GoTypeAssociator) CustomRouteReturnGoType(kind, version, path, verb string) (goType any, exists bool) {
	return ManifestCustomRouteResponsesAssociator(kind, version, path, verb)
}
func (g *GoTypeAssociator) CustomRouteQueryGoType(kind, version, path, verb string) (goType runtime.Object, exists bool) {
	return ManifestCustomRouteQueryAssociator(kind, version, path, verb)
}
func (g *GoTypeAssociator) CustomRouteRequestBodyGoType(kind, version, path, verb string) (goType any, exists bool) {
	return ManifestCustomRouteRequestBodyAssociator(kind, version, path, verb)
}
